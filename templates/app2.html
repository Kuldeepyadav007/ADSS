<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Agriculture Decision support system</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet-mouse-position@1.2.0/src/L.Control.MousePosition.css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet-compass@2.0.0/dist/leaflet-compass.min.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet-search@3.0.9/dist/leaflet-search.src.css" />
  <link rel="stylesheet" href="style2.css">

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://unpkg.com/leaflet-providers@1.13.0/leaflet-providers.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jspdf-autotable@3.8.2/dist/jspdf.plugin.autotable.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
  <script src="https://unpkg.com/leaflet-mouse-position@1.2.0/src/L.Control.MousePosition.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/leaflet-compass@2.0.0/dist/leaflet-compass.min.js"></script>
  <script src="https://unpkg.com/leaflet-search@3.0.9/dist/leaflet-search.src.js"></script>
  <script src="https://unpkg.com/@tmcw/togeojson@4.3.0/dist/togeojson.umd.js"></script>

  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700;800&display=swap"
    rel="stylesheet" />

  <style>
    
    
    /* --- Toggle Switch Styles for Legend --- */
    .legend-toggles-container {
      margin-top: 12px;
      padding-top: 10px;
      border-top: 1px solid #e2e8f0;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    body.dark-mode .legend-toggles-container {
      border-top-color: #4a4a4a;
    }

    .legend-toggle-row {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 10px;
      /* Matches your legend font size */
      color: #333;
    }

    body.dark-mode .legend-toggle-row {
      color: #e8e6e3;
    }

    /* The Switch Box */
    .legend-switch {
      position: relative;
      display: inline-block;
      width: 28px;
      height: 16px;
      flex-shrink: 0;
    }

    .legend-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    /* The Slider */
    .legend-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: .4s;
      border-radius: 34px;
    }

    .legend-slider:before {
      position: absolute;
      content: "";
      height: 12px;
      width: 12px;
      left: 2px;
      bottom: 2px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
    }

    /* Checked State */
    input:checked+.legend-slider {
      background-color: var(--krishi-green);
    }

    input:checked+.legend-slider:before {
      transform: translateX(12px);
    }


    :root {
      --krishi-green: #2f7a2f;
      --krishi-dark: #1b3b2f;
      --soil: #a96b3d;
      --sky: #eef7fb;
      --card-bg: #ffffff;
      --muted: #7a7a7a;
      --accent: #5aa64a;
      --glass: rgba(255, 255, 255, 0.8);
      --shadow: 0 6px 18px rgba(15, 23, 42, 0.08);
      --radius: 16px;
      --border-color: #e2e8f0;
    }

    html,
    body {
      height: 100%;
      margin: 0;
      font-family: "Poppins", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: linear-gradient(180deg, #f7fbf6 0%, #eef7fb 100%);
      -webkit-font-smoothing: antialiased;
      color: #0f1720;
      overflow: hidden;
    }

    /* Search Control Styles - Enhanced User-Friendly Design */
    .search-control {
      position: relative;
      background: white;
      border-radius: 20px;
      border: 1px solid #d1d5db;
      display: flex;
      align-items: center;
      width: 260px;
      /* wider input area */
      height: 36px;
      padding: 0 6px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
    }

    .search-control:hover {
      box-shadow: 0 6px 24px rgba(0, 0, 0, 0.18);
      transform: translateY(-1px);
    }

    .search-control:focus-within {
      border-color: var(--krishi-green);
      box-shadow: 0 6px 24px rgba(47, 122, 47, 0.25);
    }

    .search-container {
      display: flex;
      align-items: center;
      width: 100%;
      gap: 4px;
    }

    #locationSearch {
      flex: 1;
      border: none;
      outline: none;
      background: transparent;
      font-size: 14px;
      color: #222;
      padding: 6px 8px;
      font-family: "Poppins", sans-serif;
    }

    #locationSearch::placeholder {
      color: #888;
      font-size: 13px;
    }

    #locationSearch:hover {
      background-color: #f5f9f5;
      border-color: #c8e6c9;
    }

    #locationSearch:focus {
      outline: none;
      border-color: var(--krishi-green);
      box-shadow: 0 0 0 3px rgba(47, 122, 47, 0.08);
      background-color: white;
    }

    #searchButton {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      border: none;
      background: #2f7a2f;
      color: white;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      transition: all 0.2s ease;
    }

    #searchButton:hover {
      background: #256925;
      transform: scale(1.05);
    }

    #searchButton:active {
      transform: translateY(0px);
      box-shadow: 0 2px 6px rgba(47, 122, 47, 0.3);
    }

    #searchButton i {
      font-size: 16px;
    }

    /* Search results - elegant dropdown */
    .search-results {
      position: absolute;
      top: calc(100% + 8px);
      left: 0;
      right: 0;
      background: white;
      border: 1px solid rgba(47, 122, 47, 0.15);
      border-radius: 12px;
      max-height: 320px;
      overflow-y: auto;
      display: none;
      z-index: 1001;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
      animation: slideDown 0.3s ease;
    }

    @keyframes slideDown {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .search-results::-webkit-scrollbar {
      width: 6px;
    }

    .search-results::-webkit-scrollbar-track {
      background: #f1f1f1;
      border-radius: 10px;
    }

    .search-results::-webkit-scrollbar-thumb {
      background: var(--krishi-green);
      border-radius: 10px;
    }

    .search-results::-webkit-scrollbar-thumb:hover {
      background: #27ae60;
    }

    .search-result-item {
      padding: 12px 16px;
      cursor: pointer;
      border-bottom: 1px solid #f5f5f5;
      transition: all 0.2s ease;
      font-family: "Poppins", sans-serif;
    }

    .search-result-item:hover {
      background: linear-gradient(90deg,
          rgba(47, 122, 47, 0.06) 0%,
          rgba(47, 122, 47, 0.02) 100%);
      padding-left: 20px;
    }

    .search-result-item:first-child {
      border-top-left-radius: 12px;
      border-top-right-radius: 12px;
    }

    .search-result-item:last-child {
      border-bottom: none;
      border-bottom-left-radius: 12px;
      border-bottom-right-radius: 12px;
    }

    .search-result-name {
      font-weight: 600;
      margin-bottom: 4px;
      color: #2c3e50;
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .search-result-name::before {
      font-size: 14px;
    }

    .search-result-details {
      font-size: 12px;
      color: #7f8c8d;
      line-height: 1.4;
      margin-left: 22px;
    }

    /* Loading state */
    .search-results .loading-item {
      padding: 16px;
      text-align: center;
      color: #7f8c8d;
      font-style: italic;
    }

    /* Dark Mode Support - Enhanced */
    body.dark-mode .search-control {
      background: #2c2f32;
      border-color: #444;
    }

    body.dark-mode #locationSearch {
      color: #e8e6e3;
    }

    body.dark-mode #locationSearch::placeholder {
      color: #95a5a6;
    }

    body.dark-mode #locationSearch:hover {
      background-color: #2c2f32;
      border-color: #4a4d50;
    }

    body.dark-mode #locationSearch:focus {
      background-color: #2c2f32;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(90, 166, 74, 0.15);
    }

    body.dark-mode #searchButton {
      background: linear-gradient(135deg, var(--accent) 0%, #4a943a 100%);
    }

    body.dark-mode #searchButton:hover {
      background: linear-gradient(135deg, #4a943a 0%, #3a7a2a 100%);
    }

    body.dark-mode .search-results {
      background: #242729;
      border-color: rgba(90, 166, 74, 0.2);
    }

    body.dark-mode .search-results::-webkit-scrollbar-track {
      background: #2a2d2f;
    }

    body.dark-mode .search-results::-webkit-scrollbar-thumb {
      background: var(--accent);
    }

    body.dark-mode .search-result-item {
      border-bottom-color: #3a3d40;
      color: #e8e6e3;
    }

    body.dark-mode .search-result-item:hover {
      background: linear-gradient(90deg,
          rgba(90, 166, 74, 0.12) 0%,
          rgba(90, 166, 74, 0.04) 100%);
    }

    body.dark-mode .search-result-name {
      color: #e8e6e3;
    }

    body.dark-mode .search-result-details {
      color: #95a5a6;
    }

    /* Mobile Responsive - Enhanced */
    @media (max-width: 768px) {
      .search-control {
        top: 70px;
        right: 10px;
        left: 10px;
        width: auto;
        max-width: none;
        padding: 8px;
      }

      .search-container {
        flex-direction: row;
      }

      #searchButton {
        width: auto;
        min-width: 46px;
        padding: 11px 14px;
      }

      #locationSearch {
        font-size: 15px;
        padding: 11px 16px;
      }

      .search-results {
        max-height: 280px;
      }
    }

    header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: 64px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
      padding: 8px 20px;
      background: rgba(255, 255, 255, 0.9);
      backdrop-filter: blur(8px);
      color: var(--krishi-dark);
      z-index: 1400;
      box-shadow: 0 4px 14px rgba(15, 23, 42, 0.07);
      border-bottom: 1px solid rgba(0, 0, 0, 0.04);
    }

    .brand {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .brand img {
      height: 46px;
      width: auto;
      border-radius: 8px;
    }

    .brand h1 {
      font-size: 20px;
      margin: 0;
      font-weight: 700;
      letter-spacing: 0.2px;
    }

    .header-actions {
      display: flex;
      align-items: center;
      gap: 12px;
      position: relative;
    }

    /* Language Button CSS */
    .lang-switch {
      display: inline-flex;
      gap: 6px;
      align-items: center;
      background: transparent;
      border-radius: 8px;
      padding: 4px;
    }

    .lang-btn {
      border: 1px solid #1e5eb3;
      background: transparent;
      padding: 6px 8px;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 600;
      font-size: 13px;
    }

    .lang-btn.active {
      background: var(--krishi-green);
      color: white;
      border-color: var(--krishi-green);
    }

    #darkModeToggle {
      background: transparent;
      border: 1px solid var(--border-color);
      color: var(--krishi-dark);
      width: 40px;
      height: 40px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
    }

    #darkModeToggle:hover {
      background-color: rgba(0, 0, 0, 0.05);
      transform: translateY(-2px);
    }

    #main {
      position: relative;
      display: flex;
      gap: 20px;
      padding-top: 84px;
      padding-left: 20px;
      padding-right: 20px;
      height: calc(100vh - 84px);
    }

    #sidebar {
      width: 340px;
      min-width: 340px;
      padding: 24px;
      background: var(--card-bg);
      backdrop-filter: blur(12px);
      border-radius: var(--radius);
      margin-left: 0;
      border: 1px solid rgba(255, 255, 255, 0.7);
      box-shadow: 0 8px 32px rgba(15, 23, 42, 0.1);
      overflow-y: auto;
      overflow-x: hidden;
      transition: all 0.35s cubic-bezier(0.4, 0, 0.2, 1);
      z-index: 1200;
      position: relative;
      height: calc(100vh - 120px);
    }

    #main.sidebar-collapsed #sidebar {
      min-width: 0;
      width: 0;
      padding: 0 24px;
      margin-left: 0;
      opacity: 0;
      transform: translateX(-20px);
    }

    .panel {
      padding-bottom: 1.5rem;
      margin-bottom: 1.5rem;
      border-bottom: 1px solid var(--border-color);
    }

    .panel:last-child {
      border-bottom: none;
      margin-bottom: 0;
    }

    .panel h3 {
      margin: 0 0 16px 0;
      font-size: 16px;
      display: flex;
      align-items: center;
      gap: 10px;
      color: var(--krishi-dark);
      font-weight: 600;
    }

    .panel h3 .fa-solid {
      color: var(--accent);
    }

    label {
      font-size: 13px;
      color: #334155;
      display: block;
      margin-bottom: 8px;
      font-weight: 600;
    }

    input[type="date"],
    select,
    input[type="text"],
    button {
      width: 100%;
      padding: 12px;
      border-radius: 8px;
      border: 1px solid var(--border-color);
      font-size: 14px;
      background-color: #f8fafc;
      box-sizing: border-box;
      transition: all 0.2s ease;
      color: #1e293b;
    }

    input[type="date"]:focus,
    select:focus,
    input[type="text"]:focus {
      outline: none;
      border-color: var(--accent);
      background-color: #fff;
      box-shadow: 0 0 0 3px rgba(47, 122, 47, 0.1);
    }

    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      border: none;
      cursor: pointer;
      font-weight: 700;
      color: #fff;
      background: var(--krishi-green);
      padding: 12px;
      border-radius: 10px;
      transition: transform 0.15s ease, box-shadow 0.15s ease;
      box-shadow: 0 4px 12px rgba(47, 122, 47, 0.15);
    }

    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(47, 122, 47, 0.2);
    }

    #upload-area {
      border: 2px dashed var(--border-color);
      border-radius: 12px;
      padding: 20px;
      text-align: center;
      cursor: pointer;
      transition: all 0.2s ease-in-out;
      background-color: #f8fafc;
    }

    #upload-area:hover,
    #upload-area.drag-over {
      border-color: var(--accent);
      background-color: #f0f7ee;
    }

    #upload-area .upload-icon {
      font-size: 24px;
      color: var(--accent);
      margin-bottom: 8px;
    }

    #upload-area .upload-text {
      font-size: 14px;
      font-weight: 500;
      color: #475569;
    }

    #upload-area .upload-hint {
      font-size: 12px;
      color: var(--muted);
    }

    #vectorFile {
      display: none;
    }

    #uploaded-layers-list {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    #uploaded-layers-list li {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 14px;
      padding: 8px 0;
      border-bottom: 1px solid var(--border-color);
    }

    #uploaded-layers-list li:last-child {
      border-bottom: none;
    }

    .remove-layer-btn {
      background: transparent;
      border: none;
      color: #d9534f;
      cursor: pointer;
      font-size: 16px;
    }

    /* Opacity Control Styles */
    .opacity-control {
      margin-top: 12px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .opacity-control label {
      margin-bottom: 0;
      font-size: 13px;
      font-weight: 600;
      min-width: 60px;
    }

    .opacity-slider {
      flex: 1;
      -webkit-appearance: none;
      appearance: none;
      height: 6px;
      border-radius: 3px;
      background: #d1d5db;
      outline: none;
    }

    .opacity-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: var(--krishi-green);
      cursor: pointer;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .opacity-slider::-moz-range-thumb {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: var(--krishi-green);
      cursor: pointer;
      border: none;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .opacity-value {
      font-size: 12px;
      font-weight: 600;
      color: var(--krishi-dark);
      min-width: 30px;
      text-align: center;
    }

    /* === START: UPDATED LAYOUT CSS === */
    #workspace {
      flex: 1;
      display: flex;
      /* Changed to flex row */
      height: calc(100vh - 84px);
      max-height: calc(100vh - 84px);
      margin-right: 0;
      position: relative;
      gap: 20px;
      /* Consistent gap between map and right panel */
      min-height: 0;
      overflow: hidden;
    }

    .main-panel {
      /* Replaces .map-card */
      flex: 1;
      /* Takes up remaining space */
      min-width: 0;
      /* Important for flex shrinking */
      border-radius: 14px;
      overflow: hidden;
      position: relative;
      background: #e9f7ea;
      box-shadow: var(--shadow);
      display: flex;
      flex-direction: column;
    }

    /* Layer Management Panel - Floating over map - Left side */
    /* Layer Management Panel - Positioned near left side of AOI panel */
    /* Layer Management Panel - Positioned near left side of AOI panel */
    #layer-management-panel {
      position: absolute;
      top: 20px;
      left: 360px;
      /* Position next to sidebar */
      width: 320px;
      max-height: calc(100% - 100px);
      background-color: var(--card-bg);
      border: 1px solid var(--border-color);
      border-radius: var(--radius);
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
      display: none;
      flex-direction: column;
      overflow: hidden;
      z-index: 1000;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    /* When minimized, position at bottom left (original behavior) */
    #layer-management-panel.minimized {
      width: auto;
      height: auto;
      top: auto !important;
      bottom: 20px !important;
      left: 20px !important;
      /* Back to left side when minimized */
      transform: none !important;
    }

    #layer-management-panel.minimized .layer-management-header {
      padding: 8px 12px;
      cursor: move;
    }

    .layer-management-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 16px;
      border-bottom: 1px solid var(--border-color);
      background-color: var(--card-bg);
      flex-shrink: 0;
      cursor: move;
    }

    .panel-control-btn {
      background: transparent;
      border: 1px solid var(--border-color);
      color: var(--krishi-dark);
      width: 28px;
      height: 28px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
      padding: 0;
      margin-left: 6px;
    }

    .panel-control-btn:hover {
      background-color: rgba(0, 0, 0, 0.05);
      transform: scale(1.1);
    }

    #layer-management-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 16px;
      overflow: hidden;
      min-height: 0;
      max-height: calc(100vh - 250px);
    }

    /* This rule correctly hides the content when minimized */
    #layer-management-panel.minimized #layer-management-content {
      display: none;
    }

    /* --- Dark Mode --- */
    /* --- Dark Mode --- */

    body.dark-mode #layer-management-panel {
      /* Using specific colors instead of variables */
      background-color: rgba(30, 41, 59, 0.95);
      /* Dark slate background */
      border-color: rgba(255, 255, 255, 0.2);
      /* Light border */
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    }

    body.dark-mode #layer-management-content {
      /* This sets the default text color for all items 
     inside the content area to a light gray/white */
      color: #e8e6e3;
      background-color: rgba(30, 41, 59, 0.95);
      border-color: rgba(255, 255, 255, 0.2);
    }

    body.dark-mode .layer-management-header {
      /* Using specific colors and ensuring text is light */
      background-color: rgba(30, 41, 59, 0.95);
      /* Match panel background */
      border-bottom-color: rgba(255, 255, 255, 0.2);
      /* Light border */
      color: #e8e6e3;
      /* Light color for header title text */
    }

    body.dark-mode .panel-control-btn {
      /* Updated border and icon color */
      border-color: rgba(255, 255, 255, 0.2);
      color: #e8e6e3;
      /* Light icon color */
    }

    body.dark-mode .panel-control-btn:hover {
      /* This hover effect is good for dark mode */
      background-color: rgba(255, 255, 255, 0.1);
    }

    /* Irrigation Calendar Panel Styles */
    #irrigation-calendar-panel {
      position: absolute;
      top: 20px;
      right: 20px;
      width: 450px;
      max-height: calc(100vh - 100px);
      background-color: var(--card-bg);
      border: 1px solid var(--border-color);
      border-radius: var(--radius);
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
      display: none;
      flex-direction: column;
      overflow: hidden;
      z-index: 1000;
      transition: all 0.3s cubic-bezier(0.4, 0.2, 0.2, 1);
    }

    #irrigation-calendar-panel.expanded {
      display: flex;
      width: 80%;
      height: 85%;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      max-width: 1200px;
      max-height: 90vh;
    }

    /* When minimized, position at bottom right */
    #irrigation-calendar-panel.minimized {
      width: auto;
      height: auto;
      top: auto !important;
      bottom: 20px !important;
      right: 20px !important;
      left: auto !important;
      transform: none !important;
    }

    .irrigation-calendar-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 16px;
      border-bottom: 1px solid var(--border-color);
      background-color: var(--card-bg);
      flex-shrink: 0;
      cursor: move;
    }

    #irrigation-calendar-panel.minimized .irrigation-calendar-header {
      padding: 8px 12px;
      cursor: move;
    }

    #irrigation-calendar-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 0;
      overflow-y: auto;
      min-height: 0;
      max-height: calc(100vh - 250px);
    }

    /* Hide content when minimized */
    #irrigation-calendar-panel.minimized #irrigation-calendar-content {
      display: none;
    }

    /* Dark mode styles for irrigation calendar panel */
    body.dark-mode #irrigation-calendar-panel {
      background-color: rgba(30, 41, 59, 0.95);
      border-color: rgba(255, 255, 255, 0.2);
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    }

    body.dark-mode #irrigation-calendar-content {
      color: #e8e6e3;
      background-color: rgba(30, 41, 59, 0.95);
    }

    body.dark-mode .irrigation-calendar-header {
      background-color: rgba(30, 41, 59, 0.95);
      border-bottom-color: rgba(255, 255, 255, 0.2);
      color: #e8e6e3;
    }

    /* Removed resizer-v styles since the right panel is now fixed */

    #analytics-sidebar {
      /* Increased size for better visibility */
      flex: 0 0 400px;
      /* Increased to 400px */
      min-width: 400px;
      /* Increased to 400px */
      max-width: 400px;
      /* Increased to 400px */
      width: 400px;
      /* Increased to 400px */
      height: 100%;
      max-height: 100%;
      background-color: var(--card-bg);
      border: 1px solid var(--border-color);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      display: flex;
      flex-direction: column;
      overflow: hidden;
      position: relative;
      transition: all 0.35s cubic-bezier(0.4, 0, 0.2, 1);
      visibility: visible;
      opacity: 1;
      box-sizing: border-box;
      font-size: 12px;
    }

    /* Ensure analytics sidebar content is scrollable */
    #analytics-sidebar>* {
      overflow-y: auto;
      overflow-x: hidden;
      flex: 1;
      min-height: 0;
      max-height: 100%;
    }

    #analytics-sidebar #ndvi-dashboard,
    #analytics-sidebar #default-analytics-placeholder,
    #analytics-sidebar #irrigation-calendar-card {
      overflow-y: auto;
      overflow-x: hidden;
      flex: 1;
      min-height: 0;
      max-height: 100%;
      box-sizing: border-box;
    }

    /* Right sidebar collapse behavior */
    #main.right-collapsed #analytics-sidebar {
      flex: 0 0 0 !important;
      min-width: 0 !important;
      max-width: 0 !important;
      width: 0 !important;
      padding: 0 !important;
      border-left: none;
      opacity: 0;
      transform: translateX(20px);
      visibility: hidden;
      /* Prevent content from showing during collapse */
      overflow: hidden;
    }

    /* Right toggle control */

    #map {
      flex: 1;
      min-height: 250px;
      position: relative;
    }

    /* Comparison Maps Wrapper - Replaces main map during comparison */
    #comparison-maps-wrapper {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      width: 100%;
      height: 100%;
      z-index: 500;
    }

    #comparison-maps-container {
      width: 100%;
      height: 100%;
    }

    /* =========================================
 Drawing Toolbar - Bottom Center
 (Default Light Mode)
=========================================
*/

    .drawing-toolbar {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 1000;
      display: flex;
      align-items: center;
      gap: 8px;
      /* --- LIGHT MODE (Default) --- */
      background: rgba(255, 255, 255, 0.9);
      /* White background */
      backdrop-filter: blur(10px);
      padding: 8px 12px;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      /* Lighter shadow */
    }

    .drawing-toolbar .toolbar-separator {
      width: 1px;
      height: 32px;
      /* --- LIGHT MODE --- */
      background: rgba(0, 0, 0, 0.15);
      /* Dark separator */
      margin: 0 4px;
    }

    .drawing-toolbar-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 44px;
      height: 44px;
      border: 2px solid transparent;
      /* Added for layout consistency with active */
      border-radius: 10px;
      /* --- LIGHT MODE --- */
      background: rgba(0, 0, 0, 0.05);
      /* Very light grey bg */
      color: #1f2937;
      /* Dark icon color */
      cursor: pointer;
      transition: all 0.2s ease;
      position: relative;
      /* Adjust padding for border */
      box-sizing: border-box;
    }

    .drawing-toolbar-btn:hover {
      /* --- LIGHT MODE --- */
      background: rgba(0, 0, 0, 0.1);
      /* Darker hover */
      transform: translateY(-2px);
    }

    .drawing-toolbar-btn.active {
      background: rgba(34, 197, 94, 0.2);
      border: 2px solid rgba(34, 197, 94, 0.5);
      /* --- LIGHT MODE --- */
      color: #166534;
      /* Dark green icon for active */
    }

    .drawing-toolbar-btn i {
      font-size: 18px;
    }

    .drawing-toolbar-btn.draw-polygon {
      background: rgba(59, 130, 246, 0.15);
      /* --- LIGHT MODE --- */
      color: #1e40af;
      /* Dark blue icon */
    }

    .drawing-toolbar-btn.draw-polygon.active {
      background: rgba(59, 130, 246, 0.3);
      border-color: rgba(59, 130, 246, 0.7);
      color: #1e40af;
      /* Dark blue icon */
    }

    /* =========================================
 Dark Mode Overrides
=========================================
*/

    body.dark-mode .drawing-toolbar {
      /* Your original dark background */
      background: rgba(30, 41, 59, 0.95);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }

    body.dark-mode .drawing-toolbar .toolbar-separator {
      /* Your original separator */
      background: rgba(255, 255, 255, 0.2);
    }

    body.dark-mode .drawing-toolbar-btn {
      /* Your original button style */
      background: rgba(255, 255, 255, 0.1);
      color: #fff;
      /* White icon color */
      border-color: transparent;
    }

    body.dark-mode .drawing-toolbar-btn:hover {
      /* Your original hover */
      background: rgba(255, 255, 255, 0.2);
    }

    body.dark-mode .drawing-toolbar-btn.active {
      /* Your original active style */
      background: rgba(34, 197, 94, 0.3);
      border: 2px solid rgba(34, 197, 94, 0.6);
      color: #fff;
      /* Ensure icon is white */
    }

    body.dark-mode .drawing-toolbar-btn.draw-polygon {
      /* Your original polygon style */
      background: rgba(59, 130, 246, 0.2);
      color: #fff;
      /* Ensure icon is white */
    }

    body.dark-mode .drawing-toolbar-btn.draw-polygon.active {
      /* Your original polygon active style */
      background: rgba(59, 130, 246, 0.4);
      border-color: rgba(59, 130, 246, 0.8);
      color: #fff;
      /* Ensure icon is white */
    }

    .chart-area {
      /* Replaces .chart-panel */
      height: 35vh;
      min-height: 280px;
      background: linear-gradient(180deg, #ffffff, #fbfffb);
      border-top: 1px solid #eef3ea;
      display: flex;
      /* Kept flex to manage graph-container */
      flex-direction: column;
      overflow: visible;
      /* Allow content to be fully visible */
      box-sizing: border-box;
    }

    /* Horizontal resizer between map and chart */
    .resizer-h {
      height: 6px;
      cursor: ns-resize;
      background: #e6efe6;
      border-top: 1px solid #dfe7df;
      border-bottom: 1px solid #dfe7df;
      flex: 0 0 auto;
    }

    #graph-container {
      flex: 1;
      min-height: 0;
      padding: 12px;
      display: flex;
      flex-direction: column;
      overflow: visible;
      /* Allow content to be fully visible */
      box-sizing: border-box;
      width: 100%;
    }

    /* === END: UPDATED LAYOUT CSS === */

    #spinner {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      z-index: 1300;
      display: none;
    }

    .spinner {
      border: 6px solid #f3f3f3;
      border-top: 6px solid var(--krishi-green);
      border-radius: 50%;
      width: 44px;
      height: 44px;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% {
        transform: rotate(0);
      }

      100% {
        transform: rotate(360deg);
      }
    }

    /* Custom Crop/Leaf Loader */
    .crop-loader-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(4px);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      animation: fadeInLoader 0.3s ease;
    }

    .crop-loader-overlay.show {
      display: flex;
    }

    @keyframes fadeInLoader {
      from {
        opacity: 0;
      }

      to {
        opacity: 1;
      }
    }

    .crop-loader-container {
      text-align: center;
      background: white;
      padding: 40px 50px;
      border-radius: 20px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
      animation: scaleIn 0.3s ease;
    }

    @keyframes scaleIn {
      from {
        transform: scale(0.9);
        opacity: 0;
      }

      to {
        transform: scale(1);
        opacity: 1;
      }
    }

    .crop-loader-icon {
      font-size: 80px;
      color: var(--krishi-green);
      margin-bottom: 20px;
      display: inline-block;
      animation: leafGrow 1.5s ease-in-out infinite;
      transform-origin: center bottom;
    }

    @keyframes leafGrow {

      0%,
      100% {
        transform: scale(1) rotate(0deg);
      }

      25% {
        transform: scale(1.15) rotate(-5deg);
      }

      50% {
        transform: scale(1.2) rotate(0deg);
      }

      75% {
        transform: scale(1.15) rotate(5deg);
      }
    }

    .crop-loader-text {
      font-size: 18px;
      font-weight: 600;
      color: var(--krishi-dark);
      margin-top: 15px;
      animation: pulseText 2s ease-in-out infinite;
    }

    @keyframes pulseText {

      0%,
      100% {
        opacity: 1;
      }

      50% {
        opacity: 0.6;
      }
    }

    .crop-loader-dots {
      display: inline-flex;
      gap: 8px;
      margin-top: 10px;
    }

    .crop-loader-dots span {
      width: 10px;
      height: 10px;
      background: var(--krishi-green);
      border-radius: 50%;
      animation: dotBounce 1.4s ease-in-out infinite;
    }

    .crop-loader-dots span:nth-child(1) {
      animation-delay: 0s;
    }

    .crop-loader-dots span:nth-child(2) {
      animation-delay: 0.2s;
    }

    .crop-loader-dots span:nth-child(3) {
      animation-delay: 0.4s;
    }

    @keyframes dotBounce {

      0%,
      80%,
      100% {
        transform: scale(0.8);
        opacity: 0.5;
      }

      40% {
        transform: scale(1.2);
        opacity: 1;
      }
    }

    .chart-wrap {
      flex: 1;
      min-height: 0;
      position: relative;
      overflow: visible;
      /* Allow chart to be fully visible */
      width: 100%;
      padding: 0;
      margin: 0;
      box-sizing: border-box;
    }

    #chart-placeholder {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--muted);
      text-align: center;
      font-size: 14px;
    }

    .spaced {
      margin-top: 12px;
    }

    #chart-tabs {
      display: none;
      justify-content: center;
      gap: 8px;
      margin-bottom: 12px;
      flex-shrink: 0;
    }

    .chart-tab-btn {
      padding: 6px 14px;
      font-size: 13px;
      font-weight: 600;
      border-radius: 20px;
      cursor: pointer;
      transition: all 0.2s ease;
      background-color: var(--card-bg);
      color: #334155;
      border: 1px solid var(--border-color);
      box-shadow: 0 2px 4px rgba(15, 23, 42, 0.05);
    }

    .chart-tab-btn:hover {
      background-color: #f8fafc;
      transform: translateY(-2px);
    }

    .chart-tab-btn.active {
      background-color: var(--krishi-green);
      color: #ffffff;
      border-color: var(--krishi-dark);
      box-shadow: 0 4px 10px rgba(47, 122, 47, 0.2);
    }

    /* Styles for the analytics content inside the new sidebar - Compact */
    #default-analytics-placeholder {
      display: flex;
      flex-direction: column;
      gap: 8px;
      padding: 12px;
      overflow-y: auto;
      overflow-x: hidden;
      flex: 1;
      min-height: 0;
      max-height: 100%;
      box-sizing: border-box;
      height: 100%;
      font-size: 11px;
    }

    #default-analytics-placeholder h3 {
      margin: 0 0 6px 0;
      font-size: 13px;
      font-weight: 600;
      color: var(--krishi-dark);
      text-align: center;
    }

    .analytics-chart-wrap {
      position: relative;
      flex: 1;
      min-height: 0;
      border-top: 1px solid var(--border-color);
      padding-top: 6px;
      height: 180px;
      max-height: 180px;
    }

    #default-analytics-placeholder .analytics-chart-wrap:first-of-type {
      border-top: none;
      padding-top: 0;
    }

    .analytics-chart-wrap canvas {
      max-height: 100% !important;
      width: 100% !important;
      height: 100% !important;
    }

    /* START: New NDVI Dashboard CSS - Compact */
    #ndvi-dashboard {
      padding: 6px;
      background-color: #f7f9fc;
      height: 100%;
      max-height: 100%;
      /* Important: Make it fill the sidebar */
      display: flex;
      flex-direction: column;
      overflow-y: auto;
      overflow-x: hidden;
      flex: 1;
      min-height: 0;
      box-sizing: border-box;
      font-size: 11px;
    }

    /* Reduce NDVI dashboard header size */
    #ndvi-dashboard>div:first-child h3,
    #ndvi-dashboard h3 {
      font-size: 13px !important;
      padding: 6px 8px !important;
      margin: 0 0 8px 0 !important;
    }

    body.dark-mode #ndvi-dashboard {
      background-color: #1e2021;
    }

    body.dark-mode #ndvi-dashboard h3,
    body.dark-mode #ndvi-dashboard h4 {
      color: #e8e6e3;
    }

    body.dark-mode #ndvi-dashboard .detailed-stat-card {
      background: #2c2f32;
      border-color: #4a4a4a;
    }

    body.dark-mode #ndvi-dashboard .percentiles-dist-section {
      background: #242729;
      border-color: #4a4a4a;
    }

    /* Tabs */
    .ndvi-tabs {
      display: flex;
      gap: 4px;
      margin: 8px 0;
      background-color: #eef2f7;
      border-radius: 8px;
      padding: 3px;
      flex-shrink: 0;
      /* Prevent tabs from shrinking */
    }

    body.dark-mode .ndvi-tabs {
      background-color: #2c2f32;
    }

    .ndvi-tab-btn {
      flex: 1;
      padding: 6px 8px;
      border: none;
      background-color: transparent;
      border-radius: 6px;
      font-weight: 600;
      font-size: 11px;
      cursor: pointer;
      transition: all 0.2s ease;
      color: #555;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
    }

    body.dark-mode .ndvi-tab-btn {
      color: #aaa;
    }

    .ndvi-tab-btn:hover {
      background-color: #fff;
      color: #111;
    }

    body.dark-mode .ndvi-tab-btn:hover {
      background-color: #3a3d40;
      color: #fff;
    }

    .ndvi-tab-btn.active {
      background-color: #ffffff;
      color: var(--krishi-green);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
    }

    body.dark-mode .ndvi-tab-btn.active {
      background-color: var(--krishi-green);
      color: #fff;
    }

    /* Tab Content */
    .ndvi-content-wrapper {
      flex: 1;
      overflow-y: auto;
      position: relative;
      min-height: 0;
    }

    .ndvi-tab-content {
      display: none;
      animation: fadeIn 0.4s;
    }

    .ndvi-tab-content.active {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
      }

      to {
        opacity: 1;
      }
    }

    /* --- Overview Tab --- */
    .overview-stat-card {
      background-color: #fff;
      border-radius: 10px;
      padding: 8px;
      border: 1px solid #eef2f7;
    }

    body.dark-mode .overview-stat-card {
      background-color: #2c2f32;
      border-color: #444;
    }

    .stat-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 4px;
      font-size: 11px;
      font-weight: 500;
      color: #444;
    }

    body.dark-mode .stat-header {
      color: #ccc;
    }

    .progress-bar-container {
      position: relative;
      height: 16px;
      background-color: #e9ecef;
      border-radius: 8px;
      display: flex;
      align-items: center;
    }

    body.dark-mode .progress-bar-container {
      background-color: #444;
    }

    .progress-bar {
      height: 100%;
      background-color: #e74c3c;
      border-radius: 10px;
      transition: width 0.5s ease-out;
    }

    .progress-value {
      position: absolute;
      left: 10px;
      color: #fff;
      font-weight: 700;
      font-size: 12px;
    }

    .progress-labels {
      display: flex;
      justify-content: space-between;
      font-size: 10px;
      color: #777;
      margin-top: 4px;
    }

    body.dark-mode .progress-labels {
      color: #999;
    }

    .overall-health-card {
      color: white;
      border-radius: 10px;
      padding: 8px;
      text-align: center;
      margin-top: 6px;
    }

    .health-icon {
      font-size: 24px;
    }

    .health-title {
      font-size: 10px;
      font-weight: 500;
      opacity: 0.9;
      margin-top: 3px;
    }

    .health-status-text {
      font-size: 14px;
      font-weight: 700;
      margin-top: 2px;
    }

    .health-summary {
      font-size: 10px;
      opacity: 0.9;
      margin-top: 3px;
    }

    /* --- Detailed Tab --- */
    .detailed-stats-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 6px;
    }

    .detailed-stat-card {
      background-color: #fff;
      border-radius: 8px;
      padding: 8px;
      text-align: left;
      border: 1px solid #eef2f7;
      display: flex;
      flex-direction: column;
      font-size: 10px;
    }

    .detailed-stat-card .label {
      font-size: 9px;
      color: #777;
      font-weight: 500;
      text-transform: uppercase;
    }

    body.dark-mode .detailed-stat-card .label {
      color: #999;
    }

    .detailed-stat-card .value {
      font-size: 16px;
      font-weight: 700;
      color: var(--krishi-dark);
    }

    body.dark-mode .detailed-stat-card .value {
      color: #eee;
    }

    .detailed-stat-card .icon {
      margin-top: auto;
      font-size: 14px;
      color: #aaa;
      align-self: flex-end;
    }

    .percentiles-dist-section {
      background-color: #fff;
      border-radius: 8px;
      padding: 8px;
      border: 1px solid #eef2f7;
      margin-top: 6px;
      font-size: 10px;
    }

    .percentiles-dist-section h4 {
      font-size: 12px;
      margin: 0 0 6px 0;
    }

    .percentile-dist-bar {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 5px;
      font-size: 10px;
    }

    .percentile-dist-bar .label {
      font-size: 10px;
      width: 90px;
      min-width: 90px;
    }

    .percentile-dist-bar .value {
      font-size: 10px;
      font-weight: 600;
      min-width: 45px;
    }

    .bar-track {
      flex: 1;
      height: 8px;
      background-color: #e9ecef;
      border-radius: 4px;
    }

    body.dark-mode .bar-track {
      background-color: #444;
    }

    .bar-fill {
      height: 100%;
      border-radius: 5px;
      transition: width 0.5s ease-out;
    }

    .bar-fill.orange {
      background-color: #fdba74;
    }

    .bar-fill.yellow {
      background-color: #fde047;
    }

    .bar-fill.light-green {
      background-color: #86efac;
    }

    .bar-fill.dark-green {
      background-color: #22c55e;
    }

    /* --- Visual Tab --- */
    .visual-chart-container {
      height: 180px;
      padding: 8px;
      border-radius: 8px;
    }

    .info-box-container {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-top: 8px;
    }

    .info-box,
    .tips-box {
      padding: 10px;
      border-radius: 8px;
      font-size: 12px;
    }

    .info-box {
      background-color: #eef7ff;
      border: 1px solid #d0e7ff;
    }

    .tips-box {
      background-color: #fffbeb;
      border: 1px solid #fef3c7;
    }

    body.dark-mode .info-box {
      background-color: #2a3a4a;
      border-color: #3a5a7a;
    }

    body.dark-mode .tips-box {
      background-color: #4a3c29;
      border-color: #7a6c59;
    }

    .info-box h4,
    .tips-box h4 {
      margin: 0 0 8px 0;
      font-size: 13px;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .info-box ul,
    .tips-box ul {
      list-style: none;
      margin: 0;
      padding: 0;
    }

    .info-box li,
    .tips-box li {
      margin-bottom: 4px;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .color-swatch {
      width: 12px;
      height: 12px;
      border-radius: 3px;
      display: inline-block;
    }

    .color-swatch.red {
      background-color: #ef4444;
    }

    .color-swatch.yellow {
      background-color: #facc15;
    }

    .color-swatch.light-green {
      background-color: #4ade80;
    }

    .color-swatch.dark-green {
      background-color: #22c55e;
    }

    /* Scrollbar for new panel */
    .ndvi-content-wrapper::-webkit-scrollbar,
    #analytics-sidebar::-webkit-scrollbar {
      width: 6px;
    }

    .ndvi-content-wrapper::-webkit-scrollbar-track,
    #analytics-sidebar::-webkit-scrollbar-track {
      background: transparent;
    }

    .ndvi-content-wrapper::-webkit-scrollbar-thumb,
    #analytics-sidebar::-webkit-scrollbar-thumb {
      background-color: #ccc;
      border-radius: 10px;
    }

    body.dark-mode .ndvi-content-wrapper::-webkit-scrollbar-thumb,
    body.dark-mode #analytics-sidebar::-webkit-scrollbar-thumb {
      background-color: #555;
    }

    /* END: New NDVI Dashboard CSS */

    /* Right analytics toggle button in navbar */
    #toggleRightBtn {
      background: transparent;
      border: 1px solid var(--border-color);
      color: var(--krishi-dark);
      width: 40px;
      height: 40px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
    }

    #toggleRightBtn:hover {
      background-color: rgba(0, 0, 0, 0.05);
      transform: translateY(-2px);
    }


    /* Map Legend Styles - Draggable */
    .map-legend {
      position: absolute;
      top: 5px;
      right: 60px;
      background: var(--card-bg);
      border-radius: 8px;
      padding: 8px;
      box-shadow: var(--shadow);
      border: 1px solid var(--border-color);
      z-index: 1000;
      /* Higher than irrigation calendar panel */
      max-width: 160px;
      width: 160px;
      font-size: 11px;
      display: none;
      cursor: grab;
      /* Draggable */
      user-select: none;
    }

    /* Legend header */
    .map-legend h4 {
      margin: 0 0 6px 0;
      font-size: 12px;
      font-weight: 600;
      text-align: center;
      padding-bottom: 4px;
      border-bottom: 1px solid var(--border-color);
      cursor: grab;
    }

    .map-legend.dragging {
      cursor: grabbing;
    }

    .map-legend.dragging h4 {
      cursor: grabbing;
    }

    body.dark-mode .map-legend {
      background: #242729;
      border-color: #4a4a4a;
      color: #e8e6e3;
    }

    .legend-scale {
      display: flex;
      flex-direction: column;
      gap: 3px;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 10px;
      line-height: 1.2;
    }

    .legend-label {
      font-size: 10px;
      line-height: 1.2;
      word-wrap: break-word;
    }

    .legend-color {
      width: 16px;
      height: 12px;
      min-width: 16px;
      flex-shrink: 0;
      border-radius: 2px;
      border: 1px solid rgba(0, 0, 0, 0.1);
    }

    body.dark-mode .legend-color {
      border-color: rgba(255, 255, 255, 0.1);
    }

    /* Dragging state */
    .map-legend.dragging {
      opacity: 0.9;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
      cursor: grabbing !important;
    }

    .map-legend.dragging h4 {
      cursor: grabbing !important;
    }

    .legend-label {
      flex: 1;
      font-weight: 500;
    }

    body.dark-mode {
      background: #181a1b;
      color: #e8e6e3;
    }

    body.dark-mode header {
      background: rgba(30, 32, 33, 0.9);
      color: #e8e6e3;
      box-shadow: 0 4px 14px rgba(0, 0, 0, 0.3);
      border-bottom-color: rgba(255, 255, 255, 0.1);
    }

    body.dark-mode #sidebar {
      background: #242729;
      border-color: rgba(255, 255, 255, 0.1);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
    }

    body.dark-mode .panel {
      border-bottom-color: rgba(255, 255, 255, 0.15);
    }

    body.dark-mode .panel h3 {
      color: #e8e6e3 !important;
    }

    body.dark-mode .panel h3 .fa-solid,
    body.dark-mode .panel h3 i {
      color: var(--accent) !important;
    }

    body.dark-mode label {
      color: #e8e6e3 !important;
    }

    body.dark-mode #file-name,
    body.dark-mode #uploaded-layers-container h4 {
      color: #e8e6e3;
    }

    /* Ensure all icons are visible in dark mode */
    body.dark-mode .fa-solid,
    body.dark-mode .fa-regular,
    body.dark-mode i {
      color: inherit;
    }

    body.dark-mode .btn {
      background: var(--krishi-green);
      color: white;
      border-color: var(--krishi-green);
    }

    body.dark-mode .btn:hover {
      background: #256925;
      box-shadow: 0 8px 20px rgba(47, 122, 47, 0.3);
    }

    body.dark-mode .btn i {
      color: white !important;
    }

    body.dark-mode #uploaded-layers-list li {
      border-bottom-color: rgba(255, 255, 255, 0.15);
    }

    body.dark-mode input,
    body.dark-mode select {
      border: 1px solid #4a4a4a !important;
      background-color: #2c2f32 !important;
      color: #e8e6e3 !important;
    }

    body.dark-mode input[type="date"] {
      color-scheme: dark;
    }

    body.dark-mode input:focus,
    body.dark-mode select:focus {
      border-color: var(--accent) !important;
      background-color: #333 !important;
      box-shadow: 0 0 0 3px rgba(90, 166, 74, 0.25);
      color: #e8e6e3 !important;
    }

    body.dark-mode .main-panel {
      background: #2c2f32;
    }

    body.dark-mode .chart-area {
      background: linear-gradient(180deg, #2c2f32, #242628);
      border-top: 1px solid #4a4a4a;
    }

    body.dark-mode .resizer-h {
      background: #3a3d40;
      border-top-color: #4a4a4a;
      border-bottom-color: #4a4a4a;
    }

    body.dark-mode #analytics-sidebar {
      background-color: #242729;
      border-left-color: #4a4a4a;
    }

    body.dark-mode #default-analytics-placeholder h3 {
      color: #e8e6e3 !important;
    }

    /* Analytics sidebar text visibility */
    body.dark-mode #ndvi-dashboard h3 {
      color: #e8e6e3 !important;
    }

    body.dark-mode .ndvi-tab-btn {
      color: #e8e6e3 !important;
    }

    body.dark-mode .ndvi-tab-btn.active {
      color: white !important;
    }

    body.dark-mode .overview-stat-card .stat-header {
      color: #e8e6e3 !important;
    }

    body.dark-mode .overview-stat-card .stat-header span {
      color: #e8e6e3 !important;
    }

    body.dark-mode .progress-labels span {
      color: #9ca3af !important;
    }

    body.dark-mode .progress-value {
      color: #e8e6e3 !important;
    }

    body.dark-mode .health-title {
      color: #e8e6e3 !important;
    }

    body.dark-mode .health-status-text {
      color: #e8e6e3 !important;
    }

    body.dark-mode .health-summary {
      color: #a0aec0 !important;
    }

    body.dark-mode .detailed-stat-card .label {
      color: #9ca3af !important;
    }

    body.dark-mode .detailed-stat-card .value {
      color: #e8e6e3 !important;
    }

    body.dark-mode .detailed-stat-card .icon {
      color: var(--accent) !important;
    }

    /* Layer management panel dark mode */
    body.dark-mode #layer-management-panel {
      background: #2c2f32 !important;
      border-color: #4a4a4a !important;
    }

    body.dark-mode #layer-management-panel h3 {
      color: #e8e6e3 !important;
    }

    body.dark-mode .layer-management-header {
      border-bottom-color: #4a4a4a !important;
    }

    body.dark-mode .panel-control-btn {
      color: #e8e6e3 !important;
      border-color: #4a4a4a !important;
    }

    body.dark-mode .panel-control-btn:hover {
      background: #3a3d40 !important;
    }

    body.dark-mode .analytics-chart-wrap {
      border-top-color: #4a4a4a;
    }

    body.dark-mode #toggleRightBtn {
      background: transparent;
      border-color: var(--border-color);
      color: #e8e6e3;
    }

    body.dark-mode #toggleRightBtn:hover {
      background-color: rgba(255, 255, 255, 0.1);
    }

    body.dark-mode #darkModeToggle {
      border-color: #4a4a4a;
      color: #e8e6e3;
    }

    body.dark-mode #darkModeToggle:hover {
      background-color: rgba(255, 255, 255, 0.1);
    }

    /* Bright sun icon styling - make it look like a sun, not settings */
    #darkModeToggle i.fa-sun {
      color: #ffd700 !important;
      text-shadow: 0 0 8px #ffd700, 0 0 12px #ffa500, 0 0 16px #ff8c00;
      filter: drop-shadow(0 0 4px rgba(255, 215, 0, 0.8));
    }

    /* Moon icon styling for light mode */
    #darkModeToggle i.fa-moon {
      color: #4a5568;
    }

    body.dark-mode #darkModeToggle i.fa-moon {
      color: #a0aec0;
    }

    body.dark-mode #chart-placeholder {
      color: #a0aec0 !important;
    }

    body.dark-mode #chart-placeholder p {
      color: #a0aec0 !important;
    }

    /* Dark mode search control styles */
    body.dark-mode .search-control {
      background: #2c2f32 !important;
      border-color: #4a4a4a !important;
    }

    body.dark-mode .search-control:hover {
      border-color: var(--accent) !important;
    }

    body.dark-mode .search-control:focus-within {
      border-color: var(--accent) !important;
      box-shadow: 0 6px 24px rgba(90, 166, 74, 0.3) !important;
    }

    body.dark-mode #locationSearch {
      color: #e8e6e3 !important;
      background: transparent !important;
    }

    body.dark-mode #locationSearch::placeholder {
      color: #9ca3af !important;
    }

    body.dark-mode #searchButton {
      background: #2f7a2f !important;
      color: white !important;
    }

    body.dark-mode #searchButton:hover {
      background: #256925 !important;
    }

    body.dark-mode .search-results {
      background: #2c2f32 !important;
      border-color: #4a4a4a !important;
    }

    body.dark-mode .search-result-item {
      background: #2c2f32 !important;
      border-bottom-color: #4a4a4a !important;
      color: #e8e6e3 !important;
    }

    body.dark-mode .search-result-item:hover {
      background: #3a3d40 !important;
    }

    body.dark-mode .search-result-name {
      color: #e8e6e3 !important;
    }

    body.dark-mode .search-result-details {
      color: #9ca3af !important;
    }

    body.dark-mode #upload-area {
      background-color: #2c2f32;
      border-color: #4a4a4a;
    }

    body.dark-mode #upload-area:hover,
    body.dark-mode #upload-area.drag-over {
      border-color: var(--accent);
      background-color: #3a3d40;
    }

    body.dark-mode #upload-area .upload-text {
      color: #ccc !important;
    }

    body.dark-mode .upload-hint {
      color: #9ca3af !important;
    }

    body.dark-mode .upload-icon i {
      color: var(--accent) !important;
    }

    body.dark-mode .chart-tab-btn {
      background: #3a3d40;
      color: #e8e6e3;
      border-color: #555;
    }

    body.dark-mode .chart-tab-btn:hover {
      background-color: #4a4d50;
    }

    body.dark-mode .chart-tab-btn.active {
      background-color: var(--accent);
      color: #ffffff;
      border-color: #4a943a;
      box-shadow: 0 4px 10px rgba(90, 166, 74, 0.2);
    }

    body.dark-mode #sidebar::-webkit-scrollbar-thumb {
      background-color: #555;
    }

    body.dark-mode #sidebar::-webkit-scrollbar-thumb:hover {
      background-color: #777;
    }

    #sidebar::-webkit-scrollbar {
      width: 8px;
    }

    #sidebar::-webkit-scrollbar-track {
      background: transparent;
    }

    #sidebar::-webkit-scrollbar-thumb {
      background-color: #ccc;
      border-radius: 10px;
      border: 2px solid transparent;
      background-clip: content-box;
    }

    /* Dark mode for irrigation calendar display content */
    body.dark-mode #irrigation-calendar-display {
      background-color: #242729 !important;
      color: #e8e6e3 !important;
    }

    body.dark-mode #irrigation-calendar-display>div {
      background: #2c2f32 !important;
    }

    body.dark-mode #irrigation-calendar-display>div>div {
      background: #2c2f32 !important;
      border-color: #4a4a4a !important;
      color: #e8e6e3 !important;
    }

    body.dark-mode #irrigation-calendar-display strong {
      color: #e8e6e3 !important;
    }

    body.dark-mode #irrigation-calendar-display .icon-heading {
      color: #e8e6e3 !important;
    }

    /* Dark mode for added layers list */
    body.dark-mode #added-layers-list {
      background-color: #242729 !important;
    }

    body.dark-mode #added-layers-list>div {
      background: #2c2f32 !important;
      border-color: #4a4a4a !important;
      color: #e8e6e3 !important;
    }

    body.dark-mode #added-layers-list label {
      color: #e8e6e3 !important;
    }

    body.dark-mode #added-layers-list input[type="checkbox"] {
      border-color: #4a4a4a !important;
    }

    #hamburger-menu,
    #closeSidebarBtn {
      display: none;
    }

    @media (max-width: 1000px) {
      body {
        overflow: auto;
      }

      header .brand h1 {
        font-size: 18px;
      }

      .brand img {
        display: none;
      }

      #main {
        flex-direction: column;
        padding-top: 64px;
        gap: 0;
        height: auto;
      }

      #hamburger-menu {
        display: block;
        background: transparent;
        border: none;
        cursor: pointer;
        z-index: 1700;
        color: var(--krishi-dark);
        font-size: 20px;
        padding: 0 10px 0 0;
      }

      body.dark-mode #hamburger-menu {
        color: #e8e6e3;
      }

      #main::after {
        content: "";
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0, 0, 0, 0.5);
        z-index: 1500;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      }

      #main:not(.sidebar-collapsed)::after {
        opacity: 1;
        visibility: visible;
      }

      #workspace {
        width: 100%;
        height: auto;
        margin: 0;
        margin-right: 0;
        padding: 20px;
        box-sizing: border-box;
        flex-direction: column;
        /* Stack panels vertically */
        gap: 16px;
        /* Add space between panels */
      }

      #main {
        padding-left: 0;
        padding-right: 0;
        gap: 0;
      }

      #analytics-sidebar {
        width: 100%;
        /* Take full width */
        height: auto;
        min-height: 400px;
        flex-basis: auto;
        /* Reset flex basis */
        border-left: 1px solid var(--border-color);
        /* Keep border consistent */
        /* Ensure full visibility on mobile */
        opacity: 1 !important;
        visibility: visible !important;
        transform: none !important;
      }

      /* Ensure right panel is visible when not collapsed on mobile */
      #main:not(.right-collapsed) #analytics-sidebar {
        width: 100% !important;
        min-width: 100% !important;
        max-width: 100% !important;
        flex: 0 0 100% !important;
        opacity: 1 !important;
        visibility: visible !important;
        transform: none !important;
      }

      body.dark-mode #analytics-sidebar {
        border-left-color: var(--border-color);
      }

      #sidebar {
        position: fixed;
        top: 0;
        left: 0;
        width: 80%;
        max-width: 320px;
        height: 100%;
        margin: 0;
        margin-left: 0;
        border-radius: 0;
        border-right: 1px solid var(--border-color);
        box-shadow: 5px 0 40px rgba(15, 23, 42, 0.2);
        z-index: 1600;
        transform: translateX(0);
        transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      }

      body.dark-mode #sidebar {
        border-right-color: rgba(255, 255, 255, 0.1);
      }

      #main.sidebar-collapsed #sidebar {
        transform: translateX(-105%);
        min-width: unset;
        width: 80%;
      }

      #closeSidebarBtn {
        display: block;
        position: absolute;
        top: 15px;
        right: 15px;
        background: transparent;
        border: none;
        cursor: pointer;
        color: #999;
        padding: 5px;
        line-height: 1;
        font-size: 28px;
      }

      body.dark-mode #closeSidebarBtn {
        color: #ccc;
      }

      .stats-grid {
        grid-template-columns: repeat(2, 1fr);
        gap: 6px;
      }

      .percentiles-section,
      .health-indicator {
        padding: 8px;
      }

      .map-legend {
        bottom: 10px;
        right: 10px;
        max-width: 160px;
        font-size: 11px;
      }

      /* Enhanced mobile styles */
      header {
        padding: 8px 12px;
        height: 56px;
      }

      .header-actions {
        gap: 8px;
      }

      .search-control {
        width: 180px;
        max-width: calc(100vw - 200px);
      }

      #locationSearch {
        font-size: 13px;
        padding: 4px 6px;
      }

      .lang-switch {
        font-size: 12px;
      }

      .drawing-toolbar {
        bottom: 70px;
        padding: 8px;
        gap: 6px;
      }

      .drawing-toolbar-btn {
        width: 36px;
        height: 36px;
        font-size: 14px;
      }

      .main-panel {
        min-height: 400px;
      }

      #map {
        min-height: 300px;
        height: 400px;
      }

      .chart-area {
        min-height: 300px;
      }

      .chart-tabs {
        flex-wrap: wrap;
        gap: 4px;
      }

      .chart-tab-btn {
        font-size: 11px;
        padding: 6px 10px;
        flex: 1 1 auto;
        min-width: 80px;
      }
    }

    /* Tablet styles (768px - 1024px) */
    @media (min-width: 768px) and (max-width: 1024px) {
      #main {
        flex-direction: row;
      }

      #sidebar {
        width: 280px;
        max-width: 280px;
        position: relative;
        transform: none;
      }

      #workspace {
        flex: 1;
        padding: 16px;
      }

      #analytics-sidebar {
        width: 260px;
        min-width: 260px;
        height: 100%;
        max-height: 100%;
      }

      #workspace {
        height: calc(100vh - 84px);
        max-height: calc(100vh - 84px);
        min-height: 0;
        overflow: hidden;
      }

      .search-control {
        width: 220px;
      }

      #map {
        height: 500px;
      }

      .chart-tabs {
        flex-wrap: nowrap;
      }

      .stats-grid {
        grid-template-columns: repeat(3, 1fr);
      }
    }

    /* Small mobile devices (< 480px) */
    @media (max-width: 480px) {
      header {
        height: 52px;
        padding: 6px 10px;
      }

      .brand h1 {
        font-size: 14px;
      }

      .search-control {
        width: 140px;
        max-width: calc(100vw - 160px);
      }

      #locationSearch {
        font-size: 12px;
        padding: 3px 4px;
      }

      #workspace {
        padding: 12px;
      }

      #map {
        height: 300px;
        min-height: 250px;
      }

      .chart-tab-btn {
        font-size: 10px;
        padding: 5px 8px;
        min-width: 70px;
      }

      .stats-grid {
        grid-template-columns: 1fr;
        gap: 8px;
      }

      .overview-stat-card,
      .detailed-stat-card {
        padding: 10px;
      }

      .drawing-toolbar {
        bottom: 60px;
        padding: 6px;
      }

      .drawing-toolbar-btn {
        width: 32px;
        height: 32px;
        font-size: 12px;
      }

      .layer-management-panel {
        max-width: 90vw;
        width: 90vw;
      }
    }

    /* Landscape orientation for tablets */
    @media (min-width: 768px) and (max-width: 1024px) and (orientation: landscape) {
      #main {
        flex-direction: row;
      }

      #map {
        height: 60vh;
        min-height: 400px;
      }

      #workspace {
        height: calc(100vh - 84px);
        max-height: calc(100vh - 84px);
      }

      #analytics-sidebar {
        height: 100%;
        max-height: 100%;
        overflow: hidden;
      }
    }

    /* Large screens (laptops and desktops) - Better UX */
    @media (min-width: 1025px) {
      #workspace {
        height: calc(100vh - 84px);
        max-height: calc(100vh - 84px);
        min-height: 0;
        overflow: hidden;
      }

      #analytics-sidebar {
        height: 100%;
        max-height: 100%;
        flex: 0 0 280px;
        min-width: 280px;
        max-width: 280px;
        width: 280px;
      }
    }

    /* Large desktop (> 1400px) */
    @media (min-width: 1400px) {
      #sidebar {
        width: 380px;
      }

      #analytics-sidebar {
        width: 450px;
        flex: 0 0 300px;
        min-width: 300px;
        max-width: 300px;
      }

      #workspace {
        padding: 1px;
        height: calc(100vh - 84px);
        max-height: calc(100vh - 84px);
      }
    }

    /* Add to your existing CSS */
    #irrigation-calendar-card {
      background: var(--card-bg);
      border-radius: var(--radius);
      border: 1px solid var(--border-color);
      display: flex;
      flex-direction: column;
      flex: 1;
      overflow: hidden;
      height: 100%;
    }

    body.dark-mode #irrigation-calendar-card {
      background: #242729;
      border-color: #4a4a4a;
    }

    .irrigation-event {
      transition: all 0.2s ease;
    }

    .irrigation-event:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    }

  </style>
</head>

<body>
  <!-- Custom Crop/Leaf Loader -->
  <div id="cropLoader" class="crop-loader-overlay">
    <div class="crop-loader-container">
      <div class="crop-loader-icon">
        <i class="fas fa-seedling"></i>
      </div>
      <div class="crop-loader-text">Generating Report...</div>
      <div class="crop-loader-dots">
        <span></span>
        <span></span>
        <span></span>
      </div>
    </div>
  </div>

  <header>
    <div class="brand">
      <button id="hamburger-menu" title="Open Controls">
        <i class="fa-solid fa-bars"></i>
      </button>
      <img src="/static/logo.png" alt="KrishiZest logo" />

    </div>

    <div class="header-actions">
      <div class="lang-switch" role="tablist" aria-label="Language switch">
        <button class="lang-btn" data-lang="en" style="color: #0ea84e">
          EN
        </button>
        <button class="lang-btn" data-lang="hi" style="color: #0ea84e">
          
        </button>
      </div>

      <!--  Search bar moved to header -->
      <div class="search-control">
        <div class="search-container">
          <input type="text" id="locationSearch" data-i18n="opt_search_placeholder" placeholder="Search for location..."
            autocomplete="off" />
          <button id="searchButton">
            <i class="fa-solid fa-search"></i>
          </button>
        </div>
        <div class="search-results" id="searchResults"></div>
      </div>

      <button id="darkModeToggle" title="Toggle Dark Mode">
        <i class="fa-solid fa-moon"></i>
      </button>
    </div>
  </header>

  <div id="main">
    <aside id="sidebar" role="complementary" aria-label="Controls panel">
      <button id="closeSidebarBtn" title="Close Controls">&times;</button>
      <div class="panel">
        <h3>
          <i class="fa-solid fa-calendar-days"></i>
          <span data-i18n="select_date_range">Select Date Range</span>
        </h3>
        <label for="start" data-i18n="start_date_label">Start Date</label>
        <input id="start" type="date" max="" />
        <label for="end" style="margin-top: 10px" data-i18n="end_date_label">End Date</label>
        <input id="end" type="date" max="" />
        <div class="spaced">
          <button class="btn" onclick="fetchData()">
            <i class="fa-solid fa-cloud-arrow-down"></i>&nbsp;
            <span data-i18n="fetch_data">Fetch Data</span>
          </button>
        </div>
      </div>
      <div class="panel">
        <h3>
          <i class="fa-solid fa-layer-group"></i>
          <span data-i18n="display_layer">Display Layer</span>
        </h3>
        <label for="layer" data-i18n="choose_layer">Choose a layer to display on the map</label>
        <select id="layer">
          <option value="" disabled selected data-i18n="select_layer_placeholder">
            Select a layer...
          </option>
          <option value="rgb" data-i18n="opt_rgb">FCC</option>
          <option value="ndvi" data-i18n="opt_ndvi">Crop Health</option>
          <option value="savi" data-i18n="opt_savi">Soil Adjusted Vegetation</option>
          <option value="cwsi" data-i18n="opt_cwsi">Crop Water Stress</option>
          <option value="lst" data-i18n="opt_lst">Temperature</option>
          <option value="lai" data-i18n="opt_lai">Leaf Area Index</option>
          <option value="kc" data-i18n="opt_kc">Water Evapotranspiration</option>
          <option value="etc" data-i18n="opt_etc">Total Water Loss</option>
          <option value="irrigation_need" data-i18n="opt_irrigation_need">Irrigation Need</option>


          <!-- <option value="cwr" data-i18n="opt_cwr">Crop Water Requirement</option> -->
          <option value="soilmoisture" data-i18n="opt_soilmoisture">Soil Moisture</option>

        </select>

        <!-- Opacity Control -->
        <div class="opacity-control" id="opacity-control" style="display: none">
          <label for="opacity-slider"><span data-i18n="opt_op">Opacity:</span></label>
          <input type="range" id="opacity-slider" class="opacity-slider" min="0" max="100" value="100" />
          <span class="opacity-value" id="opacity-value">100%</span>
        </div>

        <div class="spaced">
          <button id="addLayerBtn" class="btn" style="display: none">
            <i class="fa-solid fa-plus-circle"></i>&nbsp;
            <span data-i18n="add_layer">Add Selected Layer</span>
          </button>
        </div>
      </div>
      <div class="panel">
        <h3>
          <i class="fa-solid fa-map"></i>
          <span data-i18n="map_controls">Map Controls</span>
        </h3>
        <div class="spaced">
          <button id="clearMapBtn" class="btn" onclick="clearMap()">
            <i class="fa-solid fa-rotate-left"></i>&nbsp;

            <span data-i18n="clear_all_layers">Clear All Layers</span>
          </button>
        </div>
      </div>

      <div class="panel">
        <h3>
          <i class="fa-solid fa-cloud-arrow-up"></i>
          <span data-i18n="upload_vector_file">Upload Vector File</span>
        </h3>
        <label for="vectorFile" id="upload-area">
          <div class="upload-icon">
            <i class="fa-solid fa-cloud-arrow-up"></i>
          </div>
          <div class="upload-text" data-i18n="drag_drop_click">
            Drag & drop or click
          </div>
          <div class="upload-hint">.geojson, .json, .kml</div>
        </label>
        <input id="vectorFile" type="file" accept=".geojson,.json,.kml" />
        <div id="uploaded-layers-container" style="margin-top: 15px; display: none">
          <h4 style="font-size: 14px; margin-bottom: 8px">
            <span data-i18n="opt_lo">Loaded Layers:</span>
          </h4>
          <ul id="uploaded-layers-list"></ul>
        </div>
      </div>
      <!-- Add this in the sidebar after the existing panels -->
      <div class="panel">
        <h3 style="display: flex; align-items: center; justify-content: space-between; gap: 10px;">
          <span style="display: flex; align-items: center; gap: 10px; flex: 1;">
            <i class="fa-solid fa-calendar-check"></i>
            <span data-i18n="irrigation_calendar">Irrigation Calendar</span>
          </span>
          <!-- <button
      id="minimizeIrrigationPanelBtn"
      class="panel-control-btn"
      style="display: flex;"
      title="Minimize Panel"
    >
      <i class="fa-solid fa-minus"></i>
    </button> -->
          <button id="maximizeIrrigationPanelBtn" class="panel-control-btn" style="display: none;"
            title="Maximize Panel">
            <i class="fa-solid fa-plus"></i>
          </button>
        </h3>
        <div class="spaced">
          <button id="irrigationCalendarBtn" class="btn">
            <i class="fa-solid fa-calendar-days"></i>&nbsp;
            <span data-i18n="generate_calendar">Generate Irrigation Calendar</span>
          </button>
        </div>
      </div>
      <div class="panel">
        <h3>
          <i class="fa-solid fa-download"></i>
          <span data-i18n="export_chart"><span data-i18n="opt_ex">Export Chart</span></span>
        </h3>
        <div style="display: flex; flex-direction: column; gap: 8px">
          <button class="btn" style="background: #37a8fe; color: #fff; width: 100%" onclick="generateReportPDF()">
            <i class="fa-solid fa-file-pdf"></i></i>&nbsp; Generate Report
            (PDF)
          </button>
        </div>
      </div>
    </aside>

    <section id="workspace">
      <div class="main-panel">
        <!-- Map Legend -->
        <div id="map-legend" class="map-legend"></div>

        <div id="spinner">
          <div class="spinner"></div>
        </div>

        <div id="map" aria-label="Map showing field layers">
          <!-- Comparison Maps Container - Replaces main map during comparison -->
          <div id="comparison-maps-wrapper" style="
                display: none;
                width: 100%;
                height: 100%;
                position: relative;
              ">
            <!-- Comparison maps will be created here -->
          </div>

          <!-- Layer Management Panel - Floating over map -->
          <aside id="layer-management-panel">
            <div class="layer-management-header">
              <h3 style="
                    margin: 0;
                    font-size: 16px;
                    font-weight: 600;
                    color: var(--krishi-dark);
                    display: flex;
                    align-items: center;
                    gap: 8px;
                    flex: 1;
                  ">
                <i class="fa-solid fa-layer-group" style="color: var(--krishi-green)"></i>
                <span data-i18n="opt_lm">Layer Management</span>
              </h3>
              <button id="minimizeLayerPanelBtn" class="panel-control-btn" title="Minimize Panel">
                <i class="fa-solid fa-minus"></i>
              </button>
              <button id="maximizeLayerPanelBtn" class="panel-control-btn" style="display: none" title="Maximize Panel">
                <i class="fa-solid fa-plus"></i>
              </button>
            </div>
            <div id="layer-management-content">
              <div id="added-layers-list" style="
                    display: flex;
                    flex-direction: column;
                    gap: 8px;
                    overflow-y: auto;
                    flex: 1;
                  ">
                <!-- Added layers will appear here -->
              </div>
              <div id="compare-layers-section" style="
                    display: none;
                    margin-top: 16px;
                    padding-top: 16px;
                    border-top: 1px solid var(--border-color);
                    flex-shrink: 0;
                  ">
                <button id="compareLayersBtn" class="btn" style="
                      width: 100%;
                      background: var(--krishi-green);
                      color: white;
                      border: none;
                    ">
                  <i class="fa-solid fa-chart-line"></i>
                  <span data-i18n="opt_csl">Compare Selected Layers</span>
                </button>
                <button id="closeComparisonBtn" class="btn" style="
                      width: 100%;
                      margin-top: 8px;
                      background: #ef4444;
                      color: white;
                      border: none;
                      display: none;
                    ">
                  <i class="fa-solid fa-times"></i>
                  <span data-i18n="opt_cc">Close Comparison</span>
                </button>
              </div>
              <div id="layer-comparison-view" style="
                    display: none;
                    margin-top: 16px;
                    overflow-y: auto;
                    max-height: 500px;
                  ">
                <!-- Comparison maps will appear here -->
              </div>
            </div>
          </aside>

          <!-- Drawing Toolbar - Bottom Center -->
          <div class="drawing-toolbar">
            <button id="drawPolygonBtn" class="drawing-toolbar-btn draw-polygon"
              data-i18n-title="opt_draw_polygon_title" title="Draw Polygon">
              <i class="fa-solid fa-draw-polygon"></i>
            </button>
            <button id="drawRectangleBtn" class="drawing-toolbar-btn" data-i18n-title="opt_draw_rectangle_title"
              title="Draw Rectangle">
              <i class="fa-regular fa-square"></i>
            </button>
            <div class="toolbar-separator"></div>
            <button id="editShapesBtn" class="drawing-toolbar-btn" data-i18n-title="opt_edit_shapes_title"
              title="Edit Shapes">
              <i class="fa-solid fa-pen"></i>
            </button>
            <button id="saveEditsBtn" class="drawing-toolbar-btn" data-i18n-title="opt_save_changes_title"
              title="Save Changes">
              <i class="fa-solid fa-check"></i>
            </button>
            <button id="deleteShapesBtn" class="drawing-toolbar-btn" data-i18n-title="opt_delete_shapes_title"
              title="Delete Shapes">
              <i class="fa-solid fa-trash-can"></i>
            </button>
          </div>
        </div>

        <!-- Irrigation Calendar Panel - Floating over map -->
        <aside id="irrigation-calendar-panel" style="display: none;">
          <div class="irrigation-calendar-header">
            <h3 style="
                    margin: 0;
                    font-size: 16px;
                    font-weight: 600;
                    color: var(--krishi-dark);
                    display: flex;
                    align-items: center;
                    gap: 10 px;
                    flex: 1;
                  ">
              <i class="fa-solid fa-calendar-check" style="color: var(--krishi-green)"></i>
              <span data-i18n="irrigation_calendar">Irrigation Calendar</span>
            </h3>
            <button id="minimizeIrrigationPanelFullBtn" class="panel-control-btn" title="Minimize Panel">
              <i class="fa-solid fa-minus"></i>
            </button>
            <button id="maximizeIrrigationPanelFullBtn" class="panel-control-btn" style="display: none"
              title="Maximize Panel">
              <i class="fa-solid fa-plus"></i>
            </button>
          </div>
          <div id="irrigation-calendar-content">
            <div style="padding: 20px; display: flex; flex-direction: column; height: 100%;">
              <div id="irrigation-calendar-button-container" class="spaced" style="margin-bottom: 20px;">
                <button id="irrigationCalendarBtnFull" class="btn" style="width: 100%;">
                  <i class="fa-solid fa-calendar-days"></i>&nbsp;
                  <span data-i18n="generate_calendar">Generate Irrigation Calendar</span>
                </button>
              </div>
              <div id="irrigation-calendar-loading"
                style="display: none; text-align: center; padding: 40px; color: var(--muted);">
                <i class="fa-solid fa-spinner fa-spin"
                  style="font-size: 24px; margin-bottom: 16px; display: block;"></i>
                <p style="margin: 0; font-size: 14px;">Data is fetching...</p>
              </div>
              <div id="irrigation-calendar-display"
                style="margin-top: 20px; flex: 1; overflow-y: auto; min-height: 0; display: none;">
                <!-- Irrigation calendar content will appear here -->
              </div>
            </div>
          </div>
        </aside>

        <div id="resizer-h" class="resizer-h" title="Resize panels"></div>
        <div class="chart-area">
          <div id="graph-container">
            <div id="chart-tabs">
              <button class="chart-tab-btn active" data-param="ndvi">
                <span data-i18n="opt_ndvi">Crop Health</span>
              </button>
              <button class="chart-tab-btn" data-param="savi">
                <span data-i18n="opt_savi">Soil Adjusted Index</span>
              </button>
              <button class="chart-tab-btn" data-param="cwsi">
                <span data-i18n="opt_cwsi">Water Stress</span>
              </button>
              <button class="chart-tab-btn" data-param="kc">
                <span data-i18n="opt_kc">Water Evapotranspiration</span>
              </button>
              <button class="chart-tab-btn" data-param="etc">
                <span data-i18n="opt_etc">Total Water Loss</span>
              </button>
              <!-- <button class="chart-tab-btn" data-param="cwr">
                  <span data-i18n="opt_cwr">Crop Water Requirement</span>
                </button> -->
              <button class="chart-tab-btn" data-param="irrigation_need"><span
                  data-i18n="opt_irrigation_need">Irrigation Need</span></button>


              <button class="chart-tab-btn" data-param="soilmoisture_mm">
                <span data-i18n="opt_soilmoisture">Soil Moisture</span>
              </button>
              <button class="chart-tab-btn" data-param="lst">
                <span data-i18n="opt_lst">Temperature</span>
              </button>
              <button class="chart-tab-btn" data-param="lai">
                <span data-i18n="opt_lai">Leaf Area Index</span>
              </button>
              <button class="chart-tab-btn" data-param="weather">
                <span data-i18n="opt_w">Weather</span>
              </button>
            </div>
            <div id="weather-parameter-dropdown" style="display: none; margin-bottom: 12px; text-align: center">
              <label for="weather-param-select" style="
                    font-size: 13px;
                    font-weight: 600;
                    color: var(--krishi-dark);
                    margin-right: 8px;
                  "><span data-i18n="opt_wp">Weather Parameter:</span></label>
              <select id="weather-param-select" style="
                    padding: 6px 12px;
                    border-radius: 8px;
                    border: 1px solid var(--border-color);
                    background: var(--card-bg);
                    color: var(--krishi-dark);
                    font-size: 13px;
                  ">
                <option value="eto" data-i18n="opt_evt">
                  Evapotranspiration (ET) (mm)
                </option>
                <option value="precipitation" data-i18n="opt_rp">
                  Rainfall/Precipitation (mm)
                </option>
                <option value="temperature" data-i18n="opt_tmp">
                  Temperature (K)
                </option>
                <option value="humidity" data-i18n="opt_hum">
                  Humidity (%)
                </option>
              </select>
            </div>
            <div class="chart-wrap">
              <div id="chart-placeholder">
                <p>
                  <span data-i18n="opt_Draw">Draw a polygon, select dates, and click "Fetch
                    Data".</span>
                </p>
              </div>
              <canvas id="timeseriesChart"></canvas>
            </div>
          </div>
        </div>
      </div>
      <aside id="analytics-sidebar">
        <div id="ndvi-dashboard" style="display: none">
          <div style="
                text-align: center;
                padding: 8px 8px 16px 8px;
                border-bottom: 1px solid var(--border-color);
                flex-shrink: 0;
              ">
            <h3 style="
                  display: inline;
                  margin: 0;
                  font-size: 16px;
                  font-weight: 600;
                  color: var(--krishi-dark);
                ">
              <i class="fa-solid fa-leaf" style="color: var(--krishi-green)"></i>
              <span data-i18n="opt_nst">Crop Health Statistics</span>
            </h3>
          </div>

          <div class="ndvi-tabs">
            <button class="ndvi-tab-btn active" data-tab="overview">
              <i class="fa-solid fa-chart-pie"></i>
              <span data-i18n="opt_overview">Overview</span>
            </button>
            <button class="ndvi-tab-btn" data-tab="detailed">
              <i class="fa-solid fa-list-ol"></i>
              <span data-i18n="opt_detailed">Detailed</span>
            </button>
            <button class="ndvi-tab-btn" data-tab="visual">
              <i class="fa-solid fa-chart-bar"></i>
              <span data-i18n="opt_visual">Visual</span>
            </button>
          </div>

          <div class="ndvi-content-wrapper">
            <div id="overview-tab" class="ndvi-tab-content active">
              <div class="overview-stat-card">
                <div class="stat-header">
                  <span><span data-i18n="opt_meana">Mean (Average Health)</span></span><i class="fa-solid fa-bullseye"
                    style="color: #e74c3c"></i>
                </div>
                <div class="progress-bar-container">
                  <div class="progress-bar" id="overview-mean-bar"></div>
                  <span class="progress-value" id="overview-mean-value">--</span>
                </div>
                <div class="progress-labels">
                  <span id="overview-min1"><span data-i18n="opt_min">Min</span>: --</span><span id="overview-max1"><span
                      data-i18n="opt_max">Max</span>: --</span>
                </div>
              </div>
              <div class="overview-stat-card">
                <div class="stat-header">
                  <span data-i18n="opt_median">Median (Middle Value)</span><i class="fa-solid fa-bullseye"
                    style="color: #e74c3c"></i>
                </div>
                <div class="progress-bar-container">
                  <div class="progress-bar" id="overview-median-bar"></div>
                  <span class="progress-value" id="overview-median-value">--</span>
                </div>
                <div class="progress-labels">
                  <span id="overview-min2"><span data-i18n="opt_min">Min</span>: --</span><span id="overview-max2"><span
                      data-i18n="opt_max">Max</span>: --</span>
                </div>
              </div>
              <div class="overview-stat-card">
                <div class="stat-header">
                  <span data-i18n="opt_p75">P75 (Top 25% Health)</span><i class="fa-solid fa-arrow-up"
                    style="color: #27ae60"></i>
                </div>
                <div class="progress-bar-container">
                  <div class="progress-bar" id="overview-p75-bar"></div>
                  <span class="progress-value" id="overview-p75-value">--</span>
                </div>
                <div class="progress-labels">
                  <span id="overview-min3"><span data-i18n="opt_min">Min</span>: --</span><span id="overview-max3"><span
                      data-i18n="opt_max">Max</span>: --</span>
                </div>
              </div>
              <div class="overview-stat-card">
                <div class="stat-header">
                  <span data-i18n="opt_p25">P25 (Bottom 25%)</span><i class="fa-solid fa-arrow-down"
                    style="color: #f39c12"></i>
                </div>
                <div class="progress-bar-container">
                  <div class="progress-bar" id="overview-p25-bar"></div>
                  <span class="progress-value" id="overview-p25-value">--</span>
                </div>
                <div class="progress-labels">
                  <span id="overview-min4"><span data-i18n="opt_min">Min</span>: --</span><span id="overview-max4"><span
                      data-i18n="opt_max">Max</span>: --</span>
                </div>
              </div>
              <div class="overall-health-card" id="overall-health-card">
                <div class="health-icon" id="health-emoji"></div>
                <div class="health-title" data-i18n="opt_overall_health">
                  Overall Crop Health Status
                </div>
                <div class="health-status-text" id="health-status-text">
                  --
                </div>
                <div class="health-summary" id="health-summary">
                  <span data-i18n="opt_average">Average</span>: -- |
                  <span data-i18n="opt_range_label">Range</span>: --
                </div>
              </div>
            </div>
            <div id="detailed-tab" class="ndvi-tab-content">
              <div class="detailed-stats-grid">
                <div class="detailed-stat-card">
                  <span class="label" data-i18n="opt_mean_label">MEAN</span><i class="fas fa-wave-square icon"></i><span
                    class="value" id="detailed-mean">--</span>
                </div>
                <div class="detailed-stat-card">
                  <span class="label" data-i18n="opt_median_label">MEDIAN</span><i
                    class="fas fa-balance-scale-left icon"></i><span class="value" id="detailed-median">--</span>
                </div>
                <div class="detailed-stat-card">
                  <span class="label" data-i18n="opt_stddev">STD DEV</span><i class="fas fa-chart-line icon"></i><span
                    class="value" id="detailed-stddev">--</span>
                </div>
                <div class="detailed-stat-card">
                  <span class="label" data-i18n="opt_min_label">MIN</span><i class="fas fa-arrow-down icon"></i><span
                    class="value" id="detailed-min">--</span>
                </div>
                <div class="detailed-stat-card">
                  <span class="label" data-i18n="opt_max_label">MAX</span><i class="fas fa-arrow-up icon"></i><span
                    class="value" id="detailed-max">--</span>
                </div>
                <div class="detailed-stat-card">
                  <span class="label" data-i18n="opt_range">RANGE</span><i class="fas fa-arrows-alt-h icon"></i><span
                    class="value" id="detailed-range">--</span>
                </div>
              </div>

              <!-- Land Cover Pie Chart Section -->
              <div class="percentiles-dist-section" style="margin-top: 12px">
                <h4 style="display: flex; align-items: center; gap: 8px">
                  <i class="fa-solid fa-chart-pie" style="color: var(--krishi-green)"></i>
                  <span data-i18n="opt_vegetation_cover">Vegetation Cover Share</span>
                </h4>

                <!-- Time Scale Selector -->
                <div style="
                      margin-bottom: 12px;
                      display: flex;
                      gap: 10px;
                      align-items: center;
                    ">
                  <label style="font-size: 12px; font-weight: 500" data-i18n="opt_time_scale">Time Scale:</label>
                  <select id="timeScaleSelect" style="
                        padding: 4px 8px;
                        border: 1px solid #ddd;
                        border-radius: 4px;
                        font-size: 12px;
                      ">
                    <option value="monthly" data-i18n="opt_monthly">
                      Monthly
                    </option>
                    <option value="weekly" data-i18n="opt_weekly">
                      Weekly
                    </option>
                  </select>
                  <button onclick="runLandCoverAnalysis()" style="
                        padding: 4px 12px;
                        background: var(--krishi-green);
                        color: white;
                        border: none;
                        border-radius: 4px;
                        font-size: 12px;
                        cursor: pointer;
                      " data-i18n="opt_analyze">
                    Analyze
                  </button>
                </div>

                <!-- Period Selector (will be populated dynamically) -->
                <div id="periodSelector" style="margin-bottom: 12px; display: none">
                  <label style="font-size: 12px; font-weight: 500" data-i18n="opt_select_period">Select Period:</label>
                  <select id="periodSelect" onchange="updateLandCoverChart()" style="
                        padding: 4px 8px;
                        border: 1px solid #ddd;
                        border-radius: 4px;
                        font-size: 12px;
                        width: 100%;
                      ">
                    <!-- Options will be populated dynamically -->
                  </select>
                </div>

                <div style="height: 200px; position: relative">
                  <canvas id="landCoverChart"></canvas>
                </div>

                <!-- Legend with percentages -->
                <div style="
                      margin-top: 12px;
                      display: grid;
                      grid-template-columns: 1fr 1fr;
                      gap: 8px;
                      font-size: 12px;
                    ">
                  <div style="display: flex; align-items: center; gap: 6px">
                    <div style="
                          width: 12px;
                          height: 12px;
                          background: #1e88e5;
                          border-radius: 2px;
                        "></div>
                    <span><span data-i18n="opt_water">Water</span>:
                      <span id="water-percent">--%</span></span>
                  </div>
                  <div style="display: flex; align-items: center; gap: 6px">
                    <div style="
                          width: 12px;
                          height: 12px;
                          background: #8d6e63;
                          border-radius: 2px;
                        "></div>
                    <span><span data-i18n="opt_bare_land">Bare Land</span>:
                      <span id="bare-percent">--%</span></span>
                  </div>
                  <div style="display: flex; align-items: center; gap: 6px">
                    <div style="
                          width: 12px;
                          height: 12px;
                          background: #78909c;
                          border-radius: 2px;
                        "></div>
                    <span><span data-i18n="opt_builtup">Built-up</span>:
                      <span id="builtup-percent">--%</span></span>
                  </div>
                  <div style="display: flex; align-items: center; gap: 6px">
                    <div style="
                          width: 12px;
                          height: 12px;
                          background: #c0ca33;
                          border-radius: 2px;
                        "></div>
                    <span><span data-i18n="opt_sparse_veg">Sparse Veg</span>:
                      <span id="sparse-percent">--%</span></span>
                  </div>
                  <div style="display: flex; align-items: center; gap: 6px">
                    <div style="
                          width: 12px;
                          height: 12px;
                          background: #43a047;
                          border-radius: 2px;
                        "></div>
                    <span><span data-i18n="opt_full_veg">Full Veg</span>:
                      <span id="fullveg-percent">--%</span></span>
                  </div>
                </div>

                <!-- Summary Info -->
                <div id="landCoverSummary" style="
                      margin-top: 8px;
                      font-size: 11px;
                      color: #666;
                      display: none;
                    ">
                  <div>
                    <span data-i18n="opt_total_periods">Total Periods</span>:
                    <span id="totalPeriods">0</span>
                  </div>
                  <div>
                    <span data-i18n="opt_date_range">Date Range</span>:
                    <span id="dateRange">--</span>
                  </div>
                  <div>
                    <span data-i18n="opt_time_scale">Time Scale</span>:
                    <span id="timeScaleDisplay">--</span>
                  </div>
                </div>
              </div>

              <div class="percentiles-dist-section">
                <h4>Percentiles - Data Distribution</h4>
                <div class="percentile-dist-bar">
                  <span class="label">P10 (Bottom 10%)</span>
                  <div class="bar-track">
                    <div class="bar-fill orange" id="dist-p10-bar"></div>
                  </div>
                  <span class="value" id="dist-p10-value">--</span>
                </div>
                <div class="percentile-dist-bar">
                  <span class="label">P25 (Bottom 25%)</span>
                  <div class="bar-track">
                    <div class="bar-fill yellow" id="dist-p25-bar"></div>
                  </div>
                  <span class="value" id="dist-p25-value">--</span>
                </div>
                <div class="percentile-dist-bar">
                  <span class="label">P75 (Top 25%)</span>
                  <div class="bar-track">
                    <div class="bar-fill light-green" id="dist-p75-bar"></div>
                  </div>
                  <span class="value" id="dist-p75-value">--</span>
                </div>
                <div class="percentile-dist-bar">
                  <span class="label">P90 (Top 10%)</span>
                  <div class="bar-track">
                    <div class="bar-fill dark-green" id="dist-p90-bar"></div>
                  </div>
                  <span class="value" id="dist-p90-value">--</span>
                </div>
              </div>
            </div>
            <div id="visual-tab" class="ndvi-tab-content">
              <div class="visual-chart-container">
                <canvas id="ndviComparisonChart"></canvas>
              </div>
              <div class="info-box-container">
                <div class="info-box">
                  <h4>
                    <i class="fa-solid fa-circle-question"></i>
                    <span data-i18n="what_does_this_mean">What Does This Mean?</span>
                  </h4>
                  <ul>
                    <li>
                      <span class="color-swatch red"></span>
                      <span data-i18n="needs_attention">Needs attention (&lt; 0.3)</span>
                    </li>
                    <li>
                      <span class="color-swatch yellow"></span>
                      <span data-i18n="medium_health">Medium health (0.3 - 0.5)</span>
                    </li>
                    <li>
                      <span class="color-swatch light-green"></span>
                      <span data-i18n="good_health">Good health (0.5 - 0.7)</span>
                    </li>
                    <li>
                      <span class="color-swatch dark-green"></span>
                      <span data-i18n="excellent_health">Excellent health (&gt; 0.7)</span>
                    </li>
                  </ul>
                </div>

                <div class="tips-box">
                  <h4>
                    <i class="fa-solid fa-lightbulb"></i>
                    <span data-i18n="quick_tips">Quick Tips</span>
                  </h4>
                  <ul>
                    <li>
                      <b>Mean</b> 
                      <span data-i18n="tip_mean">shows overall crop health.</span>
                    </li>
                    <li>
                      <b>Range</b> 
                      <span data-i18n="tip_range">shows field uniformity.</span>
                    </li>
                    <li>
                      <b>Higher P90</b> 
                      <span data-i18n="tip_p90">means good potential.</span>
                    </li>
                    <li>
                      <b>Monitor low values</b> 
                      <span data-i18n="tip_monitor">for issues.</span>
                    </li>
                  </ul>
                </div>
              </div>
            </div>
          </div>
        </div>
        <div id="default-analytics-placeholder">
          <h3><span data-i18n="data_analytics">Data Analytics</span></h3>
          <div class="analytics-chart-wrap">
            <canvas id="gaugeChart"></canvas>
          </div>
          <div class="analytics-chart-wrap">
            <canvas id="barChart"></canvas>
          </div>
        </div>

        <!-- Irrigation Calendar Card -->
        <div id="irrigation-calendar-card" style="display: none;">
          <div style="text-align: center; padding: 6px 8px 10px 8px; border-bottom: 1px solid var(--border-color);">
            <h3 style="display: inline; margin: 0; font-size: 13px; font-weight: 600; color: var(--krishi-dark);">
              <i class="fa-solid fa-calendar-check" style="color: var(--krishi-green);"></i>
              <span data-i18n="irrigation_schedule">Irrigation Schedule</span>
            </h3>
          </div>

          <div id="irrigation-calendar-content-sidebar"
            style="padding: 10px; flex: 1; overflow-y: auto; min-height: 0; font-size: 10px;">
            <!-- Calendar content will be loaded here -->
          </div>
        </div>
      </aside>
    </section>
  </div>

  <script>



    let irrigationCalendarData = null;
    // Timer for debounce delay
    // Timer for debounce delay
    let searchTimeout;

    // let currentSearchMarker = null; // Assuming this is defined elsewhere, maybe globally
    // Index for keyboard navigation ( / )
    let selectedIndex = -1;

    //  Initialize the Search Functionality

    function initSearch() {
      const searchInput = document.getElementById("locationSearch");
      const searchButton = document.getElementById("searchButton");
      const searchResults = document.getElementById("searchResults");

      //  Button click triggers manual search
      searchButton.addEventListener("click", performSearch);

      //  Handle keyboard navigation ( / ) AND Enter key
      searchInput.addEventListener("keydown", (e) => {
        const items = searchResults.querySelectorAll(".search-result-item");

        if (e.key === "Enter") {
          // --- THIS IS FIX #2 ---
          // Prevent default form submission
          e.preventDefault();

          if (selectedIndex >= 0 && items.length > 0) {
            // If a suggestion is highlighted, select it
            const selectedItem = items[selectedIndex];
            if (selectedItem) selectSearchResult(selectedItem);
          } else {
            // Otherwise, perform a manual search for the text in the bar
            performSearch();
          }
        } else if (e.key === "ArrowDown") {
          if (!items.length) return;
          e.preventDefault();
          selectedIndex = (selectedIndex + 1) % items.length;
          highlightSuggestion(items);
        } else if (e.key === "ArrowUp") {
          if (!items.length) return;
          e.preventDefault();
          selectedIndex = (selectedIndex - 1 + items.length) % items.length;
          highlightSuggestion(items);
        }
      });

      //  Debounced auto-suggestions while typing
      searchInput.addEventListener("input", (e) => {
        clearTimeout(searchTimeout);
        const query = e.target.value.trim();

        // Hide suggestions if query too short
        if (query.length < 3) {
          searchResults.style.display = "none";
          searchResults.innerHTML = "";
          return;
        }

        // Wait 400ms after user stops typing before searching
        searchTimeout = setTimeout(() => {
          searchLocations(query, true); // true = auto-suggestion mode
        }, 400);
      });

      //  Hide suggestions when clicking outside the search area
      document.addEventListener("click", (e) => {
        if (!e.target.closest(".search-control")) {
          searchResults.style.display = "none";
          searchResults.innerHTML = "";
        }
      });
    }

    //  Perform Manual Search on Button / Enter

    async function performSearch() {
      const query = document.getElementById("locationSearch").value.trim();
      const searchResults = document.getElementById("searchResults");

      if (query.length < 2) {
        Swal.fire("Info", "Please enter a location to search.", "info");
        return;
      }

      // Hide suggestions dropdown when performing manual search
      searchResults.style.display = "none";
      searchResults.innerHTML = "";
      selectedIndex = -1; // Reset index

      await searchLocations(query, false);
    }

    // Fetch Locations from OpenStreetMap (Nominatim)

    async function searchLocations(query, isSuggestion = false) {
      const searchResults = document.getElementById("searchResults");
      selectedIndex = -1; // reset suggestion highlight

      try {
        // Show loading state for manual search (in suggestions box)
        if (isSuggestion) {
          searchResults.innerHTML =
            '<div class="search-result-item">Searching...</div>';
          searchResults.style.display = "block";
        }

        //  Fetch matching locations from Nominatim API
        const response = await fetch(
          `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(
            query
          )}&limit=8&addressdetails=1&countrycodes=in`
        );

        if (!response.ok) throw new Error("Search failed");
        const results = await response.json();

        // If no results found
        if (results.length === 0) {
          searchResults.innerHTML = `<div class="search-result-item">${t(
            "opt_no_results"
          )}</div>`;
          searchResults.style.display = "block"; // Show "no results"
          return;
        }

        // --- Special handling for non-suggestion (manual) search ---
        if (!isSuggestion && results.length > 0) {
          // If it's a manual search, just take the FIRST result and select it
          const firstResult = results[0];
          const itemData = {
            dataset: {
              lat: firstResult.lat,
              lon: firstResult.lon,
              name: firstResult.display_name,
            },
          };
          // We pass a mock 'item' object to selectSearchResult
          selectSearchResult(itemData);
          return; // Stop here, don't show suggestion list
        }

        // --- Display fetched results (for suggestions only) ---
        searchResults.style.display = "block";
        searchResults.innerHTML = results
          .map(
            (r) => `
    <div class="search-result-item" data-lat="${r.lat}" data-lon="${r.lon
              }" data-name="${r.display_name}">
      <div class="search-result-name">
        <i class="fa-regular fa-map-pin" style="color:#2f7a2f;margin-right:6px"></i> 
        ${r.display_name.split(",")[0]}
        </div>
      <div class="search-result-details">${r.display_name}</div>
    </div>
  `
          )
          .join("");

        //  Handle selection with mousedown (prevents blur issue)
        document.querySelectorAll(".search-result-item").forEach((item) => {
          item.addEventListener("mousedown", (e) => {
            e.preventDefault(); // stops input from losing focus
            selectSearchResult(item);
          });
        });
      } catch (error) {
        console.error("Search error:", error);
        searchResults.innerHTML = `<div class="search-result-item">${t(
          "opt_search_failed"
        )}</div>`;
      }
    }

    // Handle Selecting a Search Result

    function selectSearchResult(item) {
      const lat = parseFloat(item.dataset.lat);
      const lon = parseFloat(item.dataset.lon);
      const name = item.dataset.name;

      // --- THIS IS FIX #1 ---
      // Center map on selected location
      // Changed zoom from 14 (too close) to 11 (shows city/area)
      // You can change 11 to 10 (further out) or 12 (closer)
      map.setView([lat, lon], 11);

      //  Remove previous marker if any
      if (currentSearchMarker) map.removeLayer(currentSearchMarker);

      //  Add new marker
      currentSearchMarker = L.marker([lat, lon])
        .addTo(map)
        .bindPopup(
          `<div style="text-align:center;">
      <strong>${name.split(",")[0]}</strong><br>
                  <small>${name}</small>
    </div>`
        )
        .openPopup();

      // Update search box and close dropdown
      const searchInput = document.getElementById("locationSearch");
      const searchResults = document.getElementById("searchResults");

      searchInput.value = name.split(",")[0];
      searchResults.style.display = "none";
      searchResults.innerHTML = ""; // fully clear dropdown content

      // Show confirmation popup
      Swal.fire({
        icon: "success",
        title: t("opt_location_found"),
        text: `${t("opt_centered_map")} ${name.split(",")[0]}`,
        confirmButtonColor: "var(--krishi-green)",
        timer: 2000,
        showConfirmButton: false,
      });
    }

    // Highlight Active Suggestion (Keyboard Navigation)

    function highlightSuggestion(items) {
      items.forEach((el, i) => {
        if (i === selectedIndex) el.classList.add("active");
        else el.classList.remove("active");
      });
    }

    //  Optional Reverse Geocoding (Get Name by Lat/Lon)

    async function reverseGeocode(lat, lng) {
      try {
        const res = await fetch(
          `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&zoom=18&addressdetails=1`
        );
        if (!res.ok) throw new Error("Reverse geocoding failed");
        const data = await res.json();
        return data.display_name || "Unknown location";
      } catch {
        return "Unknown location";
      }
    }

    //  Initialize on Page Load

    document.addEventListener("DOMContentLoaded", initSearch);

    // Initialize map and base layers
    const baseMaps = {
      Satellite: L.tileLayer.provider("Esri.WorldImagery"),
      Street: L.tileLayer.provider("OpenStreetMap"),
      Topographic: L.tileLayer.provider("OpenTopoMap"),
      Grayscale: L.tileLayer.provider("CartoDB.Positron"),
      Dark: L.tileLayer.provider("CartoDB.DarkMatter"),

      //  New Hybrid Layer (Satellite + City/State Names)
      Hybrid: L.tileLayer(
        "https://{s}.google.com/vt/lyrs=y&x={x}&y={y}&z={z}",
        {
          maxZoom: 20,
          subdomains: ["mt0", "mt1", "mt2", "mt3"],
          attribution:
            '&copy; <a href="https://www.google.com/maps">Google Maps</a>',
        }
      ),
    };

    //  Default map: OpenStreetMap
    const map = L.map("map", {
      center: [26.51, 80.23],
      minZoom: 3,
      maxZoom: 20,
      zoom: 11,
      layers: [baseMaps.Satellite],
      attributionControl: false, // <-- 1. YEH ADD KAREIN
    });

    // Initialize drawn items and controls
    const drawnItems = new L.FeatureGroup().addTo(map);
    const overlays = {};
    const layerControl = L.control
      .layers(baseMaps, overlays, { position: "topright" })
      .addTo(map);
    L.control.scale().addTo(map);

    // Removed Leaflet toolbar and extra plugin UIs; using sidebar buttons instead
    // L.control.mousePosition() intentionally not added to remove plugin UI

    // Global variables
    let drawnAOI = null,
      chart,
      gaugeChart,
      barChart,

      fullChartData,
      isUploading = false,
      ndviComparisonChart,
      landCoverChart;
    let landCoverResults = null;
    let startDate = null,
      endDate = null; // Add global date variables

    // Handle drawing events
    map.on(L.Draw.Event.CREATED, function (e) {
      drawnItems.clearLayers();
      drawnAOI = e.layer;
      drawnItems.addLayer(drawnAOI);
      // --- ADD THIS LINE TO SAVE FOR DASHBOARD ---
      localStorage.setItem('recentAOI', JSON.stringify(drawnAOI.toGeoJSON()));
    });

    // ========== LOAD FIELD FROM URL PARAMETER ==========
    async function loadFieldFromURL() {
      const urlParams = new URLSearchParams(window.location.search);
      const fieldId = urlParams.get('field_id');

      if (!fieldId) return;

      try {
        const response = await fetch(`/api/get_field/${fieldId}`);
        if (!response.ok) {
          throw new Error('Field not found');
        }

        const field = await response.json();
        console.log('Loading field:', field);

        // Clear any existing drawings
        drawnItems.clearLayers();

        // Create layer based on field type
        let layer;
        if (field.type === 'circle') {
          layer = L.circle(field.geometry.center, {
            radius: field.geometry.radius,
            color: '#0ea84e',
            fillColor: '#0ea84e',
            fillOpacity: 0.2
          });
        } else {
          // For polygon/rectangle - create proper Leaflet layer
          const geoJsonLayer = L.geoJSON(field.geometry, {
            style: {
              color: '#0ea84e',
              fillColor: '#0ea84e',
              fillOpacity: 0.2
            }
          });

          // Extract the actual polygon layer from the GeoJSON LayerGroup
          const layers = [];
          geoJsonLayer.eachLayer(function (l) {
            layers.push(l);
          });

          // Use the first (and should be only) layer
          if (layers.length > 0) {
            layer = layers[0];
          } else {
            throw new Error('No valid layer found in GeoJSON');
          }
        }

        // Add to map
        drawnItems.addLayer(layer);
        drawnAOI = layer;

        // Fit map to field bounds
        map.fitBounds(layer.getBounds(), { padding: [50, 50] });

        // Show success message
        Swal.fire({
          icon: 'success',
          title: 'Field Loaded',
          text: `${field.name} has been loaded successfully`,
          timer: 2000,
          showConfirmButton: false
        });

      } catch (error) {
        console.error('Error loading field:', error);
        Swal.fire({
          icon: 'error',
          title: 'Error',
          text: 'Failed to load field. Please try again.'
        });
      }
    }

    // Load field on page load
    loadFieldFromURL();
    // ========== END FIELD LOADING ==========


    // Sidebar drawing controls
    const polygonDrawer = new L.Draw.Polygon(map, {
      shapeOptions: { color: "#0ea84e" },
    });
    const rectangleDrawer = new L.Draw.Rectangle(map, {
      shapeOptions: { color: "#0ea84e" },
    });
    const editor = new L.EditToolbar.Edit(map, {
      featureGroup: drawnItems,
      selectedPathOptions: { maintainColor: true },
    });

    const drawPolygonBtn = document.getElementById("drawPolygonBtn");
    const drawRectangleBtn = document.getElementById("drawRectangleBtn");
    const editShapesBtn = document.getElementById("editShapesBtn");
    const saveEditsBtn = document.getElementById("saveEditsBtn");
    const deleteShapesBtn = document.getElementById("deleteShapesBtn");

    // Add tile error handling
    map.on('tileerror', function (e) {
      console.warn('Tile loading error:', e);
    });

    map.on('tileload', function (e) {
      console.log('Tile loaded successfully:', e);
    });

    // Helper function to update active states
    function updateToolbarActiveState(activeBtn) {
      // Remove active class from all buttons
      document.querySelectorAll(".drawing-toolbar-btn").forEach((btn) => {
        btn.classList.remove("active");
      });
      // Add active class to the clicked button
      if (activeBtn) {
        activeBtn.classList.add("active");
      }
    }

    if (drawPolygonBtn) {
      drawPolygonBtn.addEventListener("click", function () {
        rectangleDrawer.disable();
        editor.disable();
        polygonDrawer.enable();
        updateToolbarActiveState(this);
      });
    }

    if (drawRectangleBtn) {
      drawRectangleBtn.addEventListener("click", function () {
        polygonDrawer.disable();
        editor.disable();
        rectangleDrawer.enable();
        updateToolbarActiveState(this);
      });
    }

    if (editShapesBtn) {
      editShapesBtn.addEventListener("click", function () {
        if (drawnItems.getLayers().length === 0) {
          alert(t("opt_draw_shape_first"));
          return;
        }
        polygonDrawer.disable();
        rectangleDrawer.disable();
        editor.enable();
        updateToolbarActiveState(this);
      });
    }

    if (saveEditsBtn) {
      saveEditsBtn.addEventListener("click", function () {
        // Finalize edits and store updated geometry
        editor.disable();
        updateToolbarActiveState(null); // No active state after saving
        const layers = drawnItems.getLayers();
        if (layers.length > 0) {
          drawnAOI = layers[0];
          try {
            const geojson = drawnAOI.toGeoJSON();
            console.log("Saved AOI:", geojson);
          } catch (e) {
            console.warn("Could not serialize AOI after save.");
          }
          alert(t("opt_changes_saved"));
        } else {
          alert(t("opt_no_shape_to_save"));
        }
      });
    }

    if (deleteShapesBtn) {
      deleteShapesBtn.addEventListener("click", function () {
        // Disable any active drawing/editing tools
        polygonDrawer.disable();
        rectangleDrawer.disable();
        editor.disable();
        updateToolbarActiveState(null); // Deactivate all buttons

        if (drawnItems.getLayers().length > 0) {
          // Clear the drawn shape from the map
          drawnItems.clearLayers();
          // Nullify the AOI variable
          drawnAOI = null;

          // Show a success message
          Swal.fire({
            icon: "success",
            // ---  FIX HERE  ---
            title: t("opt_shape_deleted"),
            text: t("opt_shape_removed_map"),
            // ---  FIX HERE  ---
            confirmButtonColor: "var(--krishi-green)",
            timer: 2000,
            showConfirmButton: false,
          });
        } else {
          // If there's nothing to delete
          Swal.fire({
            icon: "info",
            // ---  FIX HERE  ---
            title: t("opt_nothing_to_delete"),
            text: t("opt_draw_shape_to_delete"),
            // ---  FIX HERE  ---
            confirmButtonColor: "var(--krishi-green)",
            timer: 2000,
            showConfirmButton: false,
          });
        }
      });
    }

    map.on("draw:created", function () {
      editor.disable();
    });

    map.on("draw:editstop", function () {
      editor.disable();
    });

    // Map Layers remover
    let uploadedVectorLayers = [];
    function clearMap() {
      // Remove the main tile layer (NDVI, RGB, etc.)
      if (currentLayer) {
        map.removeLayer(currentLayer);
        // Remove from layer control overlays
        if (currentLayerName) {
          delete overlays[currentLayerName];
          layerControl.removeLayer(currentLayer);
        }
        currentLayer = null;
        currentLayerName = null;
      }

      // Remove the drawn polygon/rectangle
      drawnItems.clearLayers();
      drawnAOI = null;

      // Remove all uploaded vector files
      uploadedVectorLayers.forEach((layer) => {
        map.removeLayer(layer);
      });
      uploadedVectorLayers = [];

      // Reset the UI
      document.getElementById("uploaded-layers-list").innerHTML = "";
      document.getElementById("uploaded-layers-container").style.display =
        "none";

      // Reset charts
      if (chart) chart.destroy();
      if (landCoverChart) landCoverChart.destroy();
      document.getElementById("chart-placeholder").style.display = "flex";
      document.getElementById("chart-tabs").style.display = "none";
      document.getElementById("weather-parameter-dropdown").style.display =
        "none";

      // Reset weather data
      window.weatherData = null;

      // Reset layer controls
      document.getElementById("addLayerBtn").style.display = "none";
      document.getElementById("layer").value = "";
      document.getElementById("opacity-control").style.display = "none";

      // Reset analytics
      document.getElementById("ndvi-dashboard").style.display = "none";
      document.getElementById("default-analytics-placeholder").style.display =
        "flex";
      // Hide irrigation calendar card
      const irrigationCard = document.getElementById("irrigation-calendar-card");
      if (irrigationCard) irrigationCard.style.display = "none";
      if (gaugeChart) gaugeChart.destroy();
      if (barChart) barChart.destroy();
      if (ndviComparisonChart) ndviComparisonChart.destroy();

      // Reset data cache
      fullChartData = null;

      // Reset land cover analysis
      if (landCoverChart) {
        landCoverChart.destroy();
        landCoverChart = null;
      }
      landCoverResults = null;
      document.getElementById("periodSelector").style.display = "none";
      document.getElementById("landCoverSummary").style.display = "none";

      // Reset land cover percentages
      document.getElementById("water-percent").textContent = "--%";
      document.getElementById("bare-percent").textContent = "--%";
      document.getElementById("builtup-percent").textContent = "--%";
      document.getElementById("sparse-percent").textContent = "--%";
      document.getElementById("fullveg-percent").textContent = "--%";

      // Hide legend
      document.getElementById("map-legend").style.display = "none";

      Swal.fire({
        icon: "success",
        title: "Map Cleared",
        text: "All layers, drawings, and data have been removed.",
        confirmButtonColor: "var(--krishi-green)",
      });
    }

    // Left sidebar toggle functionality
    const hamburgerMenu = document.getElementById("hamburger-menu");
    const closeSidebarBtn = document.getElementById("closeSidebarBtn");
    const mainContainer = document.getElementById("main");

    function toggleSidebar() {
      mainContainer.classList.toggle("sidebar-collapsed");
      setTimeout(() => map.invalidateSize(), 410);
    }

    hamburgerMenu.addEventListener("click", toggleSidebar);
    closeSidebarBtn.addEventListener("click", toggleSidebar);
    mainContainer.addEventListener("click", (e) => {
      if (
        window.innerWidth <= 1000 &&
        e.target === mainContainer &&
        !mainContainer.classList.contains("sidebar-collapsed")
      ) {
        toggleSidebar();
      }
    });

    // Helper function to ensure right panel is open - FIXED VERSION
    function ensureRightPanelOpen() {
      const mainEl = document.getElementById("main");
      const sidebar = document.getElementById("analytics-sidebar");

      if (mainEl.classList.contains("right-collapsed")) {
        // Remove collapsed class and clear any inline styles
        mainEl.classList.remove("right-collapsed");

        if (sidebar) {
          sidebar.removeAttribute("style");
        }

        const icon = document.querySelector("#toggleRightBtn i");
        if (icon) {
          icon.classList.remove("fa-times");
          icon.classList.add("fa-bars");
        }

        setTimeout(() => {
          map.invalidateSize();
          try {
            if (chart) chart.resize();
          } catch (_) { }
        }, 350);
      }
    }
    const mainEl = document.getElementById("main");
    const sidebar = document.getElementById("analytics-sidebar");
    if (mainEl.classList.contains("right-collapsed")) {
      // Remove collapsed class
      mainEl.classList.remove("right-collapsed");

      // Force reset all properties to ensure full expansion
      if (sidebar) {
        sidebar.style.flex = "0 0 340px";
        sidebar.style.minWidth = "340px";
        sidebar.style.maxWidth = "340px";
        sidebar.style.width = "340px";
        sidebar.style.opacity = "1";
        sidebar.style.visibility = "visible";
        sidebar.style.transform = "translateX(0)";
        sidebar.style.padding = "";
        sidebar.style.borderLeft = "";
      }

      const icon = document.querySelector("#toggleRightBtn i");
      if (icon) {
        icon.classList.remove("fa-times");
        icon.classList.add("fa-bars");
      }

      setTimeout(() => {
        map.invalidateSize();
        try {
          if (chart) chart.resize();
        } catch (_) { }
        // Clear inline styles after transition to let CSS take over
        if (sidebar) {
          setTimeout(() => {
            sidebar.style.flex = "";
            sidebar.style.minWidth = "";
            sidebar.style.maxWidth = "";
            sidebar.style.width = "";
            sidebar.style.opacity = "";
            sidebar.style.visibility = "";
            sidebar.style.transform = "";
          }, 400);
        }
      }, 450);
    }

    // Right sidebar toggle functionality - FIXED VERSION
    function toggleRightPanel() {
      const mainEl = document.getElementById("main");
      const sidebar = document.getElementById("analytics-sidebar");
      const isCollapsed = mainEl.classList.contains("right-collapsed");

      if (isCollapsed) {
        // Opening the panel - remove collapsed class
        mainEl.classList.remove("right-collapsed");

        // Remove any inline styles that might interfere
        if (sidebar) {
          sidebar.removeAttribute("style");
        }
      } else {
        // Closing the panel - add collapsed class
        mainEl.classList.add("right-collapsed");
      }

      const icon = document.querySelector("#toggleRightBtn i");
      if (icon) {
        // Toggle between hamburger (bars) and X icon when collapsed
        const nowCollapsed = mainEl.classList.contains("right-collapsed");
        icon.classList.toggle("fa-bars", !nowCollapsed);
        icon.classList.toggle("fa-times", nowCollapsed);
      }

      // Use a timeout to ensure transition completes
      setTimeout(() => {
        map.invalidateSize();
        try {
          if (chart) chart.resize();
        } catch (_) { }
      }, 350);
    }
    // Horizontal resizer logic for chart/map
    (function initHorizontalResizer() {
      const resizer = document.getElementById("resizer-h");
      const chartArea = document.querySelector(".chart-area");
      const mainPanel = document.querySelector(".main-panel");
      if (!resizer || !chartArea || !mainPanel) return;

      let isDragging = false;
      let startY = 0;
      let startHeight = 0;

      const minHeight = 200; // px
      const maxHeight = Math.round(window.innerHeight * 0.8); // cap at 80vh

      const onMouseMove = (e) => {
        if (!isDragging) return;
        const dy = e.clientY - startY;
        let newHeight = startHeight - dy; // dragging up increases map, reduces chart
        newHeight = Math.max(minHeight, Math.min(maxHeight, newHeight));
        chartArea.style.height = newHeight + "px";
        map.invalidateSize();
        // Invalidate comparison maps if they exist
        if (
          typeof comparisonMaps !== "undefined" &&
          comparisonMaps.length > 0
        ) {
          comparisonMaps.forEach((compMap) => {
            if (compMap && typeof compMap.invalidateSize === "function") {
              compMap.invalidateSize();
            }
          });
        }
        try {
          if (chart) chart.resize();
        } catch (_) { }
      };

      const stopDrag = () => {
        if (!isDragging) return;
        isDragging = false;
        document.removeEventListener("mousemove", onMouseMove);
        document.removeEventListener("mouseup", stopDrag);
      };

      resizer.addEventListener("mousedown", (e) => {
        isDragging = true;
        startY = e.clientY;
        startHeight = chartArea.getBoundingClientRect().height;
        document.addEventListener("mousemove", onMouseMove);
        document.addEventListener("mouseup", stopDrag);
      });
    })();

    // File upload functionality
    const uploadArea = document.getElementById("upload-area");
    const fileInput = document.getElementById("vectorFile");

    function processVectorFile(file) {
      if (!file) return;
      if (isUploading) {
        Swal.fire(
          "Busy",
          "Please wait for the current upload to finish.",
          "warning"
        );
        return;
      }
      if (
        !(
          file.name.endsWith(".geojson") ||
          file.name.endsWith(".json") ||
          file.name.endsWith(".kml")
        )
      ) {
        Swal.fire(
          "Invalid File",
          "Please select a valid .geojson, .json, or .kml file.",
          "error"
        );
        return;
      }
      isUploading = true;
      document.getElementById("spinner").style.display = "block";

      const reader = new FileReader();
      reader.onload = function (e) {
        try {
          let geojsonData;
          const fileName = file.name;
          if (fileName.endsWith(".kml")) {
            const kml = new DOMParser().parseFromString(
              e.target.result,
              "text/xml"
            );
            geojsonData = toGeoJSON.kml(kml);
          } else {
            geojsonData = JSON.parse(e.target.result);
          }

          // Clear existing drawn items
          drawnItems.clearLayers();

          const vectorLayer = L.geoJSON(geojsonData, {
            onEachFeature: function (feature, layer) {
              if (feature.properties) {
                let popupContent =
                  '<div style="max-height: 200px; overflow-y: auto;">';
                for (let key in feature.properties) {
                  popupContent += `<strong>${key}:</strong> ${feature.properties[key]}<br>`;
                }
                popupContent += "</div>";
                layer.bindPopup(popupContent);
              }
            },
          }).addTo(map);

          // Set the uploaded vector as the drawn AOI
          const layers = vectorLayer.getLayers();
          if (layers.length > 0) {
            drawnAOI = layers[0];
            drawnItems.addLayer(vectorLayer);
            map.fitBounds(vectorLayer.getBounds());

            Swal.fire({
              icon: "success",
              title: "Vector File Uploaded",
              text: `File "${fileName}" was added to the map and set as the Area of Interest. You can now fetch data for this area.`,
              confirmButtonColor: "var(--krishi-green)",
            });
          } else {
            Swal.fire(
              "Error",
              "The uploaded file contains no valid features.",
              "error"
            );
          }

          addLayerToList(fileName, vectorLayer);
        } catch (error) {
          console.error("File parsing error:", error);
          Swal.fire(
            "Error",
            "Could not read or parse the file. Please ensure it is a valid GeoJSON or KML.",
            "error"
          );
        } finally {
          isUploading = false;
          document.getElementById("spinner").style.display = "none";
          fileInput.value = "";
        }
      };
      reader.onerror = () => {
        isUploading = false;
        document.getElementById("spinner").style.display = "none";
        Swal.fire("Error", "Could not read the file.", "error");
      };
      reader.readAsText(file);
    }

    fileInput.addEventListener("change", () => {
      if (fileInput.files.length > 0) processVectorFile(fileInput.files[0]);
    });

    ["dragenter", "dragover", "dragleave", "drop"].forEach((eventName) => {
      uploadArea.addEventListener(
        eventName,
        (e) => {
          e.preventDefault();
          e.stopPropagation();
        },
        false
      );
    });

    uploadArea.addEventListener("dragenter", () =>
      uploadArea.classList.add("drag-over")
    );
    uploadArea.addEventListener("dragover", () =>
      uploadArea.classList.add("drag-over")
    );
    uploadArea.addEventListener("dragleave", () =>
      uploadArea.classList.remove("drag-over")
    );
    uploadArea.addEventListener("drop", (e) => {
      uploadArea.classList.remove("drag-over");
      if (e.dataTransfer.files.length > 0)
        processVectorFile(e.dataTransfer.files[0]);
    });

    function addLayerToList(fileName, layer) {
      const list = document.getElementById("uploaded-layers-list");
      const container = document.getElementById("uploaded-layers-container");
      const li = document.createElement("li");
      li.textContent =
        fileName.length > 25 ? `${fileName.substring(0, 22)}...` : fileName;
      const removeBtn = document.createElement("button");
      removeBtn.className = "remove-layer-btn";
      removeBtn.innerHTML = "&times;";
      removeBtn.title = "Remove layer";
      removeBtn.onclick = () => {
        map.removeLayer(layer);
        li.remove();
        if (list.children.length === 0) {
          container.style.display = "none";
        }
      };
      li.appendChild(removeBtn);
      list.appendChild(li);
      container.style.display = "block";
    }

    const layerOptions = `
    <option value="" disabled selected data-i18n="select_layer_placeholder">Select a layer...</option>
    <option value="rgb" data-i18n="opt_rgb">FCC</option>
    <option value="ndvi" data-i18n="opt_ndvi">Crop Health</option>
    <option value="savi" data-i18n="opt_savi">Soil Adjusted Vegetation</option>
    <option value="cwsi" data-i18n="opt_cwsi">Crop Water Stress</option>
    <option value="lst" data-i18n="opt_lst">Temperature</option>
    <option value="lai" data-i18n="opt_lai">Leaf Area Index</option>
    <option value="kc" data-i18n="opt_kc">Water Evapotranspiration</option>
    <option value="etc" data-i18n="opt_etc">Total Water Loss</option>
    // <option value="cwr" data-i18n="opt_cwr">Crop Water Requirement</option>
    <option value="irrigation_need" data-i18n="opt_irrigation_need">Irrigation Need</option>
    <option value="soilmoisture" data-i18n="opt_soilmoisture">Soil Moisture</option>
    
`;

    const chartTabsHTML = `
    <button class="chart-tab-btn active" data-param="ndvi"><span data-i18n="opt_ndvi">Crop Health</span></button>
    <button class="chart-tab-btn" data-param="savi"><span data-i18n="opt_savi">Soil Adjusted Index</span></button>
    <button class="chart-tab-btn" data-param="cwsi"><span data-i18n="opt_cwsi">Water Stress</span></button>
    <button class="chart-tab-btn" data-param="kc"><span data-i18n="opt_kc">Water Evapotranspiration</span></button>
    <button class="chart-tab-btn" data-param="etc"><span data-i18n="opt_etc">Total Water Loss</span></button>
    // <button class="chart-tab-btn" data-param="cwr"><span data-i18n="opt_cwr">Crop Water Requirement</span></button>
    <button class="chart-tab-btn" data-param="irrigation_need"><span data-i18n="opt_irrigation_need">Irrigation Need</span></button>
    
    <button class="chart-tab-btn" data-param="soilmoisture_mm"><span data-i18n="opt_soilmoisture">Soil Moisture</span></button>
    <button class="chart-tab-btn" data-param="lst"><span data-i18n="opt_lst">Temperature</span></button>
    <button class="chart-tab-btn" data-param="lai"><span data-i18n="opt_lai">Leaf Area Index</span></button>
    <button class="chart-tab-btn" data-param="weather"><span data-i18n="opt_w">Weather</span></button>
`;

    // Layer selection functionality
    const layerSelect = document.getElementById("layer");
    const addLayerButton = document.getElementById("addLayerBtn");
    const opacityControl = document.getElementById("opacity-control");
    const opacitySlider = document.getElementById("opacity-slider");
    const opacityValue = document.getElementById("opacity-value");

    // Store added layers
    let addedLayers = [];

    let comparisonMaps = []; // Store comparison maps globally
    layerSelect.addEventListener('change', async () => {
      const selectedValue = layerSelect.value;
      addLayerButton.style.display = selectedValue ? "inline-flex" : "none";
      opacityControl.style.display = selectedValue && selectedValue !== "rgb" ? "flex" : "none";

      // Auto-load layer when selected from dropdown (if AOI is drawn)
      if (selectedValue && drawnAOI) {
        await switchLayer();

        // Force stats panel update based on layer type
        if (currentLayerData && currentLayerData.stats) {
          updateStatsPanel(selectedValue, currentLayerData.stats);
        }

        // Always open right panel to show statistics
        ensureRightPanelOpen();
      }
    });

    addLayerButton.addEventListener("click", async () => {
      const selectedValue = layerSelect.value;
      if (!selectedValue) return;

      // First ensure layer is loaded (switchLayer sets currentLayerData)
      await switchLayer();

      // Add layer to management list if data is available
      // Create a copy of the layer so it persists when switching
      if (currentLayer && currentLayerData && currentLayerData.urlFormat) {
        // Create a new layer instance from the URL format
        const layerCopy = L.tileLayer(currentLayerData.urlFormat, {
          minZoom: 3,
          maxZoom: 23,
          opacity: currentLayer.options.opacity || 1.0,
        });
        layerCopy.addTo(map);

        addLayerToManagement(
          selectedValue,
          layerCopy,
          currentLayerData.stats
        );
      }

      // Open right panel
      ensureRightPanelOpen();
    });

    // Opacity control functionality
    // Replace your current opacity slider event listener with this:
    opacitySlider.addEventListener("input", function () {
      const opacity = this.value / 100;
      opacityValue.textContent = `${this.value}%`;

      if (currentLayer) {
        currentLayer.setOpacity(opacity);
      }
    });

    // Land cover classification function
    function calculateLandCover(ndviValues) {
      if (!ndviValues || ndviValues.length === 0) return null;

      let water = 0,
        bareLand = 0,
        builtup = 0,
        sparseVeg = 0,
        fullVeg = 0;

      ndviValues.forEach((ndvi) => {
        if (ndvi < -0.1) water++;
        else if (ndvi >= -0.1 && ndvi < 0.1) bareLand++;
        else if (ndvi >= 0.1 && ndvi < 0.2) builtup++;
        else if (ndvi >= 0.2 && ndvi < 0.5) sparseVeg++;
        else if (ndvi >= 0.5) fullVeg++;
      });

      const total = ndviValues.length;

      return {
        water: ((water / total) * 100).toFixed(1),
        bareLand: ((bareLand / total) * 100).toFixed(1),
        builtup: ((builtup / total) * 100).toFixed(1),
        sparseVeg: ((sparseVeg / total) * 100).toFixed(1),
        fullVeg: ((fullVeg / total) * 100).toFixed(1),
      };
    }

    // Render land cover pie chart
    function renderLandCoverChart(landCoverData) {
      if (landCoverChart) landCoverChart.destroy();

      const ctx = document.getElementById("landCoverChart").getContext("2d");

      const data = [
        parseFloat(landCoverData.water),
        parseFloat(landCoverData.bareLand),
        parseFloat(landCoverData.builtup),
        parseFloat(landCoverData.sparseVeg),
        parseFloat(landCoverData.fullVeg),
      ];

      const colors = ["#1e88e5", "#8d6e63", "#78909c", "#c0ca33", "#43a047"];

      landCoverChart = new Chart(ctx, {
        type: "pie",
        data: {
          labels: [
            "Water",
            "Bare Land",
            "Built-up",
            "Sparse Vegetation",
            "Full Vegetation",
          ],
          datasets: [
            {
              data: data,
              backgroundColor: colors,
              borderWidth: 1,
              borderColor: "#fff",
            },
          ],
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: false,
            },
            tooltip: {
              callbacks: {
                label: function (context) {
                  return `${context.label}: ${context.parsed}%`;
                },
              },
            },
          },
        },
      });

      // Update percentage labels
      document.getElementById(
        "water-percent"
      ).textContent = `${landCoverData.water}%`;
      document.getElementById(
        "bare-percent"
      ).textContent = `${landCoverData.bareLand}%`;
      document.getElementById(
        "builtup-percent"
      ).textContent = `${landCoverData.builtup}%`;
      document.getElementById(
        "sparse-percent"
      ).textContent = `${landCoverData.sparseVeg}%`;
      document.getElementById(
        "fullveg-percent"
      ).textContent = `${landCoverData.fullVeg}%`;

      updateChartTheme();
    }

    // Function to update NDVI statistics panel
    function updateNDVIStatsPanel(stats, ndviValues = null) {
      console.log("updateNDVIStatsPanel called with stats:", stats);

      // Reset the title back to "NDVI Statistics" every time.
      document.querySelector("#ndvi-dashboard h3").innerHTML = `
            <i class="fa-solid fa-leaf" style="color: var(--krishi-green);"></i>
            <span data-i18n="opt_nst">Crop Health Statistics</span>
        `;

      // Make sure the percentile sections are visible again (the LST function hides them).
      document.querySelectorAll(".percentiles-dist-section").forEach((el) => {
        el.style.display = "block";
      });

      const dashboard = document.getElementById("ndvi-dashboard");
      const placeholder = document.getElementById(
        "default-analytics-placeholder"
      );
      const irrigationCard = document.getElementById("irrigation-calendar-card");

      console.log("Dashboard element:", dashboard);
      console.log("Placeholder element:", placeholder);

      if (!stats || stats.error) {
        console.log("No stats or error, hiding dashboard");
        dashboard.style.display = "none";
        placeholder.style.display = "flex";
        if (irrigationCard) irrigationCard.style.display = "none";
        renderAnalyticsCharts();
        return;
      }

      console.log("Showing dashboard, hiding placeholder");
      dashboard.style.display = "flex";
      placeholder.style.display = "none";
      if (irrigationCard) irrigationCard.style.display = "none";

      // Ensure right panel is open when showing stats
      ensureRightPanelOpen();

      // Helper Functions
      const toNum = (v) => (v === null || v === undefined ? null : Number(v));
      const format = (v) => (v !== null ? v.toFixed(3) : "--");
      const getHealthColor = (value) => {
        if (value === null) return "#bdc3c7";
        if (value >= 0.7) return "#22c55e";
        if (value >= 0.5) return "#4ade80";
        if (value >= 0.3) return "#facc15";
        return "#ef4444";
      };

      // Data Extraction & Calculation
      const min = toNum(stats.min);
      const max = toNum(stats.max);
      const mean = toNum(stats.mean);
      const median = toNum(stats.median);
      const stdDev = toNum(stats.stdDev);
      const p10 = toNum(stats.p10);
      const p25 = toNum(stats.p25);
      const p75 = toNum(stats.p75);
      const p90 = toNum(stats.p90);
      const range = min !== null && max !== null ? max - min : null;
      const dataRange =
        max !== null && min !== null && max > min ? max - min : 1;

      const getWidthPercent = (val) => {
        if (val === null || min === null || dataRange <= 0) return "0%";
        return `${Math.max(
          0,
          Math.min(100, ((val - min) / dataRange) * 100)
        )}%`;
      };

      // Populate Overview Tab
      document.getElementById("overview-mean-value").textContent =
        format(mean);
      document.getElementById("overview-median-value").textContent =
        format(median);
      document.getElementById("overview-p25-value").textContent = format(p25);
      document.getElementById("overview-p75-value").textContent = format(p75);

      document.getElementById("overview-mean-bar").style.width =
        getWidthPercent(mean);
      document.getElementById("overview-mean-bar").style.backgroundColor =
        getHealthColor(mean);
      document.getElementById("overview-median-bar").style.width =
        getWidthPercent(median);
      document.getElementById("overview-median-bar").style.backgroundColor =
        getHealthColor(median);
      document.getElementById("overview-p25-bar").style.width =
        getWidthPercent(p25);
      document.getElementById("overview-p25-bar").style.backgroundColor =
        getHealthColor(p25);
      document.getElementById("overview-p75-bar").style.width =
        getWidthPercent(p75);
      document.getElementById("overview-p75-bar").style.backgroundColor =
        getHealthColor(p75);

      const minMaxLabel = `Min: ${format(min)}`;
      const maxMaxLabel = `Max: ${format(max)}`;
      ["1", "2", "3", "4"].forEach((i) => {
        document.getElementById(`overview-min${i}`).textContent = minMaxLabel;
        document.getElementById(`overview-max${i}`).textContent = maxMaxLabel;
      });

      let healthStatus, healthEmoji, healthBgColor;
      if (mean !== null) {
        if (mean >= 0.7) {
          healthStatus = `<span data-i18n="excellent_condition">Excellent Condition (Healthy sprout/plant)</span>`;
          healthEmoji = "";
          healthBgColor = "#22c55e";
        } else if (mean >= 0.5) {
          healthStatus = `<span data-i18n="good_condition">Good Condition</span>`;
          healthEmoji = "";
          healthBgColor = "#4ade80";
        } else if (mean >= 0.3) {
          healthStatus = `<span data-i18n="fair_condition">Fair Condition (Wilted leaf/Average)</span>`;
          healthEmoji = "";
          healthBgColor = "#facc15";
        } else {
          healthStatus = `<span data-i18n="poor_condition">Poor Condition</span>`;
          healthEmoji = "";
          healthBgColor = "#ef4444";
        }
      } else {
        healthStatus = `<span data-i18n="no_data">--</span>`;
        healthEmoji = "";
        healthBgColor = "#95a5a6";
      }

      document.getElementById("health-emoji").textContent = healthEmoji;
      document.getElementById("health-status-text").innerHTML = healthStatus;
      document.getElementById("overall-health-card").style.backgroundColor =
        healthBgColor;
      document.getElementById(
        "health-summary"
      ).textContent = `Average: ${format(mean)} | Range: ${format(range)}`;

      // Populate Detailed Tab
      document.getElementById("detailed-mean").textContent = format(mean);
      document.getElementById("detailed-median").textContent = format(median);
      document.getElementById("detailed-stddev").textContent = format(stdDev);
      document.getElementById("detailed-min").textContent = format(min);
      document.getElementById("detailed-max").textContent = format(max);
      document.getElementById("detailed-range").textContent = format(range);

      document.getElementById("dist-p10-value").textContent = format(p10);
      document.getElementById("dist-p25-value").textContent = format(p25);
      document.getElementById("dist-p75-value").textContent = format(p75);
      document.getElementById("dist-p90-value").textContent = format(p90);

      document.getElementById("dist-p10-bar").style.width =
        getWidthPercent(p10);
      document.getElementById("dist-p25-bar").style.width =
        getWidthPercent(p25);
      document.getElementById("dist-p75-bar").style.width =
        getWidthPercent(p75);
      document.getElementById("dist-p90-bar").style.width =
        getWidthPercent(p90);

      // Create/Update Visual Tab Chart
      if (ndviComparisonChart) ndviComparisonChart.destroy();
      const visualCtx = document
        .getElementById("ndviComparisonChart")
        .getContext("2d");
      const chartData = [min, p25, median, mean, p75, max];
      ndviComparisonChart = new Chart(visualCtx, {
        type: "bar",
        data: {
          labels: ["Min", "P25", "Median", "Mean", "P75", "Max"],
          datasets: [
            {
              data: chartData,
              backgroundColor: chartData.map((v) => getHealthColor(v)),
              borderRadius: 4,
            },
          ],
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { display: false },
            title: {
              display: true,
              text: "Data Comparison Chart",
              font: { size: 14 },
            },
          },
          scales: { y: { beginAtZero: true, suggestedMax: 1 } },
        },
      });

      // Add land cover calculation and chart rendering
      if (ndviValues && ndviValues.length > 0) {
        const landCoverData = calculateLandCover(ndviValues);
        if (landCoverData) {
          renderLandCoverChart(landCoverData);
        }
      }

      updateChartTheme();
    }

    function updateDataAvailabilityIndicators(data) {
      if (!data || !Array.isArray(data)) return;

      // Add indicators to chart tooltips or create a status panel
      data.forEach((item, index) => {
        const hasLandsat = item.has_landsat || item.landsat_count > 0;
        const hasSMAP = item.has_smap || item.smap_count > 0;
        const hasCHIRPS = item.has_chirps || item.chirps_count > 0;
        const hasETo = item.has_eto || item.eto_count > 0;

        // You can add visual indicators here
        console.log(
          `Date: ${item.date}, Landsat: ${hasLandsat}, SMAP: ${hasSMAP}, CHIRPS: ${hasCHIRPS}, ETo: ${hasETo}`
        );
      });
    }

    // Call this after fetching data in fetchData()
    updateDataAvailabilityIndicators(fullChartData);

    // Function to update SAVI statistics panel
    function updateSAVIStatsPanel(stats) {
      const dashboard = document.getElementById("ndvi-dashboard");
      const placeholder = document.getElementById(
        "default-analytics-placeholder"
      );
      const irrigationCard = document.getElementById("irrigation-calendar-card");

      if (!stats || stats.error) {
        dashboard.style.display = "none";
        placeholder.style.display = "flex";
        if (irrigationCard) irrigationCard.style.display = "none";
        renderAnalyticsCharts();
        return;
      }

      dashboard.style.display = "flex";
      placeholder.style.display = "none";
      if (irrigationCard) irrigationCard.style.display = "none";
      ensureRightPanelOpen();

      // Update title for SAVI
      document.querySelector("#ndvi-dashboard h3").innerHTML = `
    <i class="fa-solid fa-mountain" style="color: #27ae60;"></i>
    SAVI Statistics
  `;

      // Rest of SAVI stats implementation similar to NDVI
      // ... (copy the structure from updateNDVIStatsPanel and adapt for SAVI)
    }

    // Function to update CWSI statistics panel
    function updateCWSIStatsPanel(stats) {
      const dashboard = document.getElementById("ndvi-dashboard");
      const placeholder = document.getElementById(
        "default-analytics-placeholder"
      );

      if (!stats || stats.error) {
        dashboard.style.display = "none";
        placeholder.style.display = "flex";
        renderAnalyticsCharts();
        return;
      }

      dashboard.style.display = "flex";
      placeholder.style.display = "none";
      ensureRightPanelOpen();

      // Update title for CWSI
      document.querySelector("#ndvi-dashboard h3").innerHTML = `
    <i class="fa-solid fa-droplet-slash" style="color: #e74c3c;"></i>
    Crop Water Stress Statistics
  `;

      // CWSI-specific implementation
      // ... (copy the structure from updateNDVIStatsPanel and adapt for CWSI)
    }

    // Function to update LAI statistics panel
    function updateLAIStatsPanel(stats) {
      const dashboard = document.getElementById("ndvi-dashboard");
      const placeholder = document.getElementById(
        "default-analytics-placeholder"
      );

      if (!stats || stats.error) {
        dashboard.style.display = "none";
        placeholder.style.display = "flex";
        renderAnalyticsCharts();
        return;
      }

      dashboard.style.display = "flex";
      placeholder.style.display = "none";
      ensureRightPanelOpen();

      // Update title for LAI
      document.querySelector("#ndvi-dashboard h3").innerHTML = `
    <i class="fa-solid fa-leaf" style="color: #8e44ad;"></i>
    Leaf Area Index Statistics
  `;

      // LAI-specific implementation
      // ... (copy the structure from updateNDVIStatsPanel and adapt for LAI)
    }

    // Function to update map legend

    // Add this at the top of your script
    let useHighContrast = false;
    let showBuffer = false;

    // REPLACE your existing updateMapLegend function with this one:
    function updateMapLegend(layerName, stats) {
      const legend = document.getElementById("map-legend");

      if (!layerName || layerName === "rgb") {
        legend.style.display = "none";
        return;
      }

      // --- 1. Define High Contrast Colors (Orange/Blue) vs Normal Colors (Green/Red) ---
      const normalColors = {
        poor: "#d73027", fair: "#fc8d59", mod: "#fee08b", good: "#d9ef8b", exc: "#1a9850",
        low: "#e0f3f8", high: "#4575b4",
        hot: "#CA3519", cool: "#FFD6A7"
      };

      const highContrastColors = {
        poor: "#ff5722", fair: "#ff9800", mod: "#ffc107", good: "#8bc34a", exc: "#4caf50",
        low: "#b3e5fc", high: "#0288d1",
        hot: "#d32f2f", cool: "#0288d1"
      };

      const colors = useHighContrast ? highContrastColors : normalColors;

      // --- 2. Define Legend Configs using selected color palette ---
      const legendConfigs = {
        ndvi: {
          title: "Crop Health (NDVI)",
          items: [
            { color: colors.poor, label: "Poor (< 0.2)" },
            { color: colors.fair, label: "Fair (0.2-0.4)" },
            { color: colors.mod, label: "Moderate (0.4-0.6)" },
            { color: colors.good, label: "Good (0.6-0.8)" },
            { color: colors.exc, label: "Excellent (> 0.8)" },
          ],
        },
        savi: {
          title: "Soil Adjusted Index (SAVI)",
          items: [
            { color: "red", label: "Low (< 0.2)" },
            { color: "orange", label: "Fair (0.2-0.4)" },
            { color: "yellow", label: "Moderate (0.4-0.6)" },
            { color: "green", label: "High (> 0.6)" }
          ],
        },
        cwsi: {
          title: "Water Stress (CWSI)",
          items: [
            { color: "blue", label: "No Stress (< 0.2)" },
            { color: "cyan", label: "Low Stress (0.2-0.4)" },
            { color: "white", label: "Moderate (0.4-0.6)" },
            { color: "yellow", label: "High Stress (0.6-0.8)" },
            { color: "red", label: "Severe (> 0.8)" },
          ],
        },
        lst: {
          title: "Temperature (LST)",
          items: [
            { color: "PeachPuff", label: "Cool (< 20 C)" },
            { color: "SandyBrown", label: "Moderate (20-30 C)" },
            { color: "OrangeRed", label: "Warm (30-40 C)" },
            { color: "FireBrick", label: "Hot (> 40 C)" }
          ],
        },
        lai: {
          title: "Leaf Area Index (LAI)",
          items: [
            { color: "white", label: "Low (< 1)" },
            { color: "lightgreen", label: "Moderate (1-3)" },
            { color: "darkgreen", label: "High (> 3)" }
          ]
        },
        kc: {
          title: "Crop Coefficient (Kc)",
          items: [
            { color: "blue", label: "Low (< 0.4)" },
            { color: "cyan", label: "Moderate (0.4-0.8)" },
            { color: "red", label: "High (> 0.8)" }
          ]
        },
        etc: {
          title: "Evapotranspiration (ETc)",
          items: [
            { color: "#ffffcc", label: "Very Low" },
            { color: "#a1dab4", label: "Low" },
            { color: "#41b6c4", label: "Moderate" },
            { color: "#2c7fb8", label: "High" },
            { color: "#253494", label: "Very High" }
          ]
        },
        irrigation_need: {
          title: "Irrigation Need",
          items: [
            { color: "#ffffcc", label: "None" },
            { color: "#41b6c4", label: "Low" },
            { color: "#253494", label: "High" }
          ]
        },
        soilmoisture: {
          title: "Soil Moisture",
          items: [
            { color: "brown", label: "Very Dry (< 20%)" },
            { color: "yellow", label: "Dry (20-40%)" },
            { color: "lightgreen", label: "Moist (40-60%)" },
            { color: "darkgreen", label: "Wet (60-80%)" },
            { color: "blue", label: "Very Wet (> 80%)" }
          ]
        }
      };

      // Fallback if config doesn't exist for a specific layer
      const config = legendConfigs[layerName] || legendConfigs['ndvi'];

      // --- 3. Build the HTML ---
      let legendHTML = `<h4>${config.title}</h4><div class="legend-scale">`;

      config.items.forEach((item) => {
        legendHTML += `
          <div class="legend-item">
            <div class="legend-color" style="background: ${item.color};"></div>
            <div class="legend-label">${item.label}</div>
          </div>
        `;
      });

      legendHTML += "</div>"; // Close scale

      // --- 5. ADD THE TOGGLES HERE ---
      // We inject the checked attribute based on global variables


      legend.innerHTML = legendHTML;
      legend.style.display = "block";
    }

    // Improved error handling for layer switching
    async function switchLayer() {
      const selected = document.getElementById("layer").value;
      if (!drawnAOI) {
        Swal.fire(
          "Missing Information",
          "Please draw an Area of Interest (AOI) on the map first.",
          "warning"
        );
        return;
      }
      if (!selected) {
        Swal.fire(
          "Missing Information",
          "Please select a layer from the dropdown menu.",
          "warning"
        );
        return;
      }

      document.getElementById("spinner").style.display = "block";

      try {
        let result;
        const requestBody = {
          aoi: drawnAOI.toGeoJSON(),
          layer: selected,
        };

        // Add date parameters for layers that need them
        const startDate = document.getElementById("start").value;
        const endDate = document.getElementById("end").value;

        if (startDate && endDate) {
          requestBody.start_date = startDate;
          requestBody.end_date = endDate;
        }

        console.log("Sending request for layer:", selected, requestBody);

        result = await fetch("/get_gee_tile", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(requestBody),
        });

        console.log("Layer request response status:", result.status);

        if (!result.ok) {
          const errorText = await result.text();
          let errorMessage = `Server responded with status: ${result.status}`;
          try {
            const errorData = JSON.parse(errorText);
            errorMessage = errorData.error || errorMessage;
          } catch (e) {
            errorMessage = errorText || errorMessage;
          }
          throw new Error(errorMessage);
        }

        const data = await result.json();

        if (data.error || !data.urlFormat) {
          throw new Error(data.error || "Map layer generation failed.");
        }

        console.log("Received data:", data);
        console.log("Statistics data:", data.stats);

        // Store current layer data for later use
        currentLayerData = data;

        if (currentLayer) {
          map.removeLayer(currentLayer);
          // Remove from layer control overlays
          delete overlays[currentLayerName];
          layerControl.removeLayer(currentLayer);
        }

        currentLayer = L.tileLayer(data.urlFormat, {
          minZoom: 3,
          maxZoom: 23,
          opacity: 1.0, // Default opacity
        });
        currentLayer.addTo(map);

        // Add to layer control overlays with a descriptive name
        currentLayerName = selected.toUpperCase() + " Layer";
        overlays[currentLayerName] = currentLayer;
        layerControl.addOverlay(currentLayer, currentLayerName);

        // Reset opacity slider to 100% when switching layers
        if (opacitySlider && opacityValue) {
          opacitySlider.value = 100;
          opacityValue.textContent = "100%";
        }

        // Update map legend
        updateMapLegend(selected, data.stats);

        // --- START: Replacement Code ---

        // 1. First, hide all possible analytics panels to reset the view.
        //    Your LST panel re-uses the 'ndvi-dashboard', so this handles both cases.
        document.getElementById("ndvi-dashboard").style.display = "none";
        document.getElementById(
          "default-analytics-placeholder"
        ).style.display = "none";

        // 2. Now, show the correct panel based on the selected layer.
        console.log("Selected layer:", selected, "Has stats:", !!data.stats);
        if (selected === "ndvi" && data.stats) {
          console.log("Updating NDVI stats panel");
          const ndviValues = fullChartData
            ? fullChartData.map((d) => d.ndvi).filter((v) => v !== null)
            : null;
          updateNDVIStatsPanel(data.stats, ndviValues);
        } else if (selected === "lst" && data.stats) {
          updateLSTStatsPanel(data.stats);
        } else if (selected === "kc" && data.stats) {
          updateKcStatsPanel(data.stats);
        } else if (selected === "etc" && data.stats) {
          updateETcStatsPanel(data.stats);
        } else if (selected === "cwr" && data.stats) {
          updateCWRStatsPanel(data.stats);
        } else if (selected === "deltas" && data.stats) {
          updateDeltaSStatsPanel(data.stats);
        } else if (selected === "soilmoisture" && data.stats) {
          updateSoilMoistureStatsPanel(data.stats);
        } else {
          // For all other layers (like RGB), show the default placeholder.
          console.log(
            "No stats available for layer:",
            selected,
            "Showing default placeholder"
          );
          document.getElementById(
            "default-analytics-placeholder"
          ).style.display = "flex";
          if (selected !== "rgb") {
            renderAnalyticsCharts();
          }
        }
        // --- END: Replacement Code ---

        console.log("Layer loaded successfully:", selected);
      } catch (error) {
        console.error("Layer switch error:", error);
        Swal.fire(
          "Layer Loading Failed",
          `Could not load the ${selected.toUpperCase()} layer: ${error.message
          }`,
          "error"
        );
      } finally {
        document.getElementById("spinner").style.display = "none";
      }
    }

    let dateChangeTimeout;
    function setupDateDebounce() {
      const startInput = document.getElementById("start");
      const endInput = document.getElementById("end");

      const handleDateChange = () => {
        clearTimeout(dateChangeTimeout);
        dateChangeTimeout = setTimeout(() => {
          // Auto-refresh data when dates change (optional)
          // if (drawnAOI) fetchData();
        }, 800); // 800ms debounce
      };

      startInput.addEventListener("change", handleDateChange);
      endInput.addEventListener("change", handleDateChange);
    }

    // Call this on DOMContentLoaded
    setupDateDebounce();

    // Function to add layer to management list
    function addLayerToManagement(layerType, layerInstance, stats) {
      // Check if layer already exists
      const existingIndex = addedLayers.findIndex(
        (l) => l.type === layerType
      );
      if (existingIndex !== -1) {
        Swal.fire(
          "Info",
          "This layer is already added to the management list.",
          "info"
        );
        return;
      }

      // Get layer display name
      const layerNames = {
        rgb: "FCC",
        ndvi: "Crop Health",
        savi: "Soil Adjusted Index",
        cwsi: "Water Stress",
        lst: "Temperature",
        lai: "Leaf Area Index",
        soilmoisture: "Soil Moisture",
        cwr: "Crop Water Requirement",
        kc: "Water Evapotranspiration",
        etc: "Total Water Loss",
        deltas: "Soil Moisture Change",
      };

      const layerInfo = {
        id: Date.now(),
        type: layerType,
        name: layerNames[layerType] || layerType.toUpperCase(),
        layer: layerInstance,
        stats: stats,
        selected: false,
        urlFormat: currentLayerData ? currentLayerData.urlFormat : null,
      };

      addedLayers.push(layerInfo);
      renderLayerManagementList();
    }

    // Function to render layer management list
    function renderLayerManagementList() {
      const listContainer = document.getElementById("added-layers-list");
      const managementPanel = document.getElementById(
        "layer-management-panel"
      );
      const compareSection = document.getElementById(
        "compare-layers-section"
      );

      if (!listContainer || !managementPanel) return;

      if (addedLayers.length === 0) {
        managementPanel.style.display = "none";
        return;
      }

      managementPanel.style.display = "flex";
      listContainer.innerHTML = "";

      addedLayers.forEach((layerInfo) => {
        const layerItem = document.createElement("div");
        layerItem.style.cssText =
          "display: flex; align-items: center; gap: 8px; padding: 8px; background: var(--card-bg); border: 1px solid var(--border-color); border-radius: 8px;";

        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.checked = layerInfo.selected;
        checkbox.style.cssText =
          "width: 18px; height: 18px; cursor: pointer;";
        checkbox.addEventListener("change", () => {
          layerInfo.selected = checkbox.checked;
          updateCompareSection();
        });

        const label = document.createElement("label");
        label.style.cssText =
          "flex: 1; cursor: pointer; font-size: 13px; font-weight: 500; color: var(--krishi-dark);";
        label.textContent = layerInfo.name;
        label.appendChild(checkbox);

        const removeBtn = document.createElement("button");
        removeBtn.innerHTML = "&times;";
        removeBtn.style.cssText =
          "background: transparent; border: none; font-size: 20px; color: #ef4444; cursor: pointer; padding: 0 8px;";
        removeBtn.title = "Remove layer";
        removeBtn.addEventListener("click", () => {
          // Remove layer from map
          if (layerInfo.layer) {
            map.removeLayer(layerInfo.layer);
          }
          // Remove from array
          addedLayers = addedLayers.filter((l) => l.id !== layerInfo.id);
          renderLayerManagementList();
          updateCompareSection();
        });

        layerItem.appendChild(checkbox);
        layerItem.appendChild(label);
        layerItem.appendChild(removeBtn);
        listContainer.appendChild(layerItem);
      });

      updateCompareSection();
    }

    // Function to update compare section visibility
    function updateCompareSection() {
      const compareSection = document.getElementById(
        "compare-layers-section"
      );
      const selectedLayers = addedLayers.filter((l) => l.selected);

      if (selectedLayers.length >= 2 && compareSection) {
        compareSection.style.display = "block";
      } else if (compareSection) {
        compareSection.style.display = "none";
        // Hide comparison view if less than 2 layers selected
        const comparisonView = document.getElementById(
          "layer-comparison-view"
        );
        if (comparisonView) {
          comparisonView.style.display = "none";
        }
      }
    }

    // Function to compare selected layers - Side by side in main map using Leaflet
    function compareLayers() {
      const selectedLayers = addedLayers.filter((l) => l.selected);
      if (selectedLayers.length < 2) {
        Swal.fire(
          "Info",
          "Please select at least 2 layers to compare.",
          "info"
        );
        return;
      }

      const comparisonWrapper = document.getElementById(
        "comparison-maps-wrapper"
      );
      if (!comparisonWrapper) return;

      // Hide main map and show comparison wrapper
      const mainMapContainer = document
        .getElementById("map")
        .querySelector("div.leaflet-container");
      if (mainMapContainer) {
        mainMapContainer.style.display = "none";
      }

      comparisonWrapper.style.display = "block";
      comparisonWrapper.innerHTML = "";

      // Clear previous comparison maps
      comparisonMaps.forEach((compMap) => {
        if (compMap && compMap.remove) {
          try {
            compMap.remove();
          } catch (e) {
            console.log("Error removing map:", e);
          }
        }
      });
      comparisonMaps = [];

      // Create comparison control header
      const comparisonHeader = document.createElement("div");
      comparisonHeader.style.cssText =
        "position: absolute; top: 10px; left: 50%; transform: translateX(-50%); z-index: 2000; background: rgba(255, 255, 255, 0.95); padding: 8px 16px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.2); display: flex; align-items: center; gap: 12px;";

      const headerTitle = document.createElement("span");
      headerTitle.style.cssText =
        "font-weight: 600; color: var(--krishi-dark); font-size: 14px;";
      headerTitle.textContent = "Layer Comparison Mode";
      comparisonHeader.appendChild(headerTitle);

      const closeBtn = document.createElement("button");
      closeBtn.innerHTML = '<i class="fa-solid fa-times"></i>';
      closeBtn.style.cssText =
        "background: #ef4444; color: white; border: none; width: 28px; height: 28px; border-radius: 6px; cursor: pointer; display: flex; align-items: center; justify-content: center;";
      closeBtn.title = "Close Comparison";
      closeBtn.addEventListener("click", () => {
        closeComparison();
      });
      comparisonHeader.appendChild(closeBtn);
      comparisonWrapper.appendChild(comparisonHeader);

      // Create maps container - side by side
      const mapsContainer = document.createElement("div");
      mapsContainer.id = "comparison-maps-container";
      mapsContainer.style.cssText =
        "width: 100%; height: 100%; display: grid; grid-template-columns: repeat(" +
        Math.min(selectedLayers.length, 3) +
        ", 1fr); gap: 8px; padding: 50px 8px 8px 8px; box-sizing: border-box;";

      // If more than 3 layers, allow horizontal scrolling
      if (selectedLayers.length > 3) {
        mapsContainer.style.gridTemplateColumns = `repeat(${selectedLayers.length}, minmax(300px, 1fr))`;
        mapsContainer.style.overflowX = "auto";
      }
      comparisonWrapper.appendChild(mapsContainer);

      // Show close button in panel
      const closeComparisonBtnPanel =
        document.getElementById("closeComparisonBtn");
      if (closeComparisonBtnPanel) {
        closeComparisonBtnPanel.style.display = "block";
      }

      // Create all map containers first and add to DOM
      const mapIds = [];
      selectedLayers.forEach((layerInfo, index) => {
        const mapContainer = document.createElement("div");
        const mapId = `comparison-map-${Date.now()}-${index}`;
        mapIds.push(mapId);
        mapContainer.id = mapId;
        mapContainer.style.cssText =
          "width: 100%; height: 100%; border: 2px solid var(--krishi-green); border-radius: 8px; overflow: hidden; position: relative; background: #e9f7ea; min-height: 400px;";

        const layerLabel = document.createElement("div");
        layerLabel.style.cssText =
          "position: absolute; top: 8px; left: 8px; background: rgba(255, 255, 255, 0.95); padding: 6px 12px; border-radius: 6px; font-size: 13px; font-weight: 600; z-index: 1000; color: var(--krishi-dark); box-shadow: 0 2px 6px rgba(0,0,0,0.2); pointer-events: none;";
        layerLabel.textContent = layerInfo.name;
        mapContainer.appendChild(layerLabel);

        mapsContainer.appendChild(mapContainer);
      });

      // Wait for DOM to be ready, then initialize maps one by one
      requestAnimationFrame(() => {
        setTimeout(() => {
          selectedLayers.forEach((layerInfo, index) => {
            const mapId = mapIds[index];
            setTimeout(() => {
              initializeComparisonMap(
                mapId,
                layerInfo,
                index,
                selectedLayers
              );
            }, 300 * index);
          });
        }, 300);
      });
    }

    // Helper function to initialize a comparison map
    function initializeComparisonMap(
      mapId,
      layerInfo,
      index,
      allSelectedLayers
    ) {
      try {
        const container = document.getElementById(mapId);
        if (!container) {
          console.error("Container not found:", mapId);
          return;
        }

        // Check if container already has a map
        if (container._leaflet || container._leaflet_id) {
          console.log("Map already exists for:", mapId);
          return;
        }

        // Check if container has dimensions
        const rect = container.getBoundingClientRect();
        if (rect.width === 0 || rect.height === 0) {
          console.warn("Container has no dimensions, retrying...", mapId);
          setTimeout(
            () =>
              initializeComparisonMap(
                mapId,
                layerInfo,
                index,
                allSelectedLayers
              ),
            300
          );
          return;
        }

        // Initialize Leaflet map
        const comparisonMap = L.map(mapId, {
          center: map.getCenter(),
          zoom: map.getZoom(),
          zoomControl: false,
          attributionControl: false,
        });

        // Add base layer
        L.tileLayer("https://{s}.google.com/vt/lyrs=y&x={x}&y={y}&z={z}", {
          maxZoom: 20,
          subdomains: ["mt0", "mt1", "mt2", "mt3"],
          attribution:
            '&copy; <a href="https://www.google.com/maps">Google Maps</a>',
        }).addTo(comparisonMap);

        // Add the layer using stored urlFormat
        if (layerInfo.urlFormat) {
          const layer = L.tileLayer(layerInfo.urlFormat, {
            minZoom: 3,
            maxZoom: 23,
            opacity: 1.0,
          });
          layer.addTo(comparisonMap);
        } else if (layerInfo.layer && layerInfo.layer._url) {
          // Fallback to layer instance URL
          const layer = L.tileLayer(layerInfo.layer._url, {
            minZoom: 3,
            maxZoom: 23,
            opacity: 1.0,
          });
          layer.addTo(comparisonMap);
        }

        comparisonMaps.push(comparisonMap);

        // Invalidate size to ensure proper rendering
        setTimeout(() => {
          comparisonMap.invalidateSize();
        }, 200);

        // Setup synchronization with other maps
        if (comparisonMaps.length >= 2) {
          setupMapSync(comparisonMaps[0], comparisonMap);
        }
      } catch (error) {
        console.error("Error creating comparison map:", error, mapId);
      }
    }

    // Helper function to setup map synchronization
    function setupMapSync(map1, map2) {
      let syncing = false;

      const syncMap = (source, target) => {
        if (!syncing) {
          syncing = true;
          target.setView(source.getCenter(), source.getZoom(), {
            animate: false,
          });
          setTimeout(() => {
            syncing = false;
          }, 50);
        }
      };

      map1.on("move zoom", () => syncMap(map1, map2));
      map2.on("move zoom", () => syncMap(map2, map1));
    }

    // Function to close comparison and restore main map
    function closeComparison() {
      const comparisonWrapper = document.getElementById(
        "comparison-maps-wrapper"
      );
      const mainMapContainer = document
        .getElementById("map")
        .querySelector("div.leaflet-container");
      const closeComparisonBtn =
        document.getElementById("closeComparisonBtn");

      // Remove all comparison maps
      comparisonMaps.forEach((compMap) => {
        if (compMap && typeof compMap.remove === "function") {
          try {
            compMap.remove();
          } catch (e) {
            console.log("Error removing map:", e);
          }
        }
      });
      comparisonMaps = [];

      // Hide comparison wrapper and show main map
      if (comparisonWrapper) {
        comparisonWrapper.style.display = "none";
        comparisonWrapper.innerHTML = "";
      }

      if (mainMapContainer) {
        mainMapContainer.style.display = "block";
      }

      // Hide close button
      if (closeComparisonBtn) {
        closeComparisonBtn.style.display = "none";
      }

      // Restore main map
      setTimeout(() => {
        map.invalidateSize();
        try {
          if (chart) chart.resize();
        } catch (_) { }
      }, 100);
    }

    // Add event listener for close comparison button in panel
    const closeComparisonBtn = document.getElementById("closeComparisonBtn");
    if (closeComparisonBtn) {
      closeComparisonBtn.addEventListener("click", closeComparison);
    }

    // Add event listener for compare button
    const compareBtn = document.getElementById("compareLayersBtn");
    if (compareBtn) {
      compareBtn.addEventListener("click", compareLayers);
    }

    // Layer Management Panel minimize/maximize functionality with dragging
    const minimizeBtn = document.getElementById("minimizeLayerPanelBtn");
    const maximizeBtn = document.getElementById("maximizeLayerPanelBtn");
    const layerManagementPanel = document.getElementById(
      "layer-management-panel"
    );
    const layerManagementHeader = layerManagementPanel
      ? layerManagementPanel.querySelector(".layer-management-header")
      : null;

    let isDraggingPanel = false;
    let panelDragStartX = 0;
    let panelDragStartY = 0;
    let panelStartLeft = 0;
    let panelStartBottom = 0;

    if (minimizeBtn && maximizeBtn && layerManagementPanel) {
      minimizeBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        layerManagementPanel.classList.add("minimized");
        minimizeBtn.style.display = "none";
        maximizeBtn.style.display = "flex";
        // Reset position to top left
        layerManagementPanel.style.left = "20px";
        layerManagementPanel.style.top = "20px";
        layerManagementPanel.style.bottom = "auto";
        layerManagementPanel.style.transform = "";

        // Position at bottom center
        setTimeout(() => {
          map.invalidateSize();
          // Invalidate comparison maps if they exist
          if (
            typeof comparisonMaps !== "undefined" &&
            comparisonMaps.length > 0
          ) {
            comparisonMaps.forEach((compMap) => {
              if (compMap && typeof compMap.invalidateSize === "function") {
                compMap.invalidateSize();
              }
            });
          }
          try {
            if (chart) chart.resize();
          } catch (_) { }
        }, 300);
      });

      maximizeBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        layerManagementPanel.classList.remove("minimized");
        minimizeBtn.style.display = "flex";
        maximizeBtn.style.display = "none";

        // Reset position to top left
        layerManagementPanel.style.left = "20px";
        layerManagementPanel.style.top = "20px";
        layerManagementPanel.style.bottom = "auto";
        layerManagementPanel.style.transform = "";

        setTimeout(() => {
          map.invalidateSize();
          // Invalidate comparison maps if they exist
          if (
            typeof comparisonMaps !== "undefined" &&
            comparisonMaps.length > 0
          ) {
            comparisonMaps.forEach((compMap) => {
              if (compMap && typeof compMap.invalidateSize === "function") {
                compMap.invalidateSize();
              }
            });
          }
          try {
            if (chart) chart.resize();
          } catch (_) { }
        }, 300);
      });

      // Irrigation Calendar Panel minimize/maximize functionality
      const minimizeIrrigationBtn = document.getElementById("minimizeIrrigationPanelBtn");
      const maximizeIrrigationBtn = document.getElementById("maximizeIrrigationPanelBtn");
      const minimizeIrrigationFullBtn = document.getElementById("minimizeIrrigationPanelFullBtn");
      const maximizeIrrigationFullBtn = document.getElementById("maximizeIrrigationPanelFullBtn");
      const irrigationCalendarPanel = document.getElementById("irrigation-calendar-panel");
      const irrigationCalendarHeader = irrigationCalendarPanel
        ? irrigationCalendarPanel.querySelector(".irrigation-calendar-header")
        : null;

      let isDraggingIrrigationPanel = false;
      let irrigationPanelDragStartX = 0;
      let irrigationPanelDragStartY = 0;
      let irrigationPanelStartLeft = 0;
      let irrigationPanelStartBottom = 0;

      // Function to expand irrigation calendar panel
      function expandIrrigationCalendarPanel() {
        if (irrigationCalendarPanel) {
          irrigationCalendarPanel.style.display = "flex";
          irrigationCalendarPanel.classList.add("expanded");
          irrigationCalendarPanel.classList.remove("minimized");

          // Update sidebar buttons
          if (minimizeIrrigationBtn) minimizeIrrigationBtn.style.display = "none";
          if (maximizeIrrigationBtn) maximizeIrrigationBtn.style.display = "flex";

          // Update full panel buttons
          if (minimizeIrrigationFullBtn) minimizeIrrigationFullBtn.style.display = "flex";
          if (maximizeIrrigationFullBtn) maximizeIrrigationFullBtn.style.display = "none";

          setTimeout(() => {
            map.invalidateSize();
            try {
              if (chart) chart.resize();
            } catch (_) { }
          }, 300);
        }
      }

      // Function to minimize irrigation calendar panel
      function minimizeIrrigationCalendarPanel() {
        if (irrigationCalendarPanel) {
          irrigationCalendarPanel.classList.add("minimized");
          irrigationCalendarPanel.classList.remove("expanded");

          // Update sidebar buttons
          if (minimizeIrrigationBtn) minimizeIrrigationBtn.style.display = "flex";
          if (maximizeIrrigationBtn) maximizeIrrigationBtn.style.display = "none";

          // Update full panel buttons
          if (minimizeIrrigationFullBtn) minimizeIrrigationFullBtn.style.display = "none";
          if (maximizeIrrigationFullBtn) maximizeIrrigationFullBtn.style.display = "flex";

          setTimeout(() => {
            map.invalidateSize();
            try {
              if (chart) chart.resize();
            } catch (_) { }
          }, 300);
        }
      }

      // Sidebar minimize button (expands to full panel)
      if (minimizeIrrigationBtn) {
        minimizeIrrigationBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          expandIrrigationCalendarPanel();
        });
      }

      // Sidebar maximize button (expands to full panel)
      if (maximizeIrrigationBtn) {
        maximizeIrrigationBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          expandIrrigationCalendarPanel();
        });
      }

      // Full panel minimize button
      if (minimizeIrrigationFullBtn && irrigationCalendarPanel) {
        minimizeIrrigationFullBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          minimizeIrrigationCalendarPanel();
        });
      }

      // Full panel maximize button
      if (maximizeIrrigationFullBtn && irrigationCalendarPanel) {
        maximizeIrrigationFullBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          expandIrrigationCalendarPanel();
        });
      }

      // Make minimized panel draggable
      if (irrigationCalendarHeader) {
        const startIrrigationDrag = (e) => {
          if (!irrigationCalendarPanel.classList.contains("minimized")) return;
          isDraggingIrrigationPanel = true;
          const rect = irrigationCalendarPanel.getBoundingClientRect();
          const mapRect = document.getElementById("map").getBoundingClientRect();
          irrigationPanelDragStartX = e.clientX;
          irrigationPanelDragStartY = e.clientY;
          irrigationPanelStartLeft = rect.right - mapRect.right;
          irrigationPanelStartBottom = window.innerHeight - rect.bottom;

          document.addEventListener("mousemove", onIrrigationPanelDrag);
          document.addEventListener("mouseup", stopIrrigationPanelDrag);
          e.preventDefault();
        };

        const onIrrigationPanelDrag = (e) => {
          if (!isDraggingIrrigationPanel) return;
          const mapRect = document.getElementById("map").getBoundingClientRect();
          const newRight = window.innerWidth - e.clientX - irrigationPanelStartLeft + (irrigationPanelDragStartX - e.clientX);
          const newBottom = window.innerHeight - e.clientY - irrigationPanelStartBottom + (irrigationPanelDragStartY - e.clientY);

          irrigationCalendarPanel.style.right = `${Math.max(0, Math.min(window.innerWidth - mapRect.left - 100, newRight))}px`;
          irrigationCalendarPanel.style.bottom = `${Math.max(0, Math.min(window.innerHeight - mapRect.top - 50, newBottom))}px`;
        };

        const stopIrrigationPanelDrag = () => {
          isDraggingIrrigationPanel = false;
          document.removeEventListener("mousemove", onIrrigationPanelDrag);
          document.removeEventListener("mouseup", stopIrrigationPanelDrag);
        };

        irrigationCalendarHeader.addEventListener("mousedown", startIrrigationDrag);
      }

      // Map Legend - NOT draggable (removed dragging functionality)
      const mapLegend = document.getElementById("map-legend");
      if (mapLegend) {
        // Just prevent map interaction when clicking on legend
        mapLegend.addEventListener("mousedown", (e) => {
          e.stopPropagation(); // Prevent map interaction
        });
      }

      // Add event listener for full panel button
      const irrigationCalendarBtnFull = document.getElementById("irrigationCalendarBtnFull");
      if (irrigationCalendarBtnFull) {
        irrigationCalendarBtnFull.addEventListener("click", () => {
          // generateIrrigationCalendar already expands the panel
          generateIrrigationCalendar();
        });
      }

      // Make minimized panel draggable
      if (layerManagementHeader) {
        const startDrag = (e) => {
          if (!layerManagementPanel.classList.contains("minimized")) return;
          isDraggingPanel = true;
          const rect = layerManagementPanel.getBoundingClientRect();
          const mapRect = document
            .getElementById("map")
            .getBoundingClientRect();
          panelDragStartX = e.clientX;
          panelDragStartY = e.clientY;
          panelStartLeft = rect.left - mapRect.left;
          panelStartBottom = window.innerHeight - rect.bottom;

          document.addEventListener("mousemove", onPanelDrag);
          document.addEventListener("mouseup", stopPanelDrag);
          e.preventDefault();
        };

        const onPanelDrag = (e) => {
          if (!isDraggingPanel) return;
          const mapElement = document.getElementById("map");
          const mapRect = mapElement.getBoundingClientRect();
          const deltaX = e.clientX - panelDragStartX;
          const deltaY = panelDragStartY - e.clientY; // Y is inverted for bottom positioning

          let newLeft = panelStartLeft + deltaX;
          let newBottom = panelStartBottom + deltaY;

          // Constrain to map boundaries
          const panelRect = layerManagementPanel.getBoundingClientRect();
          const maxLeft = mapRect.width - panelRect.width;
          const maxBottom = mapRect.height - 20; // Keep 20px margin from bottom

          newLeft = Math.max(0, Math.min(maxLeft, newLeft));
          newBottom = Math.max(20, Math.min(maxBottom, newBottom));

          layerManagementPanel.style.left = newLeft + "px";
          layerManagementPanel.style.bottom = newBottom + "px";
          layerManagementPanel.style.transform = ""; // Remove center transform when dragging
        };

        const stopPanelDrag = () => {
          if (!isDraggingPanel) return;
          isDraggingPanel = false;
          document.removeEventListener("mousemove", onPanelDrag);
          document.removeEventListener("mouseup", stopPanelDrag);
        };

        layerManagementHeader.addEventListener("mousedown", startDrag);
      }
    }

    // Function to update LST statistics panel
    function updateLSTStatsPanel(stats) {
      const dashboard = document.getElementById("ndvi-dashboard");
      const placeholder = document.getElementById(
        "default-analytics-placeholder"
      );

      if (!stats || stats.error) {
        dashboard.style.display = "none";
        placeholder.style.display = "flex";
        renderAnalyticsCharts();
        return;
      }

      dashboard.style.display = "flex";
      placeholder.style.display = "none";

      // Ensure right panel is open when showing stats
      ensureRightPanelOpen();

      // Update the dashboard title for LST
      document.querySelector("#ndvi-dashboard h3").innerHTML = `
        <i class="fa-solid fa-temperature-high" style="color: #ff6b6b;"></i>
        LST Statistics
    `;

      // Update tabs content for temperature data
      const mean = stats.mean !== undefined ? Number(stats.mean) : null;
      const min = stats.min !== undefined ? Number(stats.min) : null;
      const max = stats.max !== undefined ? Number(stats.max) : null;
      const stdDev = stats.stdDev !== undefined ? Number(stats.stdDev) : null;

      // Update overview tab
      document.getElementById("overview-mean-value").textContent =
        mean !== null ? mean.toFixed(1) + "K" : "--";
      document.getElementById("overview-median-value").textContent = "--";
      document.getElementById("overview-p25-value").textContent = "--";
      document.getElementById("overview-p75-value").textContent = "--";

      // Update progress bars for temperature
      const tempRange = min !== null && max !== null ? max - min : 20; // Default range
      const getTempWidthPercent = (val) => {
        if (val === null || min === null || tempRange <= 0) return "0%";
        return `${Math.max(
          0,
          Math.min(100, ((val - min) / tempRange) * 100)
        )}%`;
      };

      document.getElementById("overview-mean-bar").style.width =
        getTempWidthPercent(mean);
      document.getElementById("overview-mean-bar").style.backgroundColor =
        "#ff6b6b";

      ["1", "2", "3", "4"].forEach((i) => {
        document.getElementById(`overview-min${i}`).textContent =
          min !== null ? `Min: ${min.toFixed(1)}K` : "Min: --";
        document.getElementById(`overview-max${i}`).textContent =
          max !== null ? `Max: ${max.toFixed(1)}K` : "Max: --";
      });

      // Update health card for temperature
      let tempStatus, tempEmoji, tempBgColor;
      if (mean !== null) {
        if (mean < 15) {
          tempStatus = "Very Cool";
          tempEmoji = "";
          tempBgColor = "#4dabf7";
        } else if (mean < 25) {
          tempStatus = "Comfortable";
          tempEmoji = "";
          tempBgColor = "#51cf66";
        } else if (mean < 35) {
          tempStatus = "Warm";
          tempEmoji = "";
          tempBgColor = "#ffd43b";
        } else {
          tempStatus = "Hot";
          tempEmoji = "";
          tempBgColor = "#ff6b6b";
        }
      } else {
        tempStatus = "--";
        tempEmoji = "";
        tempBgColor = "#95a5a6";
      }

      document.getElementById("health-emoji").textContent = tempEmoji;
      document.getElementById("health-status-text").innerHTML = tempStatus;
      document.getElementById("overall-health-card").style.backgroundColor =
        tempBgColor;
      document.getElementById("health-summary").textContent = `Average: ${mean !== null ? mean.toFixed(1) + "K" : "--"
        } | Range: ${min !== null && max !== null ? (max - min).toFixed(1) + "K" : "--"
        }`;

      // Update detailed tab
      document.getElementById("detailed-mean").textContent =
        mean !== null ? mean.toFixed(1) + "K" : "--";
      document.getElementById("detailed-median").textContent = "--";
      document.getElementById("detailed-stddev").textContent =
        stdDev !== null ? stdDev.toFixed(1) + "K" : "--";
      document.getElementById("detailed-min").textContent =
        min !== null ? min.toFixed(1) + "K" : "--";
      document.getElementById("detailed-max").textContent =
        max !== null ? max.toFixed(1) + "K" : "--";
      document.getElementById("detailed-range").textContent =
        min !== null && max !== null ? (max - min).toFixed(1) + "K" : "--";

      // Hide percentile sections for LST as they may not be available
      document.querySelector(".percentiles-dist-section").style.display =
        "none";

      // Update visual tab
      if (ndviComparisonChart) ndviComparisonChart.destroy();
      const visualCtx = document
        .getElementById("ndviComparisonChart")
        .getContext("2d");
      const chartData = [min, mean, max].filter((v) => v !== null);
      const labels = ["Min", "Mean", "Max"].filter(
        (_, i) => [min, mean, max][i] !== null
      );

      ndviComparisonChart = new Chart(visualCtx, {
        type: "bar",
        data: {
          labels: labels,
          datasets: [
            {
              data: chartData,
              backgroundColor: ["#4dabf7", "#ff6b6b", "#ff8787"],
              borderRadius: 4,
            },
          ],
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { display: false },
            title: {
              display: true,
              text: "Temperature Comparison",
              font: { size: 14 },
            },
          },
          scales: {
            y: {
              beginAtZero: false,
              title: {
                display: true,
                text: "Temperature (K)",
              },
            },
          },
        },
      });

      // Hide land cover section for LST
      document.querySelector(".percentiles-dist-section").style.display =
        "none";

      updateChartTheme();
    }

    // Generic stats panel updater
    function updateStatsPanel(layerType, stats) {
      switch (layerType) {
        case 'ndvi':
          const ndviValues = fullChartData ?
            fullChartData.map(d => d.ndvi).filter(v => v !== null) : null;
          updateNDVIStatsPanel(stats, ndviValues);
          break;
        case 'savi':
          updateSAVIStatsPanel(stats);
          break;
        case 'cwsi':
          updateCWSIStatsPanel(stats);
          break;
        case 'lst':
          updateLSTStatsPanel(stats);
          break;
        case 'kc':
          updateKcStatsPanel(stats);
          break;
        case 'etc':
          updateETcStatsPanel(stats);
          break;
        case 'cwr':
          updateCWRStatsPanel(stats);
          break;
        case 'soilmoisture':
          updateSoilMoistureStatsPanel(stats);
          break;
        case 'deltas':
          updateDeltaSStatsPanel(stats);
          break;
        case 'lai':
          updateLAIStatsPanel(stats);
          break;
        // ADD THIS CASE
        case 'irrigation_need':
          updateIrrigationNeedStatsPanel(stats);
          break;
        case 'rgb':
          document.getElementById('ndvi-dashboard').style.display = 'none';
          document.getElementById('default-analytics-placeholder').style.display = 'flex';
          const irrigationCard1 = document.getElementById('irrigation-calendar-card');
          if (irrigationCard1) irrigationCard1.style.display = 'none';
          break;
        default:
          document.getElementById('ndvi-dashboard').style.display = 'none';
          document.getElementById('default-analytics-placeholder').style.display = 'flex';
          const irrigationCard2 = document.getElementById('irrigation-calendar-card');
          if (irrigationCard2) irrigationCard2.style.display = 'none';
          renderAnalyticsCharts();
      }
    }
    // Function to update Kc (Crop coefficient) statistics panel
    function updateKcStatsPanel(stats) {
      const dashboard = document.getElementById("ndvi-dashboard");
      const placeholder = document.getElementById(
        "default-analytics-placeholder"
      );

      if (!stats || stats.error) {
        dashboard.style.display = "none";
        placeholder.style.display = "flex";
        renderAnalyticsCharts();
        return;
      }

      dashboard.style.display = "flex";
      placeholder.style.display = "none";

      // Ensure right panel is open when showing stats
      ensureRightPanelOpen();

      // Update the dashboard title for Kc
      document.querySelector("#ndvi-dashboard h3").innerHTML = `
            <i class="fa-solid fa-seedling" style="color: #51cf66;"></i>
            Kc Statistics
        `;

      // Update tabs content for Kc data
      const mean = stats.mean !== undefined ? Number(stats.mean) : null;
      const min = stats.min !== undefined ? Number(stats.min) : null;
      const max = stats.max !== undefined ? Number(stats.max) : null;
      const stdDev = stats.stdDev !== undefined ? Number(stats.stdDev) : null;
      const median = stats.median !== undefined ? Number(stats.median) : null;
      const p25 = stats.p25 !== undefined ? Number(stats.p25) : null;
      const p75 = stats.p75 !== undefined ? Number(stats.p75) : null;

      // Update overview tab
      document.getElementById("overview-mean-value").textContent =
        mean !== null ? mean.toFixed(3) : "--";
      document.getElementById("overview-median-value").textContent =
        median !== null ? median.toFixed(3) : "--";
      document.getElementById("overview-p25-value").textContent =
        p25 !== null ? p25.toFixed(3) : "--";
      document.getElementById("overview-p75-value").textContent =
        p75 !== null ? p75.toFixed(3) : "--";

      // Update progress bars for Kc
      const kcRange = min !== null && max !== null ? max - min : 1.2; // Default range for Kc
      const getKcWidthPercent = (val) => {
        if (val === null || min === null || kcRange <= 0) return "0%";
        return `${Math.max(
          0,
          Math.min(100, ((val - min) / kcRange) * 100)
        )}%`;
      };

      document.getElementById("overview-mean-bar").style.width =
        getKcWidthPercent(mean);
      document.getElementById("overview-mean-bar").style.backgroundColor =
        "#51cf66";

      ["1", "2", "3", "4"].forEach((i) => {
        document.getElementById(`overview-min${i}`).textContent =
          min !== null ? `Min: ${min.toFixed(3)}` : "Min: --";
        document.getElementById(`overview-max${i}`).textContent =
          max !== null ? `Max: ${max.toFixed(3)}` : "Max: --";
      });

      // Update health card for Kc
      let kcStatus, kcEmoji, kcBgColor;
      if (mean !== null) {
        if (mean < 0.3) {
          kcStatus = "Low Crop Coefficient";
          kcEmoji = "";
          kcBgColor = "#4dabf7";
        } else if (mean < 0.7) {
          kcStatus = "Moderate Crop Coefficient";
          kcEmoji = "";
          kcBgColor = "#51cf66";
        } else if (mean < 1.0) {
          kcStatus = "High Crop Coefficient";
          kcEmoji = "";
          kcBgColor = "#ffd43b";
        } else {
          kcStatus = "Very High Crop Coefficient";
          kcEmoji = "";
          kcBgColor = "#ff6b6b";
        }
      } else {
        kcStatus = "--";
        kcEmoji = "";
        kcBgColor = "#95a5a6";
      }

      document.getElementById("health-emoji").textContent = kcEmoji;
      document.getElementById("health-status-text").innerHTML = kcStatus;
      document.getElementById("overall-health-card").style.backgroundColor =
        kcBgColor;
      document.getElementById("health-summary").textContent = `Average: ${mean !== null ? mean.toFixed(3) : "--"
        } | Range: ${min !== null && max !== null ? (max - min).toFixed(3) : "--"
        }`;

      // Update detailed tab
      document.getElementById("detailed-mean").textContent =
        mean !== null ? mean.toFixed(3) : "--";
      document.getElementById("detailed-median").textContent =
        median !== null ? median.toFixed(3) : "--";
      document.getElementById("detailed-stddev").textContent =
        stdDev !== null ? stdDev.toFixed(3) : "--";
      document.getElementById("detailed-min").textContent =
        min !== null ? min.toFixed(3) : "--";
      document.getElementById("detailed-max").textContent =
        max !== null ? max.toFixed(3) : "--";
      document.getElementById("detailed-range").textContent =
        min !== null && max !== null ? (max - min).toFixed(3) : "--";

      // Show percentile sections for Kc
      document.querySelectorAll(".percentiles-dist-section").forEach((el) => {
        el.style.display = "block";
      });

      // Update visual tab
      if (ndviComparisonChart) ndviComparisonChart.destroy();
      const visualCtx = document
        .getElementById("ndviComparisonChart")
        .getContext("2d");
      const chartData = [min, mean, max].filter((v) => v !== null);
      const labels = ["Min", "Mean", "Max"].filter(
        (_, i) => [min, mean, max][i] !== null
      );

      ndviComparisonChart = new Chart(visualCtx, {
        type: "bar",
        data: {
          labels: labels,
          datasets: [
            {
              data: chartData,
              backgroundColor: ["#4dabf7", "#51cf66", "#ff8787"],
              borderRadius: 4,
            },
          ],
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { display: false },
            title: {
              display: true,
              text: "Kc Comparison",
              font: { size: 14 },
            },
          },
          scales: {
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: "Kc Value",
              },
            },
          },
        },
      });

      updateChartTheme();
    }

    // Function to update ETc (Crop evapotranspiration) statistics panel
    function updateETcStatsPanel(stats) {
      const dashboard = document.getElementById("ndvi-dashboard");
      const placeholder = document.getElementById(
        "default-analytics-placeholder"
      );

      if (!stats || stats.error) {
        dashboard.style.display = "none";
        placeholder.style.display = "flex";
        renderAnalyticsCharts();
        return;
      }

      dashboard.style.display = "flex";
      placeholder.style.display = "none";

      // Ensure right panel is open when showing stats
      ensureRightPanelOpen();

      // Update the dashboard title for ETc
      document.querySelector("#ndvi-dashboard h3").innerHTML = `
            <i class="fa-solid fa-tint" style="color: #339af0;"></i>
            ETc Statistics
        `;

      // Update tabs content for ETc data
      const mean = stats.mean !== undefined ? Number(stats.mean) : null;
      const min = stats.min !== undefined ? Number(stats.min) : null;
      const max = stats.max !== undefined ? Number(stats.max) : null;
      const stdDev = stats.stdDev !== undefined ? Number(stats.stdDev) : null;
      const median = stats.median !== undefined ? Number(stats.median) : null;
      const p25 = stats.p25 !== undefined ? Number(stats.p25) : null;
      const p75 = stats.p75 !== undefined ? Number(stats.p75) : null;

      // Update overview tab
      document.getElementById("overview-mean-value").textContent =
        mean !== null ? mean.toFixed(2) + " mm/day" : "--";
      document.getElementById("overview-median-value").textContent =
        median !== null ? median.toFixed(2) + " mm/day" : "--";
      document.getElementById("overview-p25-value").textContent =
        p25 !== null ? p25.toFixed(2) + " mm/day" : "--";
      document.getElementById("overview-p75-value").textContent =
        p75 !== null ? p75.toFixed(2) + " mm/day" : "--";

      // Update progress bars for ETc
      const etcRange = min !== null && max !== null ? max - min : 10; // Default range for ETc
      const getETcWidthPercent = (val) => {
        if (val === null || min === null || etcRange <= 0) return "0%";
        return `${Math.max(
          0,
          Math.min(100, ((val - min) / etcRange) * 100)
        )}%`;
      };

      document.getElementById("overview-mean-bar").style.width =
        getETcWidthPercent(mean);
      document.getElementById("overview-mean-bar").style.backgroundColor =
        "#339af0";

      ["1", "2", "3", "4"].forEach((i) => {
        document.getElementById(`overview-min${i}`).textContent =
          min !== null ? `Min: ${min.toFixed(2)} mm/day` : "Min: --";
        document.getElementById(`overview-max${i}`).textContent =
          max !== null ? `Max: ${max.toFixed(2)} mm/day` : "Max: --";
      });

      // Update health card for ETc
      let etcStatus, etcEmoji, etcBgColor;
      if (mean !== null) {
        if (mean < 0.3) {
          kcStatus = `<span data-i18n="low_kc">Low Crop Coefficient</span>`;
          kcEmoji = "";
          kcBgColor = "#4dabf7";
        } else if (mean < 0.7) {
          kcStatus = `<span data-i18n="moderate_kc">Moderate Crop Coefficient</span>`;
          kcEmoji = "";
          kcBgColor = "#51cf66";
        } else if (mean < 1.0) {
          kcStatus = `<span data-i18n="high_kc">High Crop Coefficient</span>`;
          kcEmoji = "";
          kcBgColor = "#ffd43b";
        } else {
          kcStatus = `<span data-i18n="very_high_kc">Very High Crop Coefficient</span>`;
          kcEmoji = "";
          kcBgColor = "#ff6b6b";
        }
      } else {
        kcStatus = `<span data-i18n="no_data">--</span>`;
        kcEmoji = "";
        kcBgColor = "#95a5a6";
      }

      document.getElementById("health-emoji").textContent = etcEmoji;
      document.getElementById("health-status-text").innerHTML = etcStatus;
      document.getElementById("overall-health-card").style.backgroundColor =
        etcBgColor;
      document.getElementById("health-summary").textContent = `Average: ${mean !== null ? mean.toFixed(2) + " mm/day" : "--"
        } | Range: ${min !== null && max !== null
          ? (max - min).toFixed(2) + " mm/day"
          : "--"
        }`;

      // Update detailed tab
      document.getElementById("detailed-mean").textContent =
        mean !== null ? mean.toFixed(2) + " mm/day" : "--";
      document.getElementById("detailed-median").textContent =
        median !== null ? median.toFixed(2) + " mm/day" : "--";
      document.getElementById("detailed-stddev").textContent =
        stdDev !== null ? stdDev.toFixed(2) + " mm/day" : "--";
      document.getElementById("detailed-min").textContent =
        min !== null ? min.toFixed(2) + " mm/day" : "--";
      document.getElementById("detailed-max").textContent =
        max !== null ? max.toFixed(2) + " mm/day" : "--";
      document.getElementById("detailed-range").textContent =
        min !== null && max !== null
          ? (max - min).toFixed(2) + " mm/day"
          : "--";

      // Show percentile sections for ETc
      document.querySelectorAll(".percentiles-dist-section").forEach((el) => {
        el.style.display = "block";
      });

      // Update visual tab
      if (ndviComparisonChart) ndviComparisonChart.destroy();
      const visualCtx = document
        .getElementById("ndviComparisonChart")
        .getContext("2d");
      const chartData = [min, mean, max].filter((v) => v !== null);
      const labels = ["Min", "Mean", "Max"].filter(
        (_, i) => [min, mean, max][i] !== null
      );

      ndviComparisonChart = new Chart(visualCtx, {
        type: "bar",
        data: {
          labels: labels,
          datasets: [
            {
              data: chartData,
              backgroundColor: ["#4dabf7", "#339af0", "#ff8787"],
              borderRadius: 4,
            },
          ],
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { display: false },
            title: {
              display: true,
              text: "ETc Comparison",
              font: { size: 14 },
            },
          },
          scales: {
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: "ETc (mm/day)",
              },
            },
          },
        },
      });

      updateChartTheme();
    }

    // Function to update CWR (Crop Water Requirement) statistics panel
    function updateCWRStatsPanel(stats) {
      const dashboard = document.getElementById("ndvi-dashboard");
      const placeholder = document.getElementById(
        "default-analytics-placeholder"
      );

      // Enhanced check for CWR data availability
      const hasCWRData =
        stats &&
        !stats.error &&
        stats.mean !== null &&
        stats.mean !== undefined &&
        stats.min !== null &&
        stats.min !== undefined &&
        stats.max !== null &&
        stats.max !== undefined;

      if (!hasCWRData) {
        dashboard.style.display = "none";
        placeholder.style.display = "flex";

        // Instead of showing SweetAlert, show empty graph
        createEmptyCWRGraph();
        return;
      }

      dashboard.style.display = "flex";
      placeholder.style.display = "none";

      // Ensure right panel is open when showing stats
      ensureRightPanelOpen();

      // Rest of your existing CWR panel code...
      // Update the dashboard title for CWR
      document.querySelector("#ndvi-dashboard h3").innerHTML = `
        <i class="fa-solid fa-droplet" style="color: #1c7ed6;"></i>
        CWR Statistics - Crop Water Requirement Analysis
    `;

      // Hide all tabs except the visual tab
      document.querySelectorAll(".ndvi-tab-btn").forEach((btn) => {
        btn.style.display = "none";
      });

      // Show only the visual tab
      const visualTab = document.querySelector(
        '.ndvi-tab-btn[data-tab="visual"]'
      );
      if (visualTab) {
        visualTab.style.display = "inline-flex";
        visualTab.classList.add("active");
      }

      // Hide other tab contents
      document.querySelectorAll(".ndvi-tab-content").forEach((content) => {
        content.style.display = "none";
      });

      // Show only the visual tab content
      const visualContent = document.getElementById("visual-tab");
      if (visualContent) {
        visualContent.style.display = "block";
      }

      // Create CWR bar chart
      createCWRBarChart();
    }


    function updateIrrigationNeedStatsPanel(stats) {
      const dashboard = document.getElementById("ndvi-dashboard");
      const placeholder = document.getElementById("default-analytics-placeholder");

      if (!stats || stats.error) {
        dashboard.style.display = "none";
        placeholder.style.display = "flex";
        renderAnalyticsCharts();
        return;
      }

      dashboard.style.display = "flex";
      placeholder.style.display = "none";
      ensureRightPanelOpen();

      // Update the dashboard title for Irrigation Need
      document.querySelector("#ndvi-dashboard h3").innerHTML = `
    <i class="fa-solid fa-droplet" style="color: #8e44ad;"></i>
    Irrigation Need Statistics
  `;

      // Update tabs content for irrigation need data
      const mean = stats.mean !== undefined ? Number(stats.mean) : null;
      const min = stats.min !== undefined ? Number(stats.min) : null;
      const max = stats.max !== undefined ? Number(stats.max) : null;
      const stdDev = stats.stdDev !== undefined ? Number(stats.stdDev) : null;
      const median = stats.median !== undefined ? Number(stats.median) : null;
      const p25 = stats.p25 !== undefined ? Number(stats.p25) : null;
      const p75 = stats.p75 !== undefined ? Number(stats.p75) : null;

      // Update overview tab
      document.getElementById("overview-mean-value").textContent =
        mean !== null ? mean.toFixed(2) + " mm/day" : "--";
      document.getElementById("overview-median-value").textContent =
        median !== null ? median.toFixed(2) + " mm/day" : "--";
      document.getElementById("overview-p25-value").textContent =
        p25 !== null ? p25.toFixed(2) + " mm/day" : "--";
      document.getElementById("overview-p75-value").textContent =
        p75 !== null ? p75.toFixed(2) + " mm/day" : "--";

      // Update progress bars for irrigation need
      const irrRange = min !== null && max !== null ? max - min : 10;
      const getIrrWidthPercent = (val) => {
        if (val === null || min === null || irrRange <= 0) return "0%";
        return `${Math.max(0, Math.min(100, ((val - min) / irrRange) * 100))}%`;
      };

      document.getElementById("overview-mean-bar").style.width =
        getIrrWidthPercent(mean);
      document.getElementById("overview-mean-bar").style.backgroundColor = "#8e44ad";
      document.getElementById("overview-median-bar").style.width =
        getIrrWidthPercent(median);
      document.getElementById("overview-median-bar").style.backgroundColor = "#8e44ad";
      document.getElementById("overview-p25-bar").style.width =
        getIrrWidthPercent(p25);
      document.getElementById("overview-p25-bar").style.backgroundColor = "#8e44ad";
      document.getElementById("overview-p75-bar").style.width =
        getIrrWidthPercent(p75);
      document.getElementById("overview-p75-bar").style.backgroundColor = "#8e44ad";

      ["1", "2", "3", "4"].forEach((i) => {
        document.getElementById(`overview-min${i}`).textContent =
          min !== null ? `Min: ${min.toFixed(2)} mm/day` : "Min: --";
        document.getElementById(`overview-max${i}`).textContent =
          max !== null ? `Max: ${max.toFixed(2)} mm/day` : "Max: --";
      });

      // Update health card for irrigation need
      let irrStatus, irrEmoji, irrBgColor;
      if (mean !== null) {
        if (mean <= 0) {
          irrStatus = "No Irrigation Needed";
          irrEmoji = "";
          irrBgColor = "#28a745";
        } else if (mean < 2) {
          irrStatus = "Low Irrigation Need";
          irrEmoji = "";
          irrBgColor = "#ffc107";
        } else if (mean < 5) {
          irrStatus = "Moderate Irrigation Need";
          irrEmoji = "";
          irrBgColor = "#fd7e14";
        } else {
          irrStatus = "High Irrigation Need";
          irrEmoji = "";
          irrBgColor = "#dc3545";
        }
      } else {
        irrStatus = "--";
        irrEmoji = "";
        irrBgColor = "#95a5a6";
      }

      document.getElementById("health-emoji").textContent = irrEmoji;
      document.getElementById("health-status-text").innerHTML = irrStatus;
      document.getElementById("overall-health-card").style.backgroundColor = irrBgColor;
      document.getElementById("health-summary").textContent = `Average: ${mean !== null ? mean.toFixed(2) + " mm/day" : "--"
        } | Range: ${min !== null && max !== null ? (max - min).toFixed(2) + " mm/day" : "--"
        }`;

      // Update detailed tab
      document.getElementById("detailed-mean").textContent =
        mean !== null ? mean.toFixed(2) + " mm/day" : "--";
      document.getElementById("detailed-median").textContent =
        median !== null ? median.toFixed(2) + " mm/day" : "--";
      document.getElementById("detailed-stddev").textContent =
        stdDev !== null ? stdDev.toFixed(2) + " mm/day" : "--";
      document.getElementById("detailed-min").textContent =
        min !== null ? min.toFixed(2) + " mm/day" : "--";
      document.getElementById("detailed-max").textContent =
        max !== null ? max.toFixed(2) + " mm/day" : "--";
      document.getElementById("detailed-range").textContent =
        min !== null && max !== null ? (max - min).toFixed(2) + " mm/day" : "--";

      // Show percentile sections
      document.querySelectorAll(".percentiles-dist-section").forEach((el) => {
        el.style.display = "block";
      });

      // Update visual tab
      if (ndviComparisonChart) ndviComparisonChart.destroy();
      const visualCtx = document.getElementById("ndviComparisonChart").getContext("2d");
      const chartData = [min, p25, median, mean, p75, max].filter((v) => v !== null);
      const labels = ["Min", "P25", "Median", "Mean", "P75", "Max"].filter(
        (_, i) => [min, p25, median, mean, p75, max][i] !== null
      );

      // Color coding based on irrigation need levels
      const backgroundColors = chartData.map((value) => {
        if (value <= 0) return "#28a745"; // No need - Green
        else if (value < 2) return "#ffc107"; // Low - Yellow
        else if (value < 5) return "#fd7e14"; // Moderate - Orange
        else return "#dc3545"; // High - Red
      });

      ndviComparisonChart = new Chart(visualCtx, {
        type: "bar",
        data: {
          labels: labels,
          datasets: [
            {
              label: "Irrigation Need (mm/day)",
              data: chartData,
              backgroundColor: backgroundColors,
              borderRadius: 4,
            },
          ],
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { display: false },
            title: {
              display: true,
              text: "Irrigation Need Analysis",
              font: { size: 14 },
            },
          },
          scales: {
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: "Irrigation Need (mm/day)",
              },
            },
          },
        },
      });

      updateChartTheme();
    }
    // Function to create empty CWR graph when no data
    function createEmptyCWRGraph() {
      document.getElementById("visual-tab").innerHTML = `
          <div style="text-align: center; padding: 20px;">
            <i class="fa-solid fa-chart-bar" style="font-size: 48px; color: #1c7ed6; margin-bottom: 15px;"></i>
            <h3 style="color: #1c7ed6; margin-bottom: 10px;">No CWR Data Available</h3>
            <p style="color: #666;">No crop water requirement data found for the selected period.</p>
            <p style="color: #999; font-size: 12px; margin-top: 10px;">
              CWR data comes from the daily agricultural data. Try selecting a different date range or area.
            </p>
          </div>
        `;
    }

    // Function to create CWR bar chart
    function createCWRBarChart() {
      if (!fullChartData || fullChartData.length === 0) {
        createEmptyCWRGraph();
        return;
      }

      // Filter CWR data
      const cwrData = fullChartData.filter(
        (d) => d.cwr !== null && d.cwr !== undefined
      );

      if (cwrData.length === 0) {
        createEmptyCWRGraph();
        return;
      }

      // Group data by week
      const weeklyData = {};
      cwrData.forEach((item) => {
        const date = new Date(item.date);
        const weekStart = new Date(date);
        weekStart.setDate(date.getDate() - date.getDay()); // Start of week (Sunday)
        const weekKey = weekStart.toISOString().split("T")[0];

        if (!weeklyData[weekKey]) {
          weeklyData[weekKey] = {
            week: weekKey,
            totalCWR: 0,
            days: 0,
            avgCWR: 0,
          };
        }

        weeklyData[weekKey].totalCWR += item.cwr;
        weeklyData[weekKey].days += 1;
      });

      // Calculate weekly averages
      const weeklyValues = Object.values(weeklyData)
        .map((week) => {
          week.avgCWR = week.totalCWR / week.days;
          return week;
        })
        .sort((a, b) => new Date(a.week) - new Date(b.week));

      // Create chart container
      document.getElementById("visual-tab").innerHTML = `
                <div style="padding: 20px;">
                    <h4 style="color: #1c7ed6; margin-bottom: 15px; text-align: center;">
                        <i class="fa-solid fa-chart-bar"></i> Bar Chart for Weekly CWR
                    </h4>
                    <p style="color: #666; text-align: center; margin-bottom: 20px; font-size: 14px;">
                        Each bar = total crop water requirement per week. Helps visualize total irrigation demand pattern.
                    </p>
                    <div style="position: relative; height: 400px;">
                        <canvas id="cwrBarChart"></canvas>
                    </div>
                    <div style="margin-top: 15px; text-align: center;">
                        <div style="display: inline-block; background: #e3f2fd; padding: 10px 15px; border-radius: 8px;">
                            <span style="color: #1976d2; font-weight: 600;">Total Weeks Analyzed: ${weeklyValues.length}</span>
                        </div>
                    </div>
                </div>
            `;

      // Create the bar chart
      const ctx = document.getElementById("cwrBarChart").getContext("2d");

      if (
        window.cwrBarChart &&
        typeof window.cwrBarChart.destroy === "function"
      ) {
        window.cwrBarChart.destroy();
      }

      window.cwrBarChart = new Chart(ctx, {
        type: "bar",
        data: {
          labels: weeklyValues.map((w) => {
            const date = new Date(w.week);
            return date.toLocaleDateString("en-GB", {
              month: "short",
              day: "numeric",
            });
          }),
          datasets: [
            {
              label: "Weekly CWR (mm)",
              data: weeklyValues.map((w) => w.totalCWR.toFixed(2)),
              backgroundColor: "#1c7ed6",
              borderColor: "#1976d2",
              borderWidth: 1,
              borderRadius: 4,
              borderSkipped: false,
            },
          ],
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            title: {
              display: true,
              text: "Crop Water Requirement - Weekly Analysis",
              font: { size: 16, weight: "bold" },
              color: "#1c7ed6",
            },
            legend: {
              display: true,
              position: "top",
            },
            tooltip: {
              callbacks: {
                title: function (context) {
                  const weekIndex = context[0].dataIndex;
                  const weekData = weeklyValues[weekIndex];
                  const startDate = new Date(weekData.week);
                  const endDate = new Date(startDate);
                  endDate.setDate(startDate.getDate() + 6);
                  return `Week: ${startDate.toLocaleDateString()} - ${endDate.toLocaleDateString()}`;
                },
                label: function (context) {
                  const weekIndex = context.dataIndex;
                  const weekData = weeklyValues[weekIndex];
                  return [
                    `Total CWR: ${weekData.totalCWR.toFixed(2)} mm`,
                    `Average Daily CWR: ${weekData.avgCWR.toFixed(2)} mm/day`,
                    `Days in Week: ${weekData.days}`,
                  ];
                },
              },
            },
          },
          scales: {
            x: {
              title: {
                display: true,
                text: "Week Starting Date",
                font: { weight: "bold" },
              },
              ticks: {
                maxRotation: 45,
                minRotation: 0,
              },
            },
            y: {
              title: {
                display: true,
                text: "Crop Water Requirement (mm)",
                font: { weight: "bold" },
              },
              beginAtZero: true,
            },
          },
          interaction: {
            intersect: false,
            mode: "index",
          },
        },
      });

      // Update chart theme for dark mode
      updateChartTheme();
    }

    // Helper function to safely create charts
    function createSafeChart(canvasId, chartConfig, chartName = "Chart") {
      try {
        const canvasElement = document.getElementById(canvasId);
        if (!canvasElement) {
          console.error(`${chartName} canvas element not found: ${canvasId}`);
          return null;
        }

        const ctx = canvasElement.getContext("2d");
        if (!ctx) {
          console.error(`${chartName} context not available`);
          return null;
        }

        return new Chart(ctx, chartConfig);
      } catch (error) {
        console.error(`${chartName} creation failed:`, error);
        return null;
      }
    }

    // Function to add soil moisture process information
    function addSoilMoistureProcessInfo(mean, min, max) {
      // Create or update soil moisture process information section
      let processInfo = document.getElementById("soil-moisture-process-info");
      if (!processInfo) {
        processInfo = document.createElement("div");
        processInfo.id = "soil-moisture-process-info";
        processInfo.style.cssText = `
                margin-top: 20px;
                padding: 15px;
                background: linear-gradient(135deg, #f3e5f5 0%, #e8f5e8 100%);
                border-radius: 10px;
                border-left: 4px solid #8b5cf6;
            `;

        const dashboard = document.getElementById("ndvi-dashboard");
        const visualTab = dashboard.querySelector(".visual-tab");
        if (visualTab) {
          visualTab.appendChild(processInfo);
        }
      }

      // Calculate derived metrics
      const weeklyChange = mean ? (mean * 7).toFixed(2) : "--";
      const monthlyChange = mean ? (mean * 30).toFixed(2) : "--";
      const annualChange = mean ? (mean * 365).toFixed(2) : "--";

      processInfo.innerHTML = `
            <h4 style="color: #8b5cf6; margin-bottom: 15px; display: flex; align-items: center;">
                <i class="fa-solid fa-seedling" style="margin-right: 8px;"></i>
                Soil Moisture Change Process Analysis
            </h4>
            
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px;">
                <!-- SMAP Data Source -->
                <div style="background: white; padding: 12px; border-radius: 8px; border-left: 3px solid #4dabf7;">
                    <h5 style="color: #4dabf7; margin-bottom: 8px; display: flex; align-items: center;">
                        <i class="fa-solid fa-satellite" style="margin-right: 5px;"></i>
                        SMAP Data Source
                    </h5>
                    <ul style="margin: 0; padding-left: 15px; font-size: 13px;">
                        <li>NASA SMAP L-band radar</li>
                        <li>Soil moisture measurements</li>
                        <li>Daily temporal resolution</li>
                        <li>9km spatial resolution</li>
                    </ul>
                    <p style="margin: 8px 0 0 0; font-size: 12px; color: #666; font-style: italic;">
                        Provides accurate soil moisture data for change detection
                    </p>
                </div>

                <!-- Soil Moisture Calculation -->
                <div style="background: white; padding: 12px; border-radius: 8px; border-left: 3px solid #ffd43b;">
                    <h5 style="color: #ffd43b; margin-bottom: 8px; display: flex; align-items: center;">
                        <i class="fa-solid fa-calculator" style="margin-right: 5px;"></i>
                        S Calculation
                    </h5>
                    <p style="margin: 5px 0; font-size: 13px;"><strong>Formula:</strong> S = SM_today - SM_previous</p>
                    <p style="margin: 5px 0; font-size: 13px;"><strong>Units:</strong> mm (millimeters)</p>
                    <p style="margin: 8px 0 0 0; font-size: 12px; color: #666; font-style: italic;">
                        Positive values indicate moisture gain, negative values indicate loss
                    </p>
                </div>

                <!-- Moisture Change Interpretation -->
                <div style="background: white; padding: 12px; border-radius: 8px; border-left: 3px solid #8b5cf6;">
                    <h5 style="color: #8b5cf6; margin-bottom: 8px; display: flex; align-items: center;">
                        <i class="fa-solid fa-chart-line" style="margin-right: 5px;"></i>
                        Change Interpretation
                    </h5>
                    <p style="margin: 5px 0; font-size: 13px;">S > 0: Soil moisture increasing</p>
                    <p style="margin: 5px 0; font-size: 13px;">S < 0: Soil moisture decreasing</p>
                    <p style="margin: 5px 0; font-size: 13px;">Critical threshold: 2m/m</p>
                </div>

                <!-- Agricultural Impact -->
                <div style="background: white; padding: 12px; border-radius: 8px; border-left: 3px solid #51cf66;">
                    <h5 style="color: #51cf66; margin-bottom: 8px; display: flex; align-items: center;">
                        <i class="fa-solid fa-tractor" style="margin-right: 5px;"></i>
                        Agricultural Impact
                    </h5>
                    <p style="margin: 5px 0; font-size: 13px;">Irrigation planning</p>
                    <p style="margin: 5px 0; font-size: 13px;">Crop water stress monitoring</p>
                    <p style="margin: 5px 0; font-size: 13px;">Soil health assessment</p>
                </div>
            </div>

            <!-- Soil Moisture Summary -->
            <div style="margin-top: 15px; background: white; padding: 15px; border-radius: 8px; border: 2px solid #8b5cf6;">
                <h5 style="color: #8b5cf6; margin-bottom: 10px; display: flex; align-items: center;">
                    <i class="fa-solid fa-chart-area" style="margin-right: 8px;"></i>
                    Soil Moisture Change Summary & Projections
                </h5>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px; text-align: center;">
                    <div style="background: #f3e5f5; padding: 10px; border-radius: 6px;">
                        <div style="font-weight: bold; color: #8b5cf6;">Daily Change</div>
                        <div style="font-size: 18px; font-weight: bold;">${mean ? mean.toFixed(2) : "--"
        } mm/day</div>
                    </div>
                    <div style="background: #e8f5e8; padding: 10px; border-radius: 6px;">
                        <div style="font-weight: bold; color: #2e7d32;">Weekly Change</div>
                        <div style="font-size: 18px; font-weight: bold;">${weeklyChange} mm/week</div>
                    </div>
                    <div style="background: #fff3e0; padding: 10px; border-radius: 6px;">
                        <div style="font-weight: bold; color: #f57c00;">Monthly Change</div>
                        <div style="font-size: 18px; font-weight: bold;">${monthlyChange} mm/month</div>
                    </div>
                    <div style="background: #fce4ec; padding: 10px; border-radius: 6px;">
                        <div style="font-weight: bold; color: #c2185b;">Annual Change</div>
                        <div style="font-size: 18px; font-weight: bold;">${annualChange} mm/year</div>
                    </div>
                </div>
            </div>
        `;
    }

    // Function to add CWR process information
    function addCWRProcessInfo(mean, min, max) {
      // Create or update CWR process information section
      let processInfo = document.getElementById("cwr-process-info");
      if (!processInfo) {
        processInfo = document.createElement("div");
        processInfo.id = "cwr-process-info";
        processInfo.style.cssText = `
                margin-top: 20px;
                padding: 15px;
                background: linear-gradient(135deg, #e3f2fd 0%, #f3e5f5 100%);
                border-radius: 10px;
                border-left: 4px solid #1c7ed6;
            `;

        const dashboard = document.getElementById("ndvi-dashboard");
        const visualTab = dashboard.querySelector(".visual-tab");
        if (visualTab) {
          visualTab.appendChild(processInfo);
        }
      }

      // Calculate derived metrics
      const weeklyCWR = mean ? (mean * 7).toFixed(2) : "--";
      const monthlyCWR = mean ? (mean * 30).toFixed(2) : "--";
      const annualCWR = mean ? (mean * 365).toFixed(2) : "--";

      processInfo.innerHTML = `
            <h4 style="color: #1c7ed6; margin-bottom: 15px; display: flex; align-items: center;">
                <i class="fa-solid fa-seedling" style="margin-right: 8px;"></i>
                Crop Water Requirement Process Analysis
            </h4>
            
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px;">
                <!-- Weather/Climate Data -->
                <div style="background: white; padding: 12px; border-radius: 8px; border-left: 3px solid #4dabf7;">
                    <h5 style="color: #4dabf7; margin-bottom: 8px; display: flex; align-items: center;">
                        <i class="fa-solid fa-cloud-sun" style="margin-right: 5px;"></i>
                        Weather/Climate Data
                    </h5>
                    <ul style="margin: 0; padding-left: 15px; font-size: 13px;">
                        <li>Temperature (K)</li>
                        <li>Humidity (%)</li>
                        <li>Wind speed (m/s)</li>
                        <li>Solar radiation (MJ/m/day)</li>
                        <li>Rainfall (mm/day)</li>
                    </ul>
                    <p style="margin: 8px 0 0 0; font-size: 12px; color: #666; font-style: italic;">
                        Used to compute reference evapotranspiration (ETo)
                    </p>
                </div>

                <!-- Evapotranspiration Data -->
                <div style="background: white; padding: 12px; border-radius: 8px; border-left: 3px solid #ffd43b;">
                    <h5 style="color: #ffd43b; margin-bottom: 8px; display: flex; align-items: center;">
                        <i class="fa-solid fa-leaf" style="margin-right: 5px;"></i>
                        Evapotranspiration Data
                    </h5>
                    <p style="margin: 5px 0; font-size: 13px;"><strong>ETo:</strong> Reference evapotranspiration</p>
                    <p style="margin: 5px 0; font-size: 13px;"><strong>ETc:</strong> Crop evapotranspiration = ETo  Kc</p>
                    <p style="margin: 8px 0 0 0; font-size: 12px; color: #666; font-style: italic;">
                        ETc tells you how much water the crop actually needs
                    </p>
                </div>

                <!-- Effective Rainfall -->
                <div style="background: white; padding: 12px; border-radius: 8px; border-left: 3px solid #8b5cf6;">
                    <h5 style="color: #8b5cf6; margin-bottom: 8px; display: flex; align-items: center;">
                        <i class="fa-solid fa-cloud-rain" style="margin-right: 5px;"></i>
                        Effective Rainfall
                    </h5>
                    <p style="margin: 5px 0; font-size: 13px;">Shows how much rainfall is usable by crops</p>
                    <p style="margin: 5px 0; font-size: 13px;">Helps estimate net irrigation requirement (NIR)</p>
                </div>

                <!-- Irrigation Requirement -->
                <div style="background: white; padding: 12px; border-radius: 8px; border-left: 3px solid #51cf66;">
                    <h5 style="color: #51cf66; margin-bottom: 8px; display: flex; align-items: center;">
                        <i class="fa-solid fa-tractor" style="margin-right: 5px;"></i>
                        Irrigation Requirement
                    </h5>
                    <p style="margin: 5px 0; font-size: 13px;"><strong>NIR:</strong> Net Irrigation Requirement</p>
                    <p style="margin: 5px 0; font-size: 13px;"><strong>Formula:</strong> NIR = ETc - Effective Rainfall</p>
                    <p style="margin: 5px 0; font-size: 13px;">When and how much to irrigate</p>
                </div>
            </div>

            <!-- CWR Summary -->
            <div style="margin-top: 15px; background: white; padding: 15px; border-radius: 8px; border: 2px solid #1c7ed6;">
                <h5 style="color: #1c7ed6; margin-bottom: 10px; display: flex; align-items: center;">
                    <i class="fa-solid fa-chart-line" style="margin-right: 8px;"></i>
                    CWR Summary & Projections
                </h5>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px; text-align: center;">
                    <div style="background: #e3f2fd; padding: 10px; border-radius: 6px;">
                        <div style="font-weight: bold; color: #1c7ed6;">Daily CWR</div>
                        <div style="font-size: 18px; font-weight: bold;">${mean ? mean.toFixed(2) : "--"
        } mm/day</div>
                    </div>
                    <div style="background: #e8f5e8; padding: 10px; border-radius: 6px;">
                        <div style="font-weight: bold; color: #2e7d32;">Weekly CWR</div>
                        <div style="font-size: 18px; font-weight: bold;">${weeklyCWR} mm/week</div>
                    </div>
                    <div style="background: #fff3e0; padding: 10px; border-radius: 6px;">
                        <div style="font-weight: bold; color: #f57c00;">Monthly CWR</div>
                        <div style="font-size: 18px; font-weight: bold;">${monthlyCWR} mm/month</div>
                    </div>
                    <div style="background: #fce4ec; padding: 10px; border-radius: 6px;">
                        <div style="font-weight: bold; color: #c2185b;">Annual CWR</div>
                        <div style="font-size: 18px; font-weight: bold;">${annualCWR} mm/year</div>
                    </div>
                </div>
            </div>
        `;
    }

    // Function to update DeltaS (Soil moisture change) statistics panel
    function updateDeltaSStatsPanel(stats) {
      const dashboard = document.getElementById("ndvi-dashboard");
      const placeholder = document.getElementById(
        "default-analytics-placeholder"
      );

      // Enhanced check for DeltaS data availability
      const hasDeltaSData =
        stats &&
        !stats.error &&
        stats.mean !== null &&
        stats.mean !== undefined &&
        stats.min !== null &&
        stats.min !== undefined &&
        stats.max !== null &&
        stats.max !== undefined;

      if (!hasDeltaSData) {
        dashboard.style.display = "none";
        placeholder.style.display = "flex";

        // Instead of showing SweetAlert, show empty graph
        createEmptyDeltaSGraph();
        return;
      }

      // Rest of your existing DeltaS panel code...
      dashboard.style.display = "flex";
      placeholder.style.display = "none";

      // Ensure right panel is open when showing stats
      ensureRightPanelOpen();

      // Update the dashboard title for DeltaS
      document.querySelector("#ndvi-dashboard h3").innerHTML = `
        <i class="fa-solid fa-seedling" style="color: #8b5cf6;"></i>
        S Statistics - Soil Moisture Change Analysis
    `;

      // Update tabs content for DeltaS data
      const mean = stats.mean !== undefined ? Number(stats.mean) : null;
      const min = stats.min !== undefined ? Number(stats.min) : null;
      const max = stats.max !== undefined ? Number(stats.max) : null;
      const stdDev = stats.stdDev !== undefined ? Number(stats.stdDev) : null;
      const median = stats.median !== undefined ? Number(stats.median) : null;
      const p25 = stats.p25 !== undefined ? Number(stats.p25) : null;
      const p75 = stats.p75 !== undefined ? Number(stats.p75) : null;

      // Update overview tab
      document.getElementById("overview-mean-value").textContent =
        mean !== null ? mean.toFixed(2) + " mm" : "--";
      document.getElementById("overview-median-value").textContent =
        median !== null ? median.toFixed(2) + " mm" : "--";
      document.getElementById("overview-p25-value").textContent =
        p25 !== null ? p25.toFixed(2) + " mm" : "--";
      document.getElementById("overview-p75-value").textContent =
        p75 !== null ? p75.toFixed(2) + " mm" : "--";

      // Update progress bars for DeltaS
      const deltaSRange = min !== null && max !== null ? max - min : 10; // Default range for DeltaS
      const getDeltaSWidthPercent = (val) => {
        if (val === null || min === null || deltaSRange <= 0) return "0%";
        return `${Math.max(
          0,
          Math.min(100, ((val - min) / deltaSRange) * 100)
        )}%`;
      };

      document.getElementById("overview-mean-bar").style.width =
        getDeltaSWidthPercent(mean);
      document.getElementById("overview-mean-bar").style.backgroundColor =
        "#8b5cf6";

      ["1", "2", "3", "4"].forEach((i) => {
        document.getElementById(`overview-min${i}`).textContent =
          min !== null ? `Min: ${min.toFixed(2)} mm` : "Min: --";
        document.getElementById(`overview-max${i}`).textContent =
          max !== null ? `Max: ${max.toFixed(2)} mm` : "Max: --";
      });

      // Enhanced health card for DeltaS with soil moisture recommendations
      let deltaSStatus, deltaSEmoji, deltaSBgColor, soilAdvice;
      if (mean !== null) {
        if (mean < -2) {
          deltaSStatus = "Significant Moisture Loss";
          deltaSEmoji = "";
          deltaSBgColor = "#ff6b6b";
          soilAdvice =
            "Critical soil moisture loss. Immediate irrigation required.";
        } else if (mean < 0) {
          deltaSStatus = "Moisture Loss";
          deltaSEmoji = "";
          deltaSBgColor = "#ffd43b";
          soilAdvice =
            "Soil moisture declining. Consider irrigation planning.";
        } else if (mean < 2) {
          deltaSStatus = "Moisture Gain";
          deltaSEmoji = "";
          deltaSBgColor = "#51cf66";
          soilAdvice =
            "Healthy soil moisture increase. Good water retention.";
        } else {
          deltaSStatus = "Significant Moisture Gain";
          deltaSEmoji = "";
          deltaSBgColor = "#4dabf7";
          soilAdvice =
            "Excellent moisture retention. Optimal soil conditions.";
        }
      } else {
        deltaSStatus = "--";
        deltaSEmoji = "";
        deltaSBgColor = "#95a5a6";
        soilAdvice = "Data unavailable for analysis.";
      }

      document.getElementById("health-emoji").textContent = deltaSEmoji;
      document.getElementById("health-status-text").innerHTML = deltaSStatus;
      document.getElementById("overall-health-card").style.backgroundColor =
        deltaSBgColor;
      document.getElementById("health-summary").textContent = `Average: ${mean !== null ? mean.toFixed(2) + " m/m" : "--"
        } | Range: ${min !== null && max !== null
          ? (max - min).toFixed(2) + " m/m"
          : "--"
        } | ${soilAdvice}`;

      // Update detailed tab
      document.getElementById("detailed-mean").textContent =
        mean !== null ? mean.toFixed(2) + "m/m" : "--";
      document.getElementById("detailed-median").textContent =
        median !== null ? median.toFixed(2) + " m/m" : "--";
      document.getElementById("detailed-stddev").textContent =
        stdDev !== null ? stdDev.toFixed(2) + " m/m" : "--";
      document.getElementById("detailed-min").textContent =
        min !== null ? min.toFixed(2) + " m/m" : "--";
      document.getElementById("detailed-max").textContent =
        max !== null ? max.toFixed(2) + " m/m" : "--";
      document.getElementById("detailed-range").textContent =
        min !== null && max !== null
          ? (max - min).toFixed(2) + " m/m"
          : "--";

      // Show percentile sections for DeltaS
      document.querySelectorAll(".percentiles-dist-section").forEach((el) => {
        el.style.display = "block";
      });

      // Enhanced visual tab with comprehensive soil moisture analysis
      if (ndviComparisonChart) ndviComparisonChart.destroy();

      // Create comprehensive soil moisture analysis chart
      const chartData = [min, p25, median, mean, p75, max].filter(
        (v) => v !== null
      );
      const labels = ["Min", "Q1", "Median", "Mean", "Q3", "Max"].filter(
        (_, i) => [min, p25, median, mean, p75, max][i] !== null
      );

      // Color coding based on soil moisture change levels
      const backgroundColors = chartData.map((value) => {
        if (value < -2) return "#ff6b6b"; // Critical Loss - Red
        else if (value < 0) return "#ffd43b"; // Loss - Yellow
        else if (value < 2) return "#51cf66"; // Gain - Green
        else return "#4dabf7"; // Significant Gain - Blue
      });

      const chartConfig = {
        type: "bar",
        data: {
          labels: labels,
          datasets: [
            {
              label: "S (mm)",
              data: chartData,
              backgroundColor: backgroundColors,
              borderColor: "#8b5cf6",
              borderWidth: 2,
              borderRadius: 4,
            },
          ],
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: true,
              position: "top",
            },
            title: {
              display: true,
              text: "Soil Moisture Change Analysis",
              font: { size: 16, weight: "bold" },
            },
            tooltip: {
              callbacks: {
                label: function (context) {
                  const value = context.parsed.y;
                  let level = "";
                  if (value < -2) level = " (Critical Loss)";
                  else if (value < 0) level = " (Moisture Loss)";
                  else if (value < 2) level = " (Moisture Gain)";
                  else level = " (Significant Gain)";
                  return (
                    context.dataset.label +
                    ": " +
                    value.toFixed(2) +
                    " m/m" +
                    level
                  );
                },
              },
            },
          },
          scales: {
            y: {
              beginAtZero: false,
              title: {
                display: true,
                text: "Soil Moisture Change (m/m)",
                font: { size: 14, weight: "bold" },
              },
              grid: {
                color: "rgba(0,0,0,0.1)",
              },
            },
            x: {
              title: {
                display: true,
                text: "Statistical Measures",
                font: { size: 14, weight: "bold" },
              },
            },
          },
          animation: {
            duration: 2000,
            easing: "easeInOutQuart",
          },
        },
      };

      // Add a small delay to ensure DOM is ready
      setTimeout(() => {
        ndviComparisonChart = createSafeChart(
          "ndviComparisonChart",
          chartConfig,
          "DeltaS Chart"
        );

        // Add soil moisture process information to the dashboard
        addSoilMoistureProcessInfo(mean, min, max);

        updateChartTheme();
      }, 100);
    }

    // Function to create empty DeltaS graph when no data
    function createEmptyDeltaSGraph() {
      document.getElementById("visual-tab").innerHTML = `
          <div style="text-align: center; padding: 20px;">
            <i class="fa-solid fa-seedling" style="font-size: 48px; color: #8b5cf6; margin-bottom: 15px;"></i>
            <h3 style="color: #8b5cf6; margin-bottom: 10px;">No Soil Moisture Change Data Available</h3>
            <p style="color: #666;">No soil moisture change data found for the selected period.</p>
            <p style="color: #999; font-size: 12px; margin-top: 10px;">
              S data comes from SMAP satellite measurements. Try selecting a different date range or area.
            </p>
          </div>
        `;
    }
    // Global variables for default dates (accessible to fetchData function)
    let defaultStart = "2024-01-01"; // Will be updated on DOMContentLoaded
    let defaultEnd = "2024-06-30"; // Will be updated on DOMContentLoaded

    document.addEventListener("DOMContentLoaded", function () {
      // Set max date to today to allow selecting recent dates
      const today = new Date();
      const maxDate = today.toISOString().split("T")[0]; // Format: YYYY-MM-DD

      // Set max date for both inputs to allow selecting up to today
      const startEl = document.getElementById("start");
      const endEl = document.getElementById("end");

      if (startEl) {
        startEl.setAttribute("max", maxDate);
      }
      if (endEl) {
        endEl.setAttribute("max", maxDate);
      }

      // Calculate default dates: 6 months ago to today
      const sixMonthsAgo = new Date();
      sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);
      defaultStart = sixMonthsAgo.toISOString().split("T")[0]; // YYYY-MM-DD
      defaultEnd = maxDate; // Today

      // Only set default visually if field is empty
      if (startEl && !startEl.value) {
        startEl.value = defaultStart;
        startEl.classList.add("input-default"); // highlight
      }

      if (endEl && !endEl.value) {
        endEl.value = defaultEnd;
        endEl.classList.add("input-default"); // highlight
      }

      // Remove highlight when user changes the value (they manually edited)
      if (startEl) {
        startEl.addEventListener("input", () =>
          startEl.classList.remove("input-default")
        );
      }
      if (endEl) {
        endEl.addEventListener("input", () =>
          endEl.classList.remove("input-default")
        );
      }
    });
    async function fetchData() {
      const start_date =
        document.getElementById("start")?.value || defaultStart;
      const end_date = document.getElementById("end")?.value || defaultEnd;

      // Add date validation like backend
      const start = new Date(start_date);
      const end = new Date(end_date);
      const diffDays = Math.ceil((end - start) / (1000 * 60 * 60 * 24));

      if (diffDays > 365) {
        Swal.fire({
          icon: "warning",
          title: "Date Range Too Large",
          text: "Please select  12 months ( 365 days).",
        });
        return;
      }

      const spinner = document.getElementById("spinner");
      const chartPlaceholder = document.getElementById("chart-placeholder");
      const chartTabs = document.getElementById("chart-tabs");
      const weatherDropdown = document.getElementById(
        "weather-parameter-dropdown"
      );

      if (spinner) spinner.style.display = "block";
      if (chartPlaceholder) chartPlaceholder.style.display = "none";

      try {
        // Automatically load RGB layer when fetching data
        await loadRGBLayer();

        const res = await fetch("/get_daily_data", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            aoi: drawnAOI.toGeoJSON(),
            start_date,
            end_date,
          }),
        });

        let body = null;
        // Try parse JSON body regardless of res.ok so we can show server error details
        try {
          body = await res.json();
        } catch (parseErr) {
          // If parsing fails, leave body as null
          body = null;
        }

        if (!res.ok) {
          // Show server-provided message if present, otherwise generic
          const serverMessage =
            body && (body.message || body.error)
              ? body.message || body.error
              : `Server error (${res.status})`;
          const availability =
            body && body.availability ? body.availability : null;

          let html = `<div>${serverMessage}</div>`;
          if (availability) {
            html += "<br><b>Dataset availability:</b><br>";
            for (const k of Object.keys(availability)) {
              html += `${k}: ${availability[k]}<br>`;
            }
          }

          Swal.fire({
            icon: "warning",
            title: "Processing Error",
            html,
          });

          // Reset UI safe
          if (chartPlaceholder) {
            chartPlaceholder.style.display = "flex";
          }
          if (chartTabs) {
            chartTabs.style.display = "none";
          }
          if (weatherDropdown) {
            weatherDropdown.style.display = "none";
          }
          window.weatherData = null;
          return;
        }

        // res.ok -> body should be data array or an object with error
        const data = body;

        // ENHANCED ERROR HANDLING - Replace the existing check
        if (
          !data ||
          (Array.isArray(data) && data.length === 0) ||
          (data && data.error)
        ) {
          let errorMessage =
            "No data was found for the selected area and date range.";
          let errorDetails = "";

          if (data && data.error) {
            errorMessage = data.error;
            if (errorMessage.includes("No cloud-free Landsat imagery")) {
              errorDetails =
                "<br><br><strong>Suggestions:</strong><br> Try adjusting the date range<br> Increase cloud filter tolerance<br> Select a different area";
            } else if (errorMessage.includes("Date range too large")) {
              errorMessage = "Date Range Too Large";
              errorDetails =
                "<br><br>Please select  12 months ( 365 days).";
            }
          }

          Swal.fire({
            icon: "info",
            title: "No Data Available",
            html: errorMessage + errorDetails,
          });

          // Reset UI safely
          if (chartPlaceholder) {
            chartPlaceholder.style.display = "flex";
          }
          if (chartTabs) {
            chartTabs.style.display = "none";
          }
          if (weatherDropdown) {
            weatherDropdown.style.display = "none";
          }
          window.weatherData = null;
          return;
        }

        // Check for partial data availability
        const validData = Array.isArray(data)
          ? data.filter((item) => item.has_landsat)
          : [];
        if (
          validData.length === 0 &&
          Array.isArray(data) &&
          data.length > 0
        ) {
          Swal.fire({
            icon: "warning",
            title: "Limited Data Available",
            html: `Found ${data.length
              } time periods but no Landsat imagery.<br><br>
             <strong>Available datasets:</strong><br>
              SMAP (Soil Moisture): ${data.some((d) => d.has_smap) ? "" : ""
              }<br>
              CHIRPS (Rainfall): ${data.some((d) => d.has_chirps) ? "" : ""
              }<br>
              MODIS (ETo): ${data.some((d) => d.has_eto) ? "" : ""}<br><br>
             <em>Try adjusting dates or check other data layers.</em>`,
            confirmButtonColor: "var(--krishi-green)",
          });
        }

        // Good data path
        fullChartData = data;

        //  Save crop health data to localStorage for dashboard
        try {
          const cropHealthData = {
            data: data,
            startDate: start_date,
            endDate: end_date,
            timestamp: new Date().toISOString()
          };
          localStorage.setItem('lastCropHealthData', JSON.stringify(cropHealthData));
          console.log(' Crop health data saved to localStorage for dashboard');
        } catch (e) {
          console.warn('Failed to save crop health data to localStorage:', e);
        }

        if (chartTabs) chartTabs.style.display = "flex";

        // remove active classes safely
        const allTabBtns = document.querySelectorAll(".chart-tab-btn");
        if (allTabBtns && allTabBtns.length) {
          allTabBtns.forEach((btn) => btn.classList.remove("active"));
          const ndviBtn = document.querySelector(
            '.chart-tab-btn[data-param="ndvi"]'
          );
          if (ndviBtn) ndviBtn.classList.add("active");
        }

        renderSingleChart("ndvi");
        renderAnalyticsCharts();

        // Automatically open the right panel when data is fetched
        if (typeof ensureRightPanelOpen === "function") {
          try {
            ensureRightPanelOpen();
          } catch (e) {
            console.warn("ensureRightPanelOpen failed", e);
          }
        }

        // Check for optional data presence
        const hasSoilMoisture =
          Array.isArray(data) &&
          data.some(
            (d) =>
              d &&
              d.soilmoisture_mm !== null &&
              d.soilmoisture_mm !== undefined
          );
        const hasCWR =
          Array.isArray(data) &&
          data.some((d) => d && d.cwr !== null && d.cwr !== undefined);
        const hasDeltaS =
          Array.isArray(data) &&
          data.some((d) => d && d.deltas !== null && d.deltas !== undefined);

        console.log(
          "Data availability - Soil Moisture:",
          hasSoilMoisture,
          "CWR:",
          hasCWR,
          "DeltaS:",
          hasDeltaS
        );

        const soilMoistureTab = document.querySelector(
          '.chart-tab-btn[data-param="soilmoisture_mm"]'
        );
        const cwrTab = document.querySelector(
          '.chart-tab-btn[data-param="cwr"]'
        );
        const deltaSTab = document.querySelector(
          '.chart-tab-btn[data-param="deltas"]'
        );

        if (soilMoistureTab) {
          soilMoistureTab.style.display = hasSoilMoisture
            ? "inline-block"
            : "none";
          if (!hasSoilMoisture)
            soilMoistureTab.title = "No soil moisture data available";
        }
        if (cwrTab) {
          cwrTab.style.display = hasCWR ? "inline-block" : "none";
          if (!hasCWR)
            cwrTab.title = "No crop water requirement data available";
        }
        if (deltaSTab) {
          deltaSTab.style.display = hasDeltaS ? "inline-block" : "none";
          if (!hasDeltaS)
            deltaSTab.title = "No soil moisture change data available";
        }

        // Land cover calculation (defensive)
        const ndviValues = Array.isArray(data)
          ? data
            .map((d) => d && d.ndvi)
            .filter((v) => v !== null && v !== undefined)
          : [];
        if (
          ndviValues.length > 0 &&
          typeof calculateLandCover === "function"
        ) {
          const landCoverData = calculateLandCover(ndviValues);
          try {
            renderLandCoverChart(landCoverData);
          } catch (e) {
            console.warn("renderLandCoverChart failed", e);
          }
        }
      } catch (error) {
        console.error("Earth Engine processing failed:", error);

        Swal.fire({
          icon: "warning",
          title: "Processing Error",
          html:
            "<div>Data processing failed for the selected area.</div>" +
            "<br><b>Suggestions:</b><br>" +
            " Try a smaller area<br>" +
            " Select a different date range<br>" +
            " Check your internet connection",
        });

        // Reset/cleanup UI safely
        const chartContainer = document.getElementById("graph-container");
        if (chartContainer) chartContainer.innerHTML = "";

        if (chartTabs) chartTabs.style.display = "none";
        if (weatherDropdown) weatherDropdown.style.display = "none";
        window.weatherData = null;

        if (chartPlaceholder) {
          chartPlaceholder.style.display = "flex";
          chartPlaceholder.innerHTML =
            '<p>Draw a polygon, select dates, and click "Fetch Data".</p>';
        }

        const ndviDashboard = document.getElementById("ndvi-dashboard");
        if (ndviDashboard) ndviDashboard.style.display = "none";
        const defaultAnalytics = document.getElementById(
          "default-analytics-placeholder"
        );
        if (defaultAnalytics) defaultAnalytics.style.display = "flex";
      } finally {
        if (spinner) spinner.style.display = "none";
      }
    }

    // New function to load RGB layer
    async function loadRGBLayer() {
      if (!drawnAOI) return;

      try {
        const res = await fetch("/get_gee_tile", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            aoi: drawnAOI.toGeoJSON(),
            layer: "rgb",
            start_date: document.getElementById("start").value,
            end_date: document.getElementById("end").value,
          }),
        });

        if (!res.ok) throw new Error("Server response was not OK.");
        const result = await res.json();

        if (result.error || !result.urlFormat) {
          throw new Error(result.error || "RGB layer generation failed.");
        }

        // Remove existing layer
        if (currentLayer) {
          map.removeLayer(currentLayer);
          // Remove from layer control overlays
          if (currentLayerName) {
            delete overlays[currentLayerName];
            layerControl.removeLayer(currentLayer);
          }
          currentLayer = null;
          currentLayerName = null;
        }

        // Add RGB layer
        currentLayer = L.tileLayer(result.urlFormat, {
          minZoom: 3,
          maxZoom: 23,
        });
        currentLayer.addTo(map);

        // Add to layer control overlays
        currentLayerName = "FCC Layer";
        overlays[currentLayerName] = currentLayer;
        layerControl.addOverlay(currentLayer, currentLayerName);

        // Update the dropdown to show RGB is selected
        document.getElementById("layer").value = "rgb";
        document.getElementById("addLayerBtn").style.display = "inline-flex";

        // Show default analytics for RGB
        document.getElementById("ndvi-dashboard").style.display = "none";
        document.getElementById(
          "default-analytics-placeholder"
        ).style.display = "flex";

        // Ensure legend is hidden for RGB
        updateMapLegend("rgb", null);
      } catch (error) {
        console.error("RGB layer loading failed:", error);
        Swal.fire(
          "Info",
          "Using default satellite imagery for the area.",
          "info"
        );
      }
    }

    // Update chart styles to include new parameters
    const chartStyles = {
      ndvi: { labelKey: "opt_ndvi", color: "#2f7a2f" },
      savi: { labelKey: "opt_savi", color: "#27ae60" },
      cwsi: { labelKey: "opt_cwsi", color: "#e74c3c" },
      kc: { labelKey: "opt_kc", color: "#1f78b4" },
      etc: { labelKey: "opt_etc", color: "#f39c12", unit: " mm/day" },
      cwr: { labelKey: "opt_cwr", color: "#c0392b", unit: " mm/day" },
      irrigation_need: {
        labelKey: "opt_irrigation_need",
        color: "#8e44ad",
        unit: " mm/day",
      },
      deltas: { labelKey: "opt_deltas", color: "#6a1b9a", unit: " m/m" },
      soilmoisture_mm: {
        labelKey: "opt_soilmoisture",
        color: "#8b5cf6",
        unit: " m/m",
      },
      lst: { labelKey: "opt_lst", color: "#ff6b6b", unit: "K" },
      lai: { labelKey: "opt_lai", color: "#8e44ad" },
    };

    function hexToRgba(hex, alpha) {
      let r = 0,
        g = 0,
        b = 0;
      if (hex.length == 4) {
        r = "0x" + hex[1] + hex[1];
        g = "0x" + hex[2] + hex[2];
        b = "0x" + hex[3] + hex[3];
      } else if (hex.length == 7) {
        r = "0x" + hex[1] + hex[2];
        g = "0x" + hex[3] + hex[4];
        b = "0x" + hex[5] + hex[6];
      }
      return `rgba(${+r},${+g},${+b},${alpha})`;
    }

    // Weather data fetching function - extract from existing data
    function fetchWeatherData() {
      if (!fullChartData || fullChartData.length === 0) {
        Swal.fire(
          "Missing Data",
          'Please fetch agricultural data first (click "Fetch Data").',
          "warning"
        );
        return;
      }

      try {
        // Process existing data to extract weather information
        const weatherData = processWeatherDataFromExisting(fullChartData);
        window.weatherData = weatherData;
        renderWeatherChart();
      } catch (error) {
        console.error("Weather data processing error:", error);
        Swal.fire("Error", "Failed to process weather data", "error");
      }
    }

    // Process existing data to create monthly weather summaries
    function processWeatherDataFromExisting(data) {
      // Group data by month
      const monthlyData = {};

      data.forEach((item) => {
        const date = new Date(item.date);
        const yearMonth = `${date.getFullYear()}-${String(
          date.getMonth() + 1
        ).padStart(2, "0")}`;

        if (!monthlyData[yearMonth]) {
          monthlyData[yearMonth] = {
            year_month: yearMonth,
            temperature: [],
            humidity: [],
            precipitation: [],
            wind_speed: [],
            wind_direction: [],
            eto: [],
          };
        }

        // Temperature from LST if available
        if (item.lst !== null && item.lst !== undefined) {
          monthlyData[yearMonth].temperature.push(item.lst);
        }

        // Humidity estimation from soil moisture
        if (
          item.soilmoisture_mm !== null &&
          item.soilmoisture_mm !== undefined
        ) {
          // Estimate humidity from soil moisture (rough approximation)
          const estimatedHumidity = Math.min(
            100,
            Math.max(20, item.soilmoisture_mm * 2)
          );
          monthlyData[yearMonth].humidity.push(estimatedHumidity);
        }

        // Precipitation from effective rainfall
        if (item.effrain !== null && item.effrain !== undefined) {
          monthlyData[yearMonth].precipitation.push(item.effrain / 0.8); // Convert back to total rain
        }

        // ET0 from available data
        if (item.eto !== null && item.eto !== undefined) {
          monthlyData[yearMonth].eto.push(item.eto);
        }
      });

      // Calculate monthly averages
      const result = [];
      Object.keys(monthlyData)
        .sort()
        .forEach((month) => {
          const monthData = monthlyData[month];

          const avg = (arr) =>
            arr.length > 0
              ? arr.reduce((a, b) => a + b, 0) / arr.length
              : null;
          const min = (arr) => (arr.length > 0 ? Math.min(...arr) : null);
          const max = (arr) => (arr.length > 0 ? Math.max(...arr) : null);

          result.push({
            year_month: month,
            temperature: {
              mean: avg(monthData.temperature),
              min: min(monthData.temperature),
              max: max(monthData.temperature),
              std: 0,
            },
            humidity: {
              mean: avg(monthData.humidity),
              min: min(monthData.humidity),
              max: max(monthData.humidity),
              std: 0,
            },
            precipitation: {
              mean: avg(monthData.precipitation),
              min: min(monthData.precipitation),
              max: max(monthData.precipitation),
              std: 0,
            },
            wind_speed: {
              mean: null,
              min: null,
              max: null,
              std: 0,
            },
            wind_direction: {
              mean: null,
              std: 0,
            },
            eto: {
              mean: avg(monthData.eto),
              min: min(monthData.eto),
              max: max(monthData.eto),
              std: 0,
            },
          });
        });

      return result;
    }

    // Weather chart rendering function
    function renderWeatherChart() {
      if (!window.weatherData || window.weatherData.length === 0) {
        document.getElementById("chart-placeholder").style.display = "flex";
        document.getElementById("chart-placeholder").innerHTML =
          "<p>No weather data available for the selected period.</p>";
        return;
      }

      const selectedParam = document.getElementById(
        "weather-param-select"
      ).value;
      const paramConfig = {
        temperature: {
          label: "Temperature",
          unit: "K",
          color: "#ff6b6b",
          key: "mean",
        },
        humidity: {
          label: "Humidity",
          unit: "%",
          color: "#4ecdc4",
          key: "mean",
        },
        precipitation: {
          label: "Precipitation",
          unit: "mm",
          color: "#45b7d1",
          key: "mean",
        },
        eto: {
          label: "Evapotranspiration (ET)",
          unit: "mm",
          color: "#ff9ff3",
          key: "mean",
        },
      };

      const config = paramConfig[selectedParam];
      if (!config) return;

      if (chart) chart.destroy();

      // Prefer landsat_acquisition_date for x-axis
      const labels = fullChartData.map(
        (d) => d.landsat_acquisition_date || d.date
      );
      const data = window.weatherData.map((d) => {
        const value = d[selectedParam]?.[config.key];
        return value !== null && value !== undefined ? value : null;
      });

      const numericData = data.filter((d) => d !== null);
      if (numericData.length === 0) {
        document.getElementById("chart-placeholder").style.display = "flex";
        document.getElementById(
          "chart-placeholder"
        ).innerHTML = `<p>No ${config.label} data available for the selected period.</p>`;
        return;
      }

      document.getElementById("chart-placeholder").style.display = "none";

      const minVal = Math.min(...numericData).toFixed(2);
      const maxVal = Math.max(...numericData).toFixed(2);

      chart = new Chart(document.getElementById("timeseriesChart"), {
        type: "line",
        data: {
          labels: labels,
          datasets: [
            {
              label: `${config.label} (${config.unit})`,
              data: data,
              borderColor: config.color,
              backgroundColor: hexToRgba(config.color, 0.1),
              borderWidth: 2,
              fill: true,
              tension: 0.4,
              pointBackgroundColor: config.color,
              pointBorderColor: config.color,
              pointRadius: 4,
              pointHoverRadius: 6,
            },
          ],
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          layout: {
            padding: {
              left: 10,
              right: 10,
              top: 10,
              bottom: 10
            }
          },
          plugins: {
            title: {
              display: true,
              text: `${config.label} - Monthly Average (${config.unit})`,
              font: { size: 14, weight: "bold" },
            },
            legend: {
              display: true,
              position: "top",
            },
          },
          scales: {
            x: {
              title: {
                display: true,
                text: "Month",
              },
            },
            y: {
              title: {
                display: true,
                text: `${config.label} (${config.unit})`,
              },
            },
          },
          interaction: {
            intersect: false,
            mode: "index",
          },
        },
      });

      updateChartTheme();
    }

    // Add event listener for weather parameter dropdown
    document
      .getElementById("weather-param-select")
      .addEventListener("change", () => {
        if (window.weatherData) {
          renderWeatherChart();
        }
      });

    function renderSingleChart(param) {
      if (!fullChartData) return;
      if (chart) chart.destroy();

      // Map parameter names to actual data keys
      const paramKeyMap = {
        'soilmoisture_mm': 'soilmoisture_mm',
        'deltas': 'deltas_mm',
        'etc': 'etc',
        'cwr': 'cwr',
        'irrigation_need': 'irrigation_need'
      };

      const dataKey = paramKeyMap[param] || param;

      const style = chartStyles[param];
      const styleLabel = style && style.labelKey ? t(style.labelKey) : style?.label || param;
      const labels = fullChartData.map((d) => d.date);
      const data = fullChartData.map((d) => d[dataKey] ?? null);

      const numericData = data.filter((d) => d !== null);
      if (numericData.length === 0) {
        document.getElementById("chart-placeholder").style.display = "flex";
        document.getElementById(
          "chart-placeholder"
        ).innerHTML = `<p>No ${style.label} data available for the selected period.</p>`;
        return;
      }

      document.getElementById("chart-placeholder").style.display = "none";

      const minVal = Math.min(...numericData).toFixed(2);
      const maxVal = Math.max(...numericData).toFixed(2);

      const startDate = new Date(labels[0]).toLocaleDateString("en-GB", {
        day: "2-digit",
        month: "short",
        year: "numeric",
      });
      const endDate = new Date(labels[labels.length - 1]).toLocaleDateString(
        "en-GB",
        { day: "2-digit", month: "short", year: "numeric" }
      );

      const ctx = document.getElementById("timeseriesChart").getContext("2d");

      // For LST, use different styling
      const isLST = param === "lst";

      // Create gradient for ALL charts including LST (but with different opacity)
      let gradient;
      if (isLST) {
        // LST gradient - lighter red with very low opacity
        gradient = ctx.createLinearGradient(0, 0, 0, 250);
        gradient.addColorStop(0, hexToRgba(style.color, 0.15)); // Very light red
        gradient.addColorStop(1, hexToRgba(style.color, 0.02)); // Almost transparent
      } else {
        // Regular gradient for other parameters
        gradient = ctx.createLinearGradient(0, 0, 0, 250);
        gradient.addColorStop(0, hexToRgba(style.color, 0.3));
        gradient.addColorStop(1, hexToRgba(style.color, 0));
      }

      // Consistent styling for ALL parameters
      const datasets = [
        {
          label: style.label,
          data: data,
          borderColor: style.color,
          backgroundColor: gradient, // Use gradient for ALL including LST
          tension: 0.3,
          fill: true, // Fill for ALL including LST (but with very light fill for LST)
          pointRadius: 4,
          pointBackgroundColor: "#fff", // White background for all points
          pointBorderColor: style.color, // Border color matches line color
          pointBorderWidth: 2,
          pointHoverRadius: 6,
          pointHoverBackgroundColor: "#fff",
          pointHoverBorderColor: style.color,
          pointHoverBorderWidth: 3,
          borderWidth: 2, // Consistent line thickness
          spanGaps: true, // Connect points across null/missing values
          segment: {
            borderColor: (ctx) => style.color, // Consistent color
          },
        },
      ];

      chart = new Chart(ctx, {
        type: "line",
        data: {
          labels,
          datasets: datasets,
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          layout: {
            padding: {
              left: 15,
              right: 15,
              top: 10,
              bottom: 15
            }
          },
          interaction: { intersect: false, mode: "index" },
          plugins: {
            legend: { display: false },
            title: {
              display: true,
              text: `Daily ${styleLabel} (${startDate} - ${endDate})`,
              font: { size: 16, family: "Inter", weight: "bold" },
            },
            subtitle: {
              display: true,
              text: `Min: ${minVal}${style.unit || ""} | Max: ${maxVal}${style.unit || ""
                }`,
              font: { size: 12 },
              color: "#666",
              padding: { bottom: 10 },
            },
            tooltip: {
              mode: "index",
              intersect: false,
              backgroundColor: "rgba(0, 0, 0, 0.8)",
              titleColor: "#fff",
              bodyColor: "#fff",
              borderColor: style.color,
              borderWidth: 1,
              callbacks: {
                title: function (context) {
                  return new Date(context[0].label).toLocaleDateString(
                    "en-GB",
                    {
                      weekday: "long",
                      year: "numeric",
                      month: "long",
                      day: "numeric",
                    }
                  );
                },
                label: function (context) {
                  const value = context.parsed.y;
                  if (value === null) return `${style.label}: No data`;
                  const unit = style.unit || "";
                  return `${styleLabel}: ${value.toFixed(
                    isLST ? 1 : 3
                  )}${unit}`;
                },
              },
            },
          },
          scales: {
            x: {
              grid: { display: false },
              ticks: {
                maxTicksLimit: 8,
                color: function () {
                  return document.body.classList.contains("dark-mode")
                    ? "#e8e6e3"
                    : "#666";
                },
                callback: function (value, index, ticks) {
                  const date = new Date(this.getLabelForValue(value));
                  return date.toLocaleDateString("en-GB", {
                    day: "2-digit",
                    month: "short",
                  });
                },
              },
            },
            y: {
              beginAtZero: false,
              grid: {
                drawBorder: false,
                color: function () {
                  return document.body.classList.contains("dark-mode")
                    ? "rgba(255, 255, 255, 0.1)"
                    : "rgba(0, 0, 0, 0.1)";
                },
              },
              ticks: {
                color: function () {
                  return document.body.classList.contains("dark-mode")
                    ? "#e8e6e3"
                    : "#666";
                },
                callback: function (value) {
                  if (value === null) return "No data";
                  return value.toFixed(isLST ? 1 : 2) + (style.unit || "");
                },
              },
            },
          },
          elements: {
            point: {
              hoverBorderWidth: 3,
              radius: function (context) {
                const index = context.dataIndex;
                const value = context.dataset.data[index];
                return value !== null ? 4 : 0;
              },
            },
            line: {
              borderWidth: 2, // Consistent with other graphs
              tension: 0.3,
              capBezierPoints: true,
            },
          },
        },
      });
      updateChartTheme();
    }

    function calculateAverages(data) {
      const sums = {};
      const counts = {};
      const params = Object.keys(chartStyles);
      params.forEach((p) => {
        sums[p] = 0;
        counts[p] = 0;
      });

      data.forEach((row) => {
        params.forEach((p) => {
          if (row[p] !== null && typeof row[p] === "number") {
            sums[p] += row[p];
            counts[p]++;
          }
        });
      });

      const averages = {};
      params.forEach((p) => {
        averages[p] = counts[p] > 0 ? sums[p] / counts[p] : 0;
      });
      return averages;
    }

    // Function to calculate comprehensive statistics from chart data
    function calculateStatsFromChartData(data, param) {
      if (!data || !Array.isArray(data)) return null;

      const values = data
        .map((d) => d[param])
        .filter((v) => v !== null && v !== undefined && !isNaN(v));

      if (values.length === 0) return null;

      // Sort values for percentile calculation
      const sortedValues = [...values].sort((a, b) => a - b);

      const mean = values.reduce((a, b) => a + b, 0) / values.length;
      const min = Math.min(...values);
      const max = Math.max(...values);
      const median =
        sortedValues.length % 2 === 0
          ? (sortedValues[sortedValues.length / 2 - 1] +
            sortedValues[sortedValues.length / 2]) /
          2
          : sortedValues[Math.floor(sortedValues.length / 2)];

      // Calculate standard deviation
      const variance =
        values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) /
        values.length;
      const stdDev = Math.sqrt(variance);

      // Calculate percentiles
      const percentile = (arr, p) => {
        if (arr.length === 0) return null;
        const index = (p / 100) * (arr.length - 1);
        const lower = Math.floor(index);
        const upper = Math.ceil(index);
        const weight = index - lower;
        return arr[lower] * (1 - weight) + arr[upper] * weight;
      };

      return {
        mean: mean,
        min: min,
        max: max,
        median: median,
        stdDev: stdDev,
        p10: percentile(sortedValues, 10),
        p25: percentile(sortedValues, 25),
        p75: percentile(sortedValues, 75),
        p90: percentile(sortedValues, 90),
      };
    }

    let lastAverageParam = null;

    const gaugeNeedle = {
      id: "gaugeNeedle",
      afterDraw(chart) {
        const {
          ctx,
          data,
          chartArea: { left, right, top, bottom, width, height },
        } = chart;
        ctx.save();
        const value = data.datasets[0].data[0];
        const unit = chart.options.plugins.unit || "";
        const decimals = chart.options.plugins.decimals || 2;
        const text = value.toFixed(decimals) + unit;
        ctx.font = "bold 32px Inter";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        const isDark = document.body.classList.contains("dark-mode");
        ctx.fillStyle = isDark ? "#e8e6e3" : "#333";
        ctx.fillText(text, width / 2, height * 0.85);
        ctx.restore();
      },
    };

    // Function to show average of a specific parameter in graphical form
    function showParameterAverage(param) {
      if (!fullChartData) return;

      const style = chartStyles[param];
      const styleLabel =
        style && style.labelKey ? t(style.labelKey) : style?.label || param;
      lastAverageParam = param;
      if (!style) return;

      // Calculate average
      const values = fullChartData
        .map((d) => d[param])
        .filter((v) => v !== null && v !== undefined && !isNaN(v));

      if (values.length === 0) {
        // No data available
        document.getElementById("ndvi-dashboard").style.display = "none";
        document.getElementById(
          "default-analytics-placeholder"
        ).style.display = "flex";
        document.querySelector(
          "#default-analytics-placeholder h3"
        ).textContent = t("no_data_available");
        return;
      }

      const average = values.reduce((a, b) => a + b, 0) / values.length;

      // Hide detailed stats panel
      document.getElementById("ndvi-dashboard").style.display = "none";

      // Show analytics placeholder
      const placeholder = document.getElementById(
        "default-analytics-placeholder"
      );
      placeholder.style.display = "flex";

      // Update title
      // const title = placeholder.querySelector("h3");
      // if (title) {
      //   title.textContent = `${t('opt_average')} ${styleLabel}`;
      // }

      // Destroy existing charts
      if (gaugeChart) gaugeChart.destroy();
      if (barChart) barChart.destroy();

      // Calculate max value for gauge normalization
      // For NDVI, use 0-1 range; for others, use max value with padding
      let maxValue, normalizedValue;
      if (param === "ndvi") {
        maxValue = 1;
        normalizedValue = Math.min(average, 1);
      } else {
        maxValue = Math.max(...values) * 1.2 || 1;
        normalizedValue = Math.min(average / maxValue, 1);
      }

      // Create gauge chart for the selected parameter
      const gaugeCtx = document.getElementById("gaugeChart").getContext("2d");
      gaugeChart = new Chart(gaugeCtx, {
        type: "doughnut",
        data: {
          datasets: [
            {
              data: [normalizedValue, 1 - normalizedValue],
              backgroundColor: [style.color, "#e9ecef"],
              borderColor: [style.color, "#e9ecef"],
              circumference: 180,
              rotation: 270,
            },
          ],
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            title: {
              display: true,
              text: `${t("opt_average")} ${styleLabel}`,
              font: { size: 16, weight: "bold" },
            },
            tooltip: { enabled: false },
            unit: style.unit || "",
            decimals: param === "lst" ? 1 : 2,
            displayValue: average, // Store actual value for display
          },
          cutout: "70%",
        },
        plugins: [
          {
            id: "gaugeNeedle",
            afterDraw(chart) {
              const {
                ctx,
                chartArea: { left, right, top, bottom, width, height },
              } = chart;
              ctx.save();
              const displayValue = chart.options.plugins.displayValue || 0;
              const unit = chart.options.plugins.unit || "";
              const decimals = chart.options.plugins.decimals || 2;
              const text = displayValue.toFixed(decimals) + unit;
              ctx.font = "bold 32px Inter";
              ctx.textAlign = "center";
              ctx.textBaseline = "middle";
              const isDark = document.body.classList.contains("dark-mode");
              ctx.fillStyle = isDark ? "#e8e6e3" : "#333";
              ctx.fillText(text, width / 2, height * 0.85);
              ctx.restore();
            },
          },
        ],
      });

      // Create a simple bar chart showing just this parameter's average
      const barCtx = document.getElementById("barChart").getContext("2d");
      barChart = new Chart(barCtx, {
        type: "bar",
        data: {
          labels: [styleLabel],
          datasets: [
            {
              label: t("opt_average"),
              data: [average],
              backgroundColor: style.color,
              borderRadius: 8,
            },
          ],
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          indexAxis: "y",
          plugins: {
            legend: { display: false },
            title: {
              display: true,
              text: `${t("opt_average")}: ${average.toFixed(
                param === "lst" ? 1 : 2
              )}${style.unit || ""}`,
              font: { size: 14 },
            },
            tooltip: {
              callbacks: {
                label: function (context) {
                  return `${styleLabel}: ${context.parsed.x.toFixed(
                    param === "lst" ? 1 : 2
                  )}${style.unit || ""}`;
                },
              },
            },
          },
          scales: {
            x: {
              grid: { display: false },
              ticks: {
                callback: function (value) {
                  return (
                    value.toFixed(param === "lst" ? 1 : 2) +
                    (style.unit || "")
                  );
                },
              },
            },
            y: {
              grid: { display: false },
            },
          },
        },
      });

      // Ensure right panel is open
      ensureRightPanelOpen();
      updateChartTheme();
    }

    function renderAnalyticsCharts() {
      if (!fullChartData) return;

      const averages = calculateAverages(fullChartData);

      if (gaugeChart) gaugeChart.destroy();
      const avgNdvi = averages.ndvi;
      const gaugeCtx = document.getElementById("gaugeChart").getContext("2d");
      gaugeChart = new Chart(gaugeCtx, {
        type: "doughnut",
        data: {
          datasets: [
            {
              data: [avgNdvi, 1 - avgNdvi],
              backgroundColor: [chartStyles.ndvi.color, "#e9ecef"],
              borderColor: [chartStyles.ndvi.color, "#e9ecef"],
              circumference: 180,
              rotation: 270,
            },
          ],
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            title: {
              display: true,
              text: `${t("opt_average")} ${t("opt_ndvi")}`,
            },
            tooltip: { enabled: false },
          },
          cutout: "70%",
        },
        plugins: [gaugeNeedle],
      });

      if (barChart) barChart.destroy();
      const barCtx = document.getElementById("barChart").getContext("2d");
      barChart = new Chart(barCtx, {
        type: "bar",
        data: {
          labels: Object.values(chartStyles).map((s) =>
            s.labelKey ? t(s.labelKey) : s.label
          ),
          datasets: [
            {
              label: t("opt_average"),
              data: Object.keys(chartStyles).map((p) =>
                averages[p].toFixed(2)
              ),
              backgroundColor: Object.values(chartStyles).map((s) => s.color),
              borderRadius: 4,
            },
          ],
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          indexAxis: "y",
          plugins: {
            legend: { display: false },
            title: { display: true, text: t("param_averages") },
            tooltip: { enabled: true },
          },
          scales: { x: { grid: { display: false } } },
        },
      });
      updateChartTheme();
    }

    document.querySelectorAll(".chart-tab-btn").forEach((button) => {
      button.addEventListener("click", () => {
        const param = button.dataset.param;
        document
          .querySelectorAll(".chart-tab-btn")
          .forEach((btn) => btn.classList.remove("active"));
        button.classList.add("active");

        // Show/hide weather parameter dropdown
        const weatherDropdown = document.getElementById(
          "weather-parameter-dropdown"
        );
        if (param === "weather") {
          weatherDropdown.style.display = "block";
          // Fetch weather data if not already loaded
          if (!window.weatherData) {
            fetchWeatherData();
          } else {
            renderWeatherChart();
          }
        } else {
          weatherDropdown.style.display = "none";
          renderSingleChart(param);

          // Show only the average of this parameter in graphical form
          showParameterAverage(param);
        }
      });
    });

    // Dark mode functionality
    const darkModeToggle = document.getElementById("darkModeToggle");
    const body = document.body;
    const themeIcon = darkModeToggle.querySelector("i");

    function setDarkTheme(isDark) {
      body.classList.toggle("dark-mode", isDark);
      themeIcon.classList.toggle("fa-moon", !isDark);
      themeIcon.classList.toggle("fa-sun", isDark);
      localStorage.setItem("theme", isDark ? "dark-mode" : "light-mode");
      updateChartTheme();
    }

    darkModeToggle.addEventListener("click", () => {
      setDarkTheme(!body.classList.contains("dark-mode"));
    });

    function setupNDVITabs() {
      const tabButtons = document.querySelectorAll(".ndvi-tab-btn");
      const tabContents = document.querySelectorAll(".ndvi-tab-content");

      tabButtons.forEach((button) => {
        button.addEventListener("click", () => {
          const targetTab = button.dataset.tab;
          tabButtons.forEach((btn) => btn.classList.remove("active"));
          button.classList.add("active");
          tabContents.forEach((content) => {
            content.classList.toggle(
              "active",
              content.id === `${targetTab}-tab`
            );
          });
        });
      });
    }
    setupNDVITabs();

    function updateChartTheme() {
      const isDark = body.classList.contains("dark-mode");
      const textColor = isDark ? "#e8e6e3" : "#666";
      const gridColor = isDark
        ? "rgba(255, 255, 255, 0.1)"
        : "rgba(0, 0, 0, 0.1)";
      const titleColor = isDark ? "#e8e6e3" : "#333";

      [
        chart,
        gaugeChart,
        barChart,
        ndviComparisonChart,
        landCoverChart,
      ].forEach((c) => {
        if (c) {
          if (c.options.plugins.title)
            c.options.plugins.title.color = titleColor;
          if (c.options.plugins.subtitle)
            c.options.plugins.subtitle.color = textColor;

          // Update scales colors
          if (c.options.scales) {
            if (c.options.scales.x) {
              c.options.scales.x.ticks.color = textColor;
              c.options.scales.x.grid.color = gridColor;
            }
            if (c.options.scales.y) {
              c.options.scales.y.ticks.color = textColor;
              c.options.scales.y.grid.color = gridColor;
            }
          }

          c.update();
        }
      });
    }
    setDarkTheme(localStorage.getItem("theme") === "dark-mode");

    // Function to update Soil Moisture statistics panel
    function updateSoilMoistureStatsPanel(stats) {
      const dashboard = document.getElementById("ndvi-dashboard");
      const placeholder = document.getElementById(
        "default-analytics-placeholder"
      );

      // In your fetchData function, update the data availability checks:
      const hasSoilMoisture = data.some(
        (d) =>
          d.soilmoisture_mm !== null &&
          d.soilmoisture_mm !== undefined &&
          d.soilmoisture_mm > 0
      );
      const hasCWR = data.some(
        (d) => d.cwr !== null && d.cwr !== undefined && d.cwr > 0
      );
      const hasDeltaS = data.some(
        (d) => d.deltas !== null && d.deltas !== undefined
      );

      console.log(
        "Data availability - Soil Moisture:",
        hasSoilMoisture,
        "CWR:",
        hasCWR,
        "DeltaS:",
        hasDeltaS
      );

      // Removed SweetAlert for missing data as requested

      // Rest of your existing soil moisture panel code...
      dashboard.style.display = "flex";
      placeholder.style.display = "none";

      // Ensure right panel is open when showing stats
      ensureRightPanelOpen();

      // Update the dashboard title for Soil Moisture
      document.querySelector("#ndvi-dashboard h3").innerHTML = `
        <i class="fa-solid fa-seedling" style="color: #8b5cf6;"></i>
        Soil Moisture Statistics
    `;

      // Update tabs content for soil moisture data
      const mean = stats.mean !== undefined ? Number(stats.mean) : null;
      const min = stats.min !== undefined ? Number(stats.min) : null;
      const max = stats.max !== undefined ? Number(stats.max) : null;
      const stdDev = stats.stdDev !== undefined ? Number(stats.stdDev) : null;
      const median = stats.median !== undefined ? Number(stats.median) : null;
      const p25 = stats.p25 !== undefined ? Number(stats.p25) : null;
      const p75 = stats.p75 !== undefined ? Number(stats.p75) : null;

      // Update overview tab
      document.getElementById("overview-mean-value").textContent =
        mean !== null ? mean.toFixed(1) + " m/m" : "--";
      document.getElementById("overview-median-value").textContent =
        median !== null ? median.toFixed(1) + " m/m" : "--";
      document.getElementById("overview-p25-value").textContent =
        p25 !== null ? p25.toFixed(1) + " m/m" : "--";
      document.getElementById("overview-p75-value").textContent =
        p75 !== null ? p25.toFixed(1) + " m/m" : "--";

      // Update progress bars for soil moisture
      const soilRange = min !== null && max !== null ? max - min : 100; // Default range for soil moisture
      const getSoilWidthPercent = (val) => {
        if (val === null || min === null || soilRange <= 0) return "0%";
        return `${Math.max(
          0,
          Math.min(100, ((val - min) / soilRange) * 100)
        )}%`;
      };

      document.getElementById("overview-mean-bar").style.width =
        getSoilWidthPercent(mean);
      document.getElementById("overview-mean-bar").style.backgroundColor =
        "#8b5cf6";

      ["1", "2", "3", "4"].forEach((i) => {
        document.getElementById(`overview-min${i}`).textContent =
          min !== null ? `Min: ${min.toFixed(1)} mm` : "Min: --";
        document.getElementById(`overview-max${i}`).textContent =
          max !== null ? `Max: ${max.toFixed(1)} mm` : "Max: --";
      });

      // Update health card for soil moisture
      let soilStatus, soilEmoji, soilBgColor, soilAdvice;
      if (mean !== null) {
        if (mean < 20) {
          soilStatus = `<span data-i18n="very_dry_soil">Very Dry Soil</span>`;
          soilEmoji = "";
          soilBgColor = "#ff6b6b";
          soilAdvice = `<span data-i18n="advice_very_dry">Critical soil moisture. Immediate irrigation required.</span>`;
        } else if (mean < 40) {
          soilStatus = `<span data-i18n="dry_soil">Dry Soil</span>`;
          soilEmoji = "";
          soilBgColor = "#ffd43b";
          soilAdvice = `<span data-i18n="advice_dry">Soil is dry. Consider irrigation planning.</span>`;
        } else if (mean < 60) {
          soilStatus = `<span data-i18n="moderate_moisture">Moderate Moisture</span>`;
          soilEmoji = "";
          soilBgColor = "#51cf66";
          soilAdvice = `<span data-i18n="advice_moderate">Good soil moisture. Maintain current practices.</span>`;
        } else if (mean < 80) {
          soilStatus = `<span data-i18n="well_hydrated">Well Hydrated</span>`;
          soilEmoji = "";
          soilBgColor = "#4dabf7";
          soilAdvice = `<span data-i18n="advice_hydrated">Excellent soil moisture. Optimal for plant growth.</span>`;
        } else {
          soilStatus = `<span data-i18n="saturated_soil">Saturated Soil</span>`;
          soilEmoji = "";
          soilBgColor = "#1e88e5";
          soilAdvice = `<span data-i18n="advice_saturated">Soil is saturated. Risk of waterlogging.</span>`;
        }
      } else {
        soilStatus = `<span data-i18n="no_data">--</span>`;
        soilEmoji = "";
        soilBgColor = "#95a5a6";
        soilAdvice = `<span data-i18n="advice_no_data">Data unavailable for analysis.</span>`;
      }

      document.getElementById("health-emoji").textContent = soilEmoji;
      document.getElementById("health-status-text").innerHTML = soilStatus;
      document.getElementById("overall-health-card").style.backgroundColor =
        soilBgColor;
      document.getElementById("health-summary").textContent = `Average: ${mean !== null ? mean.toFixed(1) + " m/m" : "--"
        } | Range: ${min !== null && max !== null
          ? (max - min).toFixed(1) + " m/m"
          : "--"
        } | ${soilAdvice}`;

      // Update detailed tab
      document.getElementById("detailed-mean").textContent =
        mean !== null ? mean.toFixed(1) + " m/m" : "--";
      document.getElementById("detailed-median").textContent =
        median !== null ? median.toFixed(1) + " m/m" : "--";
      document.getElementById("detailed-stddev").textContent =
        stdDev !== null ? stdDev.toFixed(1) + " m/m" : "--";
      document.getElementById("detailed-min").textContent =
        min !== null ? min.toFixed(1) + " m/m" : "--";
      document.getElementById("detailed-max").textContent =
        max !== null ? max.toFixed(1) + " m/m" : "--";
      document.getElementById("detailed-range").textContent =
        min !== null && max !== null
          ? (max - min).toFixed(1) + " m/m"
          : "--";

      // Show percentile sections for soil moisture
      document.querySelectorAll(".percentiles-dist-section").forEach((el) => {
        el.style.display = "block";
      });

      // Update visual tab
      if (ndviComparisonChart) ndviComparisonChart.destroy();
      const visualCtx = document
        .getElementById("ndviComparisonChart")
        .getContext("2d");
      const chartData = [min, p25, median, mean, p75, max].filter(
        (v) => v !== null
      );
      const labels = ["Min", "P25", "Median", "Mean", "P75", "Max"].filter(
        (_, i) => [min, p25, median, mean, p75, max][i] !== null
      );

      // Color coding based on soil moisture levels
      const backgroundColors = chartData.map((value) => {
        if (value < 20) return "#ff6b6b"; // Very Dry - Red
        else if (value < 40) return "#ffd43b"; // Dry - Yellow
        else if (value < 60) return "#51cf66"; // Moderate - Green
        else if (value < 80) return "#4dabf7"; // Well Hydrated - Blue
        else return "#1e88e5"; // Saturated - Dark Blue
      });

      ndviComparisonChart = new Chart(visualCtx, {
        type: "bar",
        data: {
          labels: labels,
          datasets: [
            {
              label: "Soil Moisture (m/m)",
              data: chartData,
              backgroundColor: backgroundColors,
              borderRadius: 4,
            },
          ],
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { display: false },
            title: {
              display: true,
              text: "Soil Moisture Analysis",
              font: { size: 14 },
            },
          },
          scales: {
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: "Soil Moisture (m/m)",
              },
            },
          },
        },
      });

      updateChartTheme();
    }

    // Export functionality
    function exportChartAsImage() {
      if (!chart) {
        Swal.fire(
          "No chart to export",
          "Please generate a chart first.",
          "warning"
        );
        return;
      }
      const a = document.createElement("a");
      a.href = chart.toBase64Image();
      a.download = `krishi-${chart.data.datasets[0].label}.png`;
      a.click();
    }

    function exportChartAsPDF() {
      if (!chart || !chart.canvas) {
        Swal.fire({
          icon: "warning",
          title: "No Chart to Export",
          text: "Please generate a chart first!",
          confirmButtonColor: "var(--krishi-green)",
        });
        return;
      }
      const { jsPDF } = window.jspdf || {};
      if (!jsPDF) {
        Swal.fire("Error", "The PDF library is not available.", "error");
        return;
      }
      try {
        const pdf = new jsPDF({
          orientation: "landscape",
          unit: "pt",
          format: "a4",
        });
        const canvasImage = chart.canvas.toDataURL("image/png", 1.0);
        const pageWidth = pdf.internal.pageSize.getWidth();
        const pageHeight = pdf.internal.pageSize.getHeight();
        const margin = 40;
        pdf.setFontSize(18);
        pdf.setTextColor(30, 30, 30);
        pdf.text(chart.options.plugins.title.text, margin, margin + 10);
        const chartWidth = pageWidth - margin * 2;
        const chartHeight =
          (chart.canvas.height / chart.canvas.width) * chartWidth;
        const chartY = margin + 30;
        pdf.addImage(
          canvasImage,
          "PNG",
          margin,
          chartY,
          chartWidth,
          chartHeight
        );
        const footerY = pageHeight - margin;
        // pdf.addImage(logoBase64, 'PNG', margin, footerY - 20, 20, 20); // Uncomment if you have a logo
        pdf.setFontSize(10);
        pdf.setTextColor(150, 150, 150);
        pdf.text("Powered by TerrAqua UAV", margin + 30, footerY);
        pdf.setFontSize(12);
        pdf.setTextColor(80, 80, 80);
        pdf.text("KrishiZest", pageWidth - margin, footerY, {
          align: "right",
        });
        pdf.save(`KrishiZest_${chart.data.datasets[0].label}.pdf`);
      } catch (error) {
        console.error("PDF Export Error:", error);
        Swal.fire({
          icon: "error",
          title: t("opt_oops"),
          text: t("opt_something_wrong"),
        });
      }
    }

    async function exportAICropReportPDF() {
      try {
        if (!drawnAOI) {
          Swal.fire({
            icon: "warning",
            title: "Draw AOI",
            text: "Please draw a field boundary first.",
          });
          return;
        }
        const startEl = document.getElementById("start");
        const endEl = document.getElementById("end");
        const start_date = startEl?.value;
        const end_date = endEl?.value;
        if (!start_date || !end_date) {
          Swal.fire({
            icon: "warning",
            title: "Select Dates",
            text: "Please select start and end dates.",
          });
          return;
        }

        Swal.showLoading();
        const res = await fetch("/ai/crop_report", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            aoi: drawnAOI.toGeoJSON(),
            start_date,
            end_date,
          }),
        });
        const data = await res.json();
        Swal.close();
        if (!res.ok || !data.success) {
          throw new Error(data.error || "Failed to generate report");
        }

        const { jsPDF } = window.jspdf || {};
        if (!jsPDF) {
          Swal.fire("Error", "The PDF library is not available.", "error");
          return;
        }

        const pdf = new jsPDF({
          orientation: "portrait",
          unit: "pt",
          format: "a4",
        });
        const pageWidth = pdf.internal.pageSize.getWidth();
        const margin = 48;

        // Cover
        pdf.setFontSize(18);
        pdf.text("AI Crop Report", margin, 90);
        pdf.setFontSize(12);
        pdf.text(
          `Date Range: ${data.start_date} to ${data.end_date}`,
          margin,
          120
        );
        pdf.text(`Area: ${data.area_ha} ha`, margin, 138);
        pdf.text(`Crop: ${data.crop_name}`, margin, 156);
        pdf.setFontSize(10);
        pdf.setTextColor(150, 150, 150);
        pdf.text("Powered by KrishiZest", margin, 780);

        // Analysis page
        pdf.addPage();
        pdf.setTextColor(0, 0, 0);
        pdf.setFontSize(14);
        pdf.text("Agronomist Summary", margin, 80);
        pdf.setFontSize(11);
        const analysisLines = pdf.splitTextToSize(
          data.analysis_text || "",
          pageWidth - margin * 2
        );
        pdf.text(analysisLines, margin, 110);

        // Metrics page
        pdf.addPage();
        pdf.setFontSize(14);
        pdf.text("Key Metrics", margin, 80);
        pdf.setFontSize(11);
        const m = data.metrics || {};
        const entries = [
          ["NDVI (mean/min/max)", m.ndvi],
          ["ET0 mm (mean/min/max)", m.eto_mm],
          ["Eff. Rain mm (mean/min/max)", m.eff_rain_mm],
          ["S mm (mean/min/max)", m.deltas_mm],
          ["Soil Moisture mm (mean/min/max)", m.soil_moisture_mm],
          ["ETc mm (mean/min/max)", m.etc_mm],
          ["CWR mm (mean/min/max)", m.cwr_mm],
          ["LST C (mean/min/max)", m.lst_c],
        ];
        let y = 110;
        entries.forEach(([label, obj]) => {
          const text = obj
            ? `${label}: ${obj.mean ?? "-"} / ${obj.min ?? "-"} / ${obj.max ?? "-"
            }`
            : `${label}: -`;
          pdf.text(text, margin, y);
          y += 20;
        });

        // Charts page (capture existing main chart if available)
        if (window.chart && window.chart.canvas) {
          pdf.addPage();
          pdf.setFontSize(14);
          pdf.text("Time Series Chart", margin, 80);
          const img = window.chart.canvas.toDataURL("image/png", 1.0);
          const chartWidth = pageWidth - margin * 2;
          const chartHeight =
            (window.chart.canvas.height / window.chart.canvas.width) *
            chartWidth;
          pdf.addImage(img, "PNG", margin, 100, chartWidth, chartHeight);
        }

        pdf.save(`AI_Crop_Report_${data.start_date}_to_${data.end_date}.pdf`);
      } catch (err) {
        console.error(err);
        Swal.close();
        Swal.fire({
          icon: "error",
          title: "Report Failed",
          text: err.message || "Could not generate report.",
        });
      }
    }

    // Function to cycle through different crop/leaf icons
    let cropLoaderInterval = null;
    const cropIcons = [
      "fa-seedling",
      "fa-leaf",
      "fa-wheat-awn",
      "fa-tree",
      "fa-spa",
      "fa-seedling",
    ];

    function startCropLoaderAnimation() {
      const iconElement = document.querySelector(".crop-loader-icon i");
      let iconIndex = 0;

      // Change icon every 1.5 seconds
      cropLoaderInterval = setInterval(() => {
        iconIndex = (iconIndex + 1) % cropIcons.length;
        iconElement.className = `fas ${cropIcons[iconIndex]}`;
      }, 1500);
    }

    function stopCropLoaderAnimation() {
      if (cropLoaderInterval) {
        clearInterval(cropLoaderInterval);
        cropLoaderInterval = null;
      }
      // Reset to first icon
      const iconElement = document.querySelector(".crop-loader-icon i");
      if (iconElement) {
        iconElement.className = `fas ${cropIcons[0]}`;
      }
    }

    // Replace your existing generateReportPDF function with this enhanced version

    async function generateReportPDF() {
      try {
        if (!drawnAOI) {
          Swal.fire({
            icon: "warning",
            title: "Draw AOI",
            text: "Please draw a field boundary first.",
          });
          return;
        }

        const start_date = document.getElementById("start")?.value;
        const end_date = document.getElementById("end")?.value;

        if (!start_date || !end_date) {
          Swal.fire({
            icon: "warning",
            title: "Select Dates",
            text: "Please select start and end dates.",
          });
          return;
        }

        if (!fullChartData || fullChartData.length === 0) {
          Swal.fire({
            icon: "warning",
            title: "No Data",
            text: 'Please fetch data first by clicking "Get Data".',
          });
          return;
        }

        // Show custom crop/leaf loader and start animation
        document.getElementById("cropLoader").classList.add("show");
        startCropLoaderAnimation();

        // Calculate area in hectares
        const aoiGeojson = drawnAOI.toGeoJSON();
        const coords = aoiGeojson.geometry.coordinates[0];
        let area_m2 = 0;
        if (coords && coords.length > 2) {
          for (let i = 0; i < coords.length - 1; i++) {
            area_m2 += coords[i][0] * coords[i + 1][1];
            area_m2 -= coords[i + 1][0] * coords[i][1];
          }
          area_m2 = Math.abs(area_m2) / 2;
          area_m2 = area_m2 * 111000 * 111000;
        }
        const area_ha = area_m2 > 0 ? (area_m2 / 10000).toFixed(2) : null;

        // Calculate metrics from fullChartData
        const calculateMetrics = (data, key) => {
          const values = data
            .map((d) => d[key])
            .filter((v) => v !== null && v !== undefined && !isNaN(v));
          if (values.length === 0)
            return { mean: null, min: null, max: null };
          return {
            mean: parseFloat(
              (values.reduce((a, b) => a + b, 0) / values.length).toFixed(3)
            ),
            min: parseFloat(Math.min(...values).toFixed(3)),
            max: parseFloat(Math.max(...values).toFixed(3)),
          };
        };

        const metrics = {
          ndvi: calculateMetrics(fullChartData, "ndvi"),
          kc: calculateMetrics(fullChartData, "kc"),
          eto_mm: calculateMetrics(fullChartData, "eto"),
          eff_rain_mm: calculateMetrics(fullChartData, "effrain"),
          deltas_mm: calculateMetrics(fullChartData, "deltas_mm"),
          soil_moisture_mm: calculateMetrics(fullChartData, "soilmoisture_mm"),
          etc_mm: calculateMetrics(fullChartData, "etc"),
          cwr_mm: calculateMetrics(fullChartData, "cwr"),
          lst_c: calculateMetrics(fullChartData, "lst"),
        };

        // Prepare series (daily data)
        const series = fullChartData.map((d) => ({
          date: d.date,
          ndvi: d.ndvi,
          kc: d.kc,
          etc: d.etc,
          cwr: d.cwr,
          effrain: d.effrain,
          eto: d.eto,
          lst: d.lst,
          deltas: d.deltas_mm,
          soilmoisture_mm: d.soilmoisture_mm,
        }));

        // Get location name
        let location_text = null;
        try {
          const polygon = coords;
          const avg_lon = polygon.reduce((sum, p) => sum + p[0], 0) / polygon.length;
          const avg_lat = polygon.reduce((sum, p) => sum + p[1], 0) / polygon.length;

          const geoResponse = await fetch(
            `https://nominatim.openstreetmap.org/reverse?format=json&lat=${avg_lat}&lon=${avg_lon}`
          );

          if (geoResponse.ok) {
            const geoData = await geoResponse.json();
            const address = geoData.address;
            const parts = [
              address.city || address.town || address.village,
              address.state
            ].filter(Boolean);
            location_text = parts.join(", ") || `${avg_lat.toFixed(5)}, ${avg_lon.toFixed(5)}`;
          }
        } catch (e) {
          console.warn("Location fetch failed", e);
        }

        // Fetch land cover classification
        let landcover = null;
        try {
          const lcRes = await fetch("/get_land_cover_analysis", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              aoi: drawnAOI.toGeoJSON(),
              start_date: start_date,
              end_date: end_date,
              time_scale: "monthly",
            }),
          });
          const lcJson = await lcRes.json();
          if (lcRes.ok && lcJson?.success && lcJson?.data?.length) {
            const last = lcJson.data[lcJson.data.length - 1];
            landcover = last.percentages || null;
          }
        } catch (e) {
          console.warn("Land cover classification fetch failed", e);
        }

        // ===== FETCH IRRIGATION CALENDAR DATA =====
        let irrigation_calendar = null;
        let irrigation_summary = null;

        try {
          console.log("Fetching irrigation calendar data...");
          const irrigationRes = await fetch("/get_irrigation_calendar", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              aoi: drawnAOI.toGeoJSON(),
              start_date: start_date,
              end_date: end_date,
              rain_threshold: 2.0,
              cwsi_threshold: 0.35,
              sm_threshold: 25.0
            }),
          });

          if (irrigationRes.ok) {
            const irrigationData = await irrigationRes.json();
            if (irrigationData.success) {
              irrigation_calendar = irrigationData.calendar;
              irrigation_summary = irrigationData.summary;
              console.log("Irrigation data fetched successfully:", {
                events: irrigation_summary?.irrigation?.total_events,
                dates: irrigation_calendar?.length
              });
            }
          }
        } catch (e) {
          console.warn("Irrigation calendar fetch failed (optional):", e);
        }
        // ===== END IRRIGATION CALENDAR DATA =====

        //  DETERMINE BACKEND URL DYNAMICALLY
        const BACKEND_URL = window.location.hostname === 'localhost'
          ? 'http://localhost:5000'
          : `${window.location.protocol}//${window.location.hostname}:5000`;

        console.log("Using backend URL:", BACKEND_URL);

        // Call the generate_report endpoint with ALL data including irrigation
        const res = await fetch("/generate_report", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            language: "en",
            crop_name: "Crop",
            area_ha: area_ha ? parseFloat(area_ha) : null,
            start_date: start_date,
            end_date: end_date,
            location: location_text,
            cloud_cover: "< 20%",
            metrics: metrics,
            series: series,
            landcover: landcover,
            aoi: drawnAOI.toGeoJSON(),
            irrigation_calendar: irrigation_calendar,
            irrigation_summary: irrigation_summary,
            backend_url: BACKEND_URL,  //  ADD THIS LINE - CRITICAL!
          }),
        });

        // Hide custom loader and stop animation
        stopCropLoaderAnimation();
        document.getElementById("cropLoader").classList.remove("show");

        if (!res.ok) {
          const errorData = await res
            .json()
            .catch(() => ({ error: "Failed to generate report" }));
          throw new Error(errorData.error || "Failed to generate report");
        }

        // Download the PDF
        const blob = await res.blob();
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `Crop_Report_${start_date}_to_${end_date}.pdf`;
        document.body.appendChild(a);
        a.click();
        window.URL.revokeObjectURL(url);
        document.body.removeChild(a);

        Swal.fire({
          icon: "success",
          title: "Report Generated",
          html: `
        <p>PDF report downloaded successfully!</p>
        ${irrigation_calendar && irrigation_calendar.length > 0
              ? `<p style="color: #28a745; margin-top: 10px;">
              <i class="fa-solid fa-check-circle"></i> 
              Including ${irrigation_calendar.length} irrigation events with satellite tile layers
            </p>`
              : '<p style="color: #ffc107; margin-top: 10px;"> No irrigation data available for this period</p>'
            }
      `,
          confirmButtonColor: "var(--krishi-green)",
        });
      } catch (err) {
        console.error(err);
        stopCropLoaderAnimation();
        document.getElementById("cropLoader").classList.remove("show");
        Swal.fire({
          icon: "error",
          title: "Report Failed",
          text: err.message || "Could not generate report.",
        });
      }
    }
    async function exportAIProposalPDF() {
      try {
        if (!drawnAOI) {
          Swal.fire({
            icon: "warning",
            title: "Draw AOI",
            text: "Please draw a field boundary first.",
          });
          return;
        }
        const start_date = document.getElementById("start")?.value;
        const end_date = document.getElementById("end")?.value;
        if (!start_date || !end_date) {
          Swal.fire({
            icon: "warning",
            title: "Select Dates",
            text: "Please select start and end dates.",
          });
          return;
        }

        Swal.showLoading();
        const res = await fetch("/ai/crop_report", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            aoi: drawnAOI.toGeoJSON(),
            start_date,
            end_date,
            report_mode: "proposal",
          }),
        });
        const data = await res.json();
        Swal.close();
        if (!res.ok || !data.success)
          throw new Error(data.error || "Failed to generate proposal");

        const { jsPDF } = window.jspdf || {};
        if (!jsPDF) {
          Swal.fire("Error", "The PDF library is not available.", "error");
          return;
        }

        const pdf = new jsPDF({
          orientation: "portrait",
          unit: "pt",
          format: "a4",
        });
        const pageWidth = pdf.internal.pageSize.getWidth();
        const pageHeight = pdf.internal.pageSize.getHeight();
        const margin = 48;

        const addFooter = (p) => {
          pdf.setFontSize(9);
          pdf.setTextColor(140, 140, 140);
          pdf.text(
            `KrishiZest  ${new Date().toLocaleDateString()}`,
            margin,
            pageHeight - 24
          );
          pdf.text(`Page ${p}`, pageWidth - margin, pageHeight - 24, {
            align: "right",
          });
        };

        // Cover Page
        pdf.setFontSize(22);
        pdf.text("AI-Driven Crop Proposal Report", margin, 120);
        pdf.setFontSize(12);
        pdf.text(
          `Date Range: ${data.start_date} to ${data.end_date}`,
          margin,
          150
        );
        pdf.text(`Area: ${data.area_ha} ha`, margin, 168);
        pdf.text(`Crop: ${data.crop_name || "Crop"}`, margin, 186);
        addFooter(1);

        // TOC
        pdf.addPage();
        pdf.setFontSize(16);
        pdf.text("Table of Contents", margin, 80);
        const toc = [
          "1. Crop Profile & Climatic Requirements",
          "2. Soil Analysis & Smart Fertilizer Plan",
          "3. AI-based Yield Prediction & Risk Analysis",
          "4. Market Trends & MSP/Price Forecast",
          "5. Farming Cost vs Profit Projection",
          "6. Government Schemes & Subsidy Support",
          "7. AgriTech Tools, AI Models & Sensors",
          "8. Conclusion + Actionable Recommendations",
        ];
        pdf.setFontSize(11);
        toc.forEach((t, i) => pdf.text(`${t}`, margin, 120 + i * 18));
        addFooter(2);

        // Metrics Summary Table
        pdf.addPage();
        pdf.setFontSize(14);
        pdf.text("Key Metrics Summary", margin, 80);
        const m = data.metrics || {};
        const rows = [
          [
            "NDVI",
            m.ndvi?.mean ?? "-",
            m.ndvi?.min ?? "-",
            m.ndvi?.max ?? "-",
          ],
          [
            "ET0 (mm)",
            m.eto_mm?.mean ?? "-",
            m.eto_mm?.min ?? "-",
            m.eto_mm?.max ?? "-",
          ],
          [
            "Eff. Rain (mm)",
            m.eff_rain_mm?.mean ?? "-",
            m.eff_rain_mm?.min ?? "-",
            m.eff_rain_mm?.max ?? "-",
          ],
          [
            "S (mm)",
            m.deltas_mm?.mean ?? "-",
            m.deltas_mm?.min ?? "-",
            m.deltas_mm?.max ?? "-",
          ],
          [
            "Soil Moisture (mm)",
            m.soil_moisture_mm?.mean ?? "-",
            m.soil_moisture_mm?.min ?? "-",
            m.soil_moisture_mm?.max ?? "-",
          ],
          [
            "ETc (mm)",
            m.etc_mm?.mean ?? "-",
            m.etc_mm?.min ?? "-",
            m.etc_mm?.max ?? "-",
          ],
          [
            "CWR (mm)",
            m.cwr_mm?.mean ?? "-",
            m.cwr_mm?.min ?? "-",
            m.cwr_mm?.max ?? "-",
          ],
          [
            "LST (K)",
            m.lst_c?.mean ?? "-",
            m.lst_c?.min ?? "-",
            m.lst_c?.max ?? "-",
          ],
        ];
        if (pdf.autoTable) {
          pdf.autoTable({
            head: [["Parameter", "Mean", "Min", "Max"]],
            body: rows,
            startY: 100,
            styles: { fontSize: 10 },
            theme: "grid",
          });
        }
        addFooter(3);

        // Screenshots page: Map + Chart
        pdf.addPage();
        pdf.setFontSize(14);
        pdf.text("Visual Insights", margin, 80);
        try {
          if (window.chart && window.chart.canvas) {
            const img = window.chart.canvas.toDataURL("image/png", 1.0);
            const cw = pageWidth - margin * 2;
            const ch =
              (window.chart.canvas.height / window.chart.canvas.width) * cw;
            pdf.addImage(img, "PNG", margin, 100, cw, Math.min(ch, 260));
          }
          const mapEl = document.getElementById("map");
          if (mapEl && window.html2canvas) {
            const mapCanvas = await html2canvas(mapEl, {
              useCORS: true,
              logging: false,
              scale: 1,
            });
            const img = mapCanvas.toDataURL("image/png", 1.0);
            const cw = pageWidth - margin * 2;
            const ch = (mapCanvas.height / mapCanvas.width) * cw;
            pdf.addImage(img, "PNG", margin, 380, cw, Math.min(ch, 280));
          }
        } catch (e) { }
        addFooter(4);

        // Narrative Sections (from analysis_text)
        const narrative = (data.analysis_text || "").toString();
        const chunks = narrative.split(/\n\n+/);
        let pageNum = 5;
        for (let i = 0; i < chunks.length; i++) {
          pdf.addPage();
          pdf.setFontSize(12);
          const lines = pdf.splitTextToSize(
            chunks[i],
            pageWidth - margin * 2
          );
          pdf.text(lines, margin, 80);
          addFooter(pageNum++);
        }

        // Save
        pdf.save(
          `AI_Crop_Proposal_${data.start_date}_to_${data.end_date}.pdf`
        );
      } catch (err) {
        console.error(err);
        Swal.close();
        Swal.fire({
          icon: "error",
          title: "Report Failed",
          text: err.message || "Could not generate proposal.",
        });
      }
    }

    // Language functionality
    const i18n = {
      en: {
        param_averages: "Parameter Averages",
        no_data_available: "No Data Available",

        select_date_range: "Select Date",
        start_date_label: "Start Date",
        end_date_label: "End Date",
        fetch_data: "Get Data",
        display_layer: "Show Map Layer",
        choose_layer: "Select map layer to see",
        select_layer_placeholder: "Choose layer",
        opt_rgb: "False Colour Composite ",
        opt_ndvi: "Crop Health-1",
        opt_lst: "Temperature ",
        opt_kc: "Crop coefficient ",
        opt_etc: "Total Water Loss ",//needs modification as there is no etc in 
        opt_cwr: "Crop Water Requirement",
        opt_deltas: "Soil Moisture",
        add_layer: "Add Layer",
        upload_vector_file: "Upload Farm File",
        drag_drop_click: "Click or drag here",
        export_chart: "Download Report",
        draw_polygon_prompt:
          'Draw field on map, select dates, then click "Get Data"',
        data_analytics: "Data Report",
        clear_all_layers: "Remove All",
        map_controls: "Map Tools",
        opt_w: "Weather",

        // --- New Items Added Below ---
        opt_op: "Opacity:",
        opt_lo: "Loaded Layers:",
        opt_ex: "Export Chart",
        opt_lm: "Layer Management",
        opt_csl: "Compare Selected Layers",
        opt_cc: "Close Comparison",
        opt_wp: "Weather Parameter:",
        opt_evt: "Evapotranspiration",
        opt_rp: "Rainfall",
        opt_tmp: "Temperature",
        opt_hum: " Relative Humidity",
        opt_Draw: 'Draw a polygon, select dates, and click "Fetch Data".',
        opt_nst: "Crop Health Statistics",
        opt_overview: "Overview",
        opt_detailed: "Detailed",
        opt_visual: "Visual",
        opt_meana: "Mean (Average Health)",
        opt_median: "Median (Middle Value)",
        opt_p75: "P75 (Top 25% Health)",
        opt_p25: "P25 (Bottom 25%)",
        opt_overall_health: "Overall Crop Health Status",
        opt_vegetation_cover: "Vegetation Cover Share",
        opt_time_scale: "Time Scale:",
        opt_monthly: "Monthly",
        opt_weekly: "Weekly",
        opt_analyze: "Analyze",
        opt_select_period: "Select Period:",
        opt_water: "Water",
        opt_bare_land: "Bare Land",
        opt_builtup: "Built-up",
        opt_sparse_veg: "Sparse Veg",
        opt_full_veg: "Full Veg",
        opt_total_periods: "Total Periods:",
        opt_date_range: "Date Range:",
        opt_soilmoisture: "Soil Moisture",
        opt_search_placeholder: "Search for location...",
        opt_no_results: "No results found",
        opt_search_failed: "Search failed. Please try again.",
        opt_location_found: "Location Found",
        opt_centered_map: "Centered map on",
        opt_draw_shape_first: "Draw a shape first.",
        opt_changes_saved: "Changes saved.",
        opt_no_shape_to_save: "No shape to save.",
        opt_missing_info: "Missing Information",
        opt_draw_aoi_first:
          "Please draw an Area of Interest (AOI) on the map first.",
        opt_select_dates: "Please select start and end dates.",
        opt_no_data: "No Data",
        opt_no_land_cover:
          "No land cover data found for the selected period.",
        opt_error: "Error",
        opt_failed_analyze: "Failed to analyze land cover:",
        opt_date_range_error: "Date Range is Only Acceptable for 1 Year",
        opt_something_wrong: "Something went wrong while creating the PDF!",
        opt_oops: "Oops...",
        opt_min: "Min",
        opt_max: "Max",
        opt_mean_label: "MEAN",
        opt_median_label: "MEDIAN",
        opt_stddev: "STD DEV",
        opt_min_label: "MIN",
        opt_max_label: "MAX",
        opt_range: "RANGE",
        opt_average: "Average",
        opt_draw_polygon_title: "Draw Polygon",
        opt_draw_rectangle_title: "Draw Rectangle",
        opt_edit_shapes_title: "Edit Shapes",
        opt_save_changes_title: "Save Changes",
        opt_delete_shapes_title: "Delete Shapes",
        opt_shape_deleted: "Shape Deleted",
        opt_shape_removed_map:
          "The drawn shape has been removed from the map.",
        opt_nothing_to_delete: "Nothing to Delete",
        opt_draw_shape_to_delete: "There is no shape on the map to delete.",
        excellent_condition: "Excellent Condition (Healthy sprout/plant)",
        good_condition: "Good Condition",
        fair_condition: "Fair Condition (Wilted leaf/Average)",
        poor_condition: "Poor Condition",
        no_data: "--",
        what_does_this_mean: "What Does This Mean?",
        needs_attention: "Needs attention (< 0.3)",
        medium_health: "Medium health (0.3 - 0.5)",
        good_health: "Good health (0.5 - 0.7)",
        excellent_health: "Excellent health (> 0.7)",
        quick_tips: "Quick Tips",
        tip_mean: "shows overall crop health.",
        tip_range: "shows field uniformity.",
        tip_p90: "means good potential.",
        tip_monitor: "for issues.",
        // Temperature
        very_cool: "Very Cool",
        comfortable: "Comfortable",
        warm: "Warm",
        hot: "Hot",

        // ... existing translations
        opt_savi: "Crop Health-2 ",
        opt_cwsi: "Water Stress",
        opt_lai: "Leaf cover density",

        // Crop Coefficient
        low_kc: "Crop Coefficient",
        moderate_kc: "Moderate Crop Coefficient",
        high_kc: "High Crop Coefficient",
        very_high_kc: "Very High Crop Coefficient",
        opt_irrigation_need: "Irrigation Need",
        opt_etc: "Total Water Loss",
        generate_calendar: "Generate Irrigation Calendar",
        total_events: "Total Events",
        total_irrigation: "Total Irrigation ",
        avg_interval: "Avg. Interval (days)",
        avg_event_amount: "Avg. Event Amount",
        last_event_date: "Last Event Date",
        water_saved: "Water Saved",
        savings: "Savings",
        total_water: "Total Water",


        // Common
        no_data: "--",
        opt_irrigation_need: "Irrigation Need",
        irrigation_calendar: "Irrigation Calendar",
        generate_calendar: "Generate Irrigation Calendar",
        irrigation_schedule: "Irrigation Schedule",
        rain_label: "Rain",
        irrigation_event: "Irrigation Event",
        soil_moisture_label: "Soil Moisture",
        cwsi_label: "CWSI",
        irrigation_label: "Irrigation",
      },

      hi: {
        param_averages: " ",
        opt_irrigation_need: " ",
        opt_etc: "    (ETc)",
        no_data_available: "   ",

        select_date_range: " ",
        start_date_label: " ",
        end_date_label: " ",
        fetch_data: " ",
        display_layer: "   ",
        choose_layer: "    ",
        select_layer_placeholder: " ",
        opt_rgb: "   ",
        opt_ndvi: " ",
        opt_lst: " ",
        opt_kc: "    ",
        opt_etc: "   ",
        opt_cwr: "  ",
        opt_deltas: "  ",
        add_layer: " ",
        upload_vector_file: "   ",
        drag_drop_click: "   ",
        export_chart: "  ",
        draw_polygon_prompt:
          '   ,    " "   ',
        data_analytics: " ",
        clear_all_layers: " ",
        map_controls: " ",
        opt_w: " ",

        // --- New Items Added Below (Hindi) ---
        opt_op: ":",
        opt_lo: "  :",
        opt_ex: "  ",
        opt_lm: " ",
        opt_csl: "    ",
        opt_cc: "  ",
        opt_wp: "  :",
        opt_evt: "   (ET) ()",
        opt_rp: "/ ()",
        opt_tmp: " (C)",
        opt_hum: " (%)",
        opt_Draw: " ,  ,  ' '   ",
        opt_nst: "   ",
        opt_nst: "   ",
        opt_overview: " ",
        opt_detailed: " ",
        opt_visual: "",
        opt_meana: " ( )",
        opt_median: " ( )",
        opt_p75: "P75 ( 25% )",
        opt_p25: "P25 ( 25%)",
        opt_overall_health: "   ",
        opt_vegetation_cover: "  ",
        opt_time_scale: " :",
        opt_monthly: "",
        opt_weekly: "",
        opt_analyze: " ",
        opt_select_period: " :",
        opt_water: "",
        opt_bare_land: " ",
        opt_builtup: "",
        opt_sparse_veg: " ",
        opt_full_veg: " ",
        opt_total_periods: " :",
        opt_date_range: " :",
        opt_soilmoisture: "  ",
        opt_search_placeholder: " ...",
        opt_no_results: "   ",
        opt_search_failed: "     ",
        opt_location_found: " ",
        opt_centered_map: "   ",
        opt_draw_shape_first: "   ",
        opt_changes_saved: "  ",
        opt_no_shape_to_save: "     ",
        opt_missing_info: " ",
        opt_draw_aoi_first:
          "       (AOI) ",
        opt_select_dates: "     ",
        opt_no_data: "  ",
        opt_no_land_cover: "          ",
        opt_error: "",
        opt_failed_analyze: "      :",
        opt_date_range_error: "   1     ",
        opt_something_wrong: "PDF      !",
        opt_oops: " ...",
        opt_min: "",
        opt_max: "",
        opt_mean_label: "",
        opt_median_label: "",
        opt_stddev: " ",
        opt_min_label: "",
        opt_max_label: "",
        opt_range: "",
        opt_average: "",
        opt_range_label: "",
        opt_draw_polygon_title: " ",
        opt_draw_rectangle_title: " ",
        opt_edit_shapes_title: " ",
        opt_save_changes_title: "  ",
        opt_delete_shapes_title: " ",
        opt_shape_deleted: "  ",
        opt_shape_removed_map: "        ",
        opt_nothing_to_delete: "    ",
        opt_draw_shape_to_delete: "        ",
        excellent_condition: "  ( /)",
        good_condition: " ",
        fair_condition: "  ( )",
        poor_condition: " ",
        no_data: "--",
        what_does_this_mean: "   ?",
        needs_attention: "    (< 0.3)",
        medium_health: "  (0.3 - 0.5)",
        good_health: "  (0.5 - 0.7)",
        excellent_health: "  (> 0.7)",
        quick_tips: " ",
        tip_mean: "    ",
        tip_range: "    ",
        tip_p90: "   ",
        tip_monitor: "    ",
        // Temperature
        very_cool: " ",
        comfortable: "",
        warm: "",
        hot: " ",

        // Crop Coefficient
        low_kc: "  ",
        moderate_kc: "  ",
        high_kc: "  ",
        very_high_kc: "   ",

        // ... existing translations
        opt_savi: "  ",
        opt_cwsi: "  ",
        opt_lai: " ",
        // ... rest of translations

        // Common
        no_data: "--",
        opt_irrigation_need: " ",
        irrigation_label: "",
        soil_moisture_label: "  ",
        cwsi_label: "CWSI",
        rain_label: "",
        irrigation_event: " ",
        total_events: " ",
        total_irrigation: " ",
        avg_interval: "  ()",
        avg_event_amount: "  ",
        last_event_date: "  ",
        water_saved: "  ",
        savings: "",
        total_water: " ",
      },
    };



    function t(key) {
      const lang = currentLang || "en";
      return i18n[lang] && i18n[lang][key] ? i18n[lang][key] : key;
    }

    let currentLang = localStorage.getItem("site_lang") || "en";

    function applyLanguage(lang) {
      currentLang = lang;
      localStorage.setItem("site_lang", lang);
      document.documentElement.lang = lang;
      document.querySelectorAll(".lang-btn").forEach((btn) => {
        btn.classList.toggle("active", btn.dataset.lang === lang);
      });

      // ---  YEH FUNCTION UPDATE KIYA GAYA HAI  ---
      document
        .querySelectorAll("[data-i18n], [data-i18n-title]")
        .forEach((el) => {
          const key = el.getAttribute("data-i18n");
          const titleKey = el.getAttribute("data-i18n-title");

          // Translate inner text (spans, buttons, etc.)
          if (key) {
            if (
              el.tagName.toLowerCase() === "input" &&
              (el.type === "text" || el.type === "search")
            ) {
              el.placeholder = t(key);
            } else if (el.tagName.toLowerCase() === "option") {
              el.textContent = t(key);
            } else {
              el.textContent = t(key);
            }
          }

          // --- NEW --- Translate title (hover text)
          if (titleKey) {
            el.title = t(titleKey);
          }
        });

      // Update search placeholder specifically
      const searchInput = document.getElementById("locationSearch");
      if (searchInput) {
        searchInput.placeholder = t("opt_search_placeholder");
      }

      // Do not change which panel is visible on language switch; only text updates above.
    }

    document.querySelectorAll(".lang-btn").forEach((btn) => {
      btn.addEventListener("click", (e) => {
        applyLanguage(e.target.dataset.lang);
      });
    });

    applyLanguage(currentLang);

    // Land Cover Analysis Functions
    async function runLandCoverAnalysis() {
      if (!drawnAOI) {
        Swal.fire(t("opt_missing_info"), t("opt_draw_aoi_first"), "warning");
        return;
      }

      const start_date = document.getElementById("start").value;
      const end_date = document.getElementById("end").value;
      const timeScale = document.getElementById("timeScaleSelect").value;

      if (!start_date || !end_date) {
        Swal.fire(t("opt_missing_info"), t("opt_select_dates"), "warning");
        return;
      }

      document.getElementById("spinner").style.display = "block";

      try {
        const response = await fetch("/get_land_cover_analysis", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            aoi: drawnAOI.toGeoJSON(),
            start_date: start_date,
            end_date: end_date,
            time_scale: timeScale,
          }),
        });

        if (!response.ok) {
          throw new Error(t("opt_date_range_error"));
        }

        const data = await response.json();

        if (data.error) {
          throw new Error(data.error);
        }

        if (data.success && data.data && data.data.length > 0) {
          displayLandCoverResults(data);
        } else {
          Swal.fire(t("opt_no_data"), t("opt_no_land_cover"), "info");
        }
      } catch (error) {
        console.error("Land cover analysis error:", error);
        Swal.fire(
          t("opt_error"),
          `${t("opt_failed_analyze")} ${error.message}`,
          "error"
        );
      } finally {
        document.getElementById("spinner").style.display = "none";
      }
    }

    function displayLandCoverResults(data) {
      // Store results globally
      landCoverResults = data;

      //  Save land cover data to localStorage for dashboard
      try {
        localStorage.setItem('lastLandCoverData', JSON.stringify(data));
        console.log(' Land cover data saved to localStorage for dashboard');
      } catch (e) {
        console.warn('Failed to save land cover data to localStorage:', e);
      }

      // Populate period selector
      const periodSelect = document.getElementById("periodSelect");
      periodSelect.innerHTML = "";

      data.data.forEach((periodData, index) => {
        const option = document.createElement("option");
        option.value = index;
        option.textContent = periodData.period;
        periodSelect.appendChild(option);
      });

      // Show the period selector
      document.getElementById("periodSelector").style.display = "block";

      // Update summary info
      document.getElementById("totalPeriods").textContent = data.data.length;
      document.getElementById("dateRange").textContent = `${data.data[0]?.period
        } to ${data.data[data.data.length - 1]?.period}`;
      document.getElementById("timeScaleDisplay").textContent =
        data.time_scale;
      document.getElementById("landCoverSummary").style.display = "block";

      // Display first period's data
      updateLandCoverChart();
    }

    function updateLandCoverChart() {
      const periodSelect = document.getElementById("periodSelect");
      const selectedIndex = parseInt(periodSelect.value);

      if (!landCoverResults || !landCoverResults.data[selectedIndex]) return;

      const landCoverData = landCoverResults.data[selectedIndex];

      // Update the land cover pie chart
      renderLandCoverPieChart(landCoverData);
    }

    function renderLandCoverPieChart(periodData) {
      const ctx = document.getElementById("landCoverChart").getContext("2d");

      // Destroy existing chart if it exists
      if (landCoverChart) {
        landCoverChart.destroy();
      }

      const percentages = periodData.percentages;
      const data = [
        percentages["Water"] || 0,
        percentages["Bare Land"] || 0,
        percentages["Built-up"] || 0,
        percentages["Sparse Vegetation"] || 0,
        percentages["Dense Vegetation"] || 0,
      ];

      const colors = ["#1e88e5", "#8d6e63", "#78909c", "#c0ca33", "#43a047"];

      landCoverChart = new Chart(ctx, {
        type: "pie",
        data: {
          labels: [
            "Water",
            "Bare Land",
            "Built-up",
            "Sparse Vegetation",
            "Dense Vegetation",
          ],
          datasets: [
            {
              data: data,
              backgroundColor: colors,
              borderWidth: 2,
              borderColor: "#fff",
            },
          ],
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: false,
            },
            tooltip: {
              callbacks: {
                label: function (context) {
                  const label = context.label || "";
                  const value = context.parsed;
                  const total = context.dataset.data.reduce(
                    (a, b) => a + b,
                    0
                  );
                  const percentage =
                    total > 0 ? ((value / total) * 100).toFixed(1) : "0";
                  return `${label}: ${value}% (${(
                    (value / 100) *
                    (periodData.total_pixels || 0)
                  ).toLocaleString()} pixels)`;
                },
              },
            },
            title: {
              display: true,
              text: `Land Cover - ${periodData.period}`,
              font: {
                size: 14,
              },
            },
          },
        },
      });

      // Update percentage displays
      updateLandCoverPercentages(
        periodData.percentages,
        periodData.pixel_counts
      );
    }

    function updateLandCoverPercentages(percentages, pixelCounts) {
      document.getElementById("water-percent").textContent = `${percentages["Water"] || 0
        }%`;
      document.getElementById("bare-percent").textContent = `${percentages["Bare Land"] || 0
        }%`;
      document.getElementById("builtup-percent").textContent = `${percentages["Built-up"] || 0
        }%`;
      document.getElementById("sparse-percent").textContent = `${percentages["Sparse Vegetation"] || 0
        }%`;
      document.getElementById("fullveg-percent").textContent = `${percentages["Dense Vegetation"] || 0
        }%`;

      // Optional: Show pixel counts on hover or in tooltip
      const elements = document.querySelectorAll('[id$="-percent"]');
      elements.forEach((element) => {
        const type = element.id
          .replace("-percent", "")
          .replace(/([A-Z])/g, " $1")
          .trim();
        const pixelKey = Object.keys(pixelCounts || {}).find((key) =>
          key.toLowerCase().includes(type.toLowerCase().split(" ")[0])
        );
        const count = pixelCounts?.[pixelKey] || 0;
        element.title = `${count.toLocaleString()} pixels`;
      });
    }

    // Initialize the map size after a short delay
    setTimeout(() => map.invalidateSize(), 500);
  </script>
  <script src="https://www.example.com/js/lib/vapi-0.3.js"></script>
</body>

<!-- Add this section to your HTML form where you want irrigation need button -->

<div class="form-section mt-4 border-top pt-4">
  <h5 class="icon-heading">
    <i class="fa-solid fa-droplet" data-i18n="i1"></i>
    Irrigation Need Analysis
  </h5>
  <small class="text-muted">Calculate water requirement based on LANDSAT data, ETo, and
    rainfall</small>

  <div class="button-group mt-3">
    <button id="irrigationNeedBtn" class="btn btn-success btn-lg" style="width: 100%">
      <i class="fa-solid fa-droplet" data-i18n="i2"></i>
      Calculate Irrigation Need
    </button>
  </div>
</div>

<!-- Results Container -->
<div id="irrigationResultsContainer" style="margin-top: 20px; display: none">
  <div class="alert alert-info">
    <h5 class="icon-heading">
      <i class="fa-solid fa-droplet" data-i18n="i3"></i>
      Irrigation Need Results
    </h5>
    <div id="irrigationResults"></div>
  </div>
</div>

<!-- Time Series Chart -->
<div id="irrigationChartContainer" style="margin-top: 20px; display: none">
  <canvas id="irrigationChart" width="400" height="100"></canvas>
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>

<script>

  // Add this with other global variables at the top
  let currentSearchMarker = null;
  let currentLayer = null;
  let currentLayerName = null;
  let currentLayerData = null;
  // ============================================================================
  // IRRIGATION NEED CALCULATION
  // ============================================================================

  document
    .getElementById("irrigationNeedBtn")
    .addEventListener("click", async function () {
      const aoiData = getAOIData();

      if (!aoiData) {
        showAlert(" Please define an AOI first", "warning");
        return;
      }

      const startDate = document.getElementById("startDate")?.value;
      const endDate = document.getElementById("endDate")?.value;

      if (!startDate || !endDate) {
        showAlert(" Please select start and end dates", "warning");
        return;
      }

      const payload = {
        aoi: aoiData,
        start_date: startDate,
        end_date: endDate,
      };

      try {
        showAlert(
          " Calculating irrigation need from LANDSAT data...",
          "info"
        );

        const response = await fetch("/get_irrigation_need", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        });

        const data = await response.json();

        if (!response.ok) {
          showAlert(" " + (data.error || "Calculation failed"), "danger");
          return;
        }

        if (data.success && data.irrigation_data) {
          displayIrrigationResults(data.irrigation_data);
          showAlert(
            ` Analysis complete!\n Analyzed ${data.total_dates} dates\n Data Source: ${data.data_source}`,
            "success"
          );
        } else {
          showAlert(" No data available", "danger");
        }
      } catch (error) {
        console.error("Error:", error);
        showAlert(" Server error: " + error.message, "danger");
      }
    });

  // ============================================================================
  // DISPLAY IRRIGATION RESULTS TABLE
  // ============================================================================

  function displayIrrigationResults(irrigationData) {
    const container = document.getElementById("irrigationResults");

    // Create summary statistics
    const irrigationNeeds = irrigationData
      .map((d) => d.irrigation_need_mean)
      .filter((v) => v !== null && v !== undefined);

    const avgIrrNeed =
      irrigationNeeds.length > 0
        ? (
          irrigationNeeds.reduce((a, b) => a + b, 0) /
          irrigationNeeds.length
        ).toFixed(2)
        : "N/A";

    const maxIrrNeed =
      irrigationNeeds.length > 0
        ? Math.max(...irrigationNeeds).toFixed(2)
        : "N/A";

    // Summary box
    let html = `
        <div class="alert alert-success mb-3">
           <h6 class="icon-heading">
  <i class="fa-solid fa-chart-simple"></i>
  Summary Statistics
</h6>
            <div class="row">
                <div class="col-md-4">
                    <strong>Average Irrigation Need:</strong><br>
                    <span style="font-size: 1.5em; color: #28a745;">${avgIrrNeed} mm/day</span>
                </div>
                <div class="col-md-4">
                    <strong>Maximum Irrigation Need:</strong><br>
                    <span style="font-size: 1.5em; color: #dc3545;">${maxIrrNeed} mm/day</span>
                </div>
                <div class="col-md-4">
                    <strong>Total Days Analyzed:</strong><br>
                    <span style="font-size: 1.5em; color: #0070d0;">${irrigationData.length} days</span>
                </div>
            </div>
        </div>
    `;

    // Detailed table
    html += `
        <table class="table table-striped table-sm">
            <thead class="table-dark">
                <tr>
                    <th>Date</th>
                    <th>CWR (mm)</th>
                    <th>Rainfall (mm)</th>
                    <th>Irr. Need (mm)</th>
                    <th>Kc</th>
                    <th>ETo (mm)</th>
                    <th>Recommendation</th>
                </tr>
            </thead>
            <tbody>
    `;

    irrigationData.forEach((d) => {
      const date = d.date || "N/A";
      const cwr = d.cwr_mean !== null ? d.cwr_mean.toFixed(2) : "N/A";
      const rainfall =
        d.effective_rainfall !== null
          ? d.effective_rainfall.toFixed(2)
          : "N/A";
      const irrNeed =
        d.irrigation_need_mean !== null
          ? d.irrigation_need_mean.toFixed(2)
          : "N/A";
      const kc = d.kc_mean !== null ? d.kc_mean.toFixed(3) : "N/A";
      const eto =
        d.eto_mm_per_day !== null ? d.eto_mm_per_day.toFixed(2) : "N/A";
      const recommendation = d.irrigation_recommendation || "N/A";

      let badgeColor = "secondary";
      if (d.status === "green") badgeColor = "success";
      else if (d.status === "yellow") badgeColor = "warning";
      else if (d.status === "orange") badgeColor = "warning";
      else if (d.status === "red") badgeColor = "danger";

      html += `
            <tr>
                <td><strong>${date}</strong></td>
                <td>${cwr}</td>
                <td>${rainfall}</td>
                <td><strong style="color: ${getColorForValue(
        irrNeed
      )}">${irrNeed}</strong></td>
                <td>${kc}</td>
                <td>${eto}</td>
                <td><span class="badge bg-${badgeColor}">${recommendation}</span></td>
            </tr>
        `;
    });

    html += `
            </tbody>
        </table>
    `;

    html += `
        <hr>
       <h6 class="icon-heading">
  <i class="fa-solid fa-clipboard-list"></i>
  Legend:
</h6>
        <ul style="font-size: 0.9em;">
            <li><strong>CWR:</strong> Crop Water Requirement (ETo  Kc)</li>
            <li><strong>Rainfall:</strong> Effective Rainfall (60% of total precipitation)</li>
            <li><strong>Irr. Need:</strong> (CWR - Rainfall) / Irrigation Efficiency (0.6)</li>
            <li><strong>Kc:</strong> Crop Coefficient (from SAVI)</li>
<li style="color: #28a745;"><i class="fa-solid fa-check-circle"></i> <strong>Green:</strong> Sufficient rainfall, no irrigation needed</li>
<li style="color: #ffc107;"><i class="fa-solid fa-exclamation-triangle"></i> <strong>Yellow:</strong> Light irrigation (&lt;2 mm/day)</li>
<li style="color: #ff6c00;"><i class="fa-solid fa-circle-exclamation"></i> <strong>Orange:</strong> Moderate irrigation (2-5 mm/day)</li>
<li style="color: #dc3545;"><i class="fa-solid fa-circle-xmark"></i> <strong>Red:</strong> Heavy irrigation (&gt;5 mm/day)</li>
        </ul>
    `;

    container.innerHTML = html;
    document.getElementById("irrigationResultsContainer").style.display =
      "block";

    // Draw chart
    drawIrrigationChart(irrigationData);
  }

  // ============================================================================
  // DRAW IRRIGATION NEED CHART
  // ============================================================================

  function drawIrrigationChart(irrigationData) {
    const canvas = document.getElementById("irrigationChart");
    if (!canvas) return;

    // Prepare data
    const dates = irrigationData.map((d) => d.date);
    const cwrValues = irrigationData.map((d) => d.cwr_mean || 0);
    const rainfallValues = irrigationData.map(
      (d) => d.effective_rainfall || 0
    );
    const irrNeeds = irrigationData.map((d) => d.irrigation_need_mean || 0);

    // Destroy existing chart if it exists
    if (window.irrigationChartInstance) {
      window.irrigationChartInstance.destroy();
    }

    const ctx = canvas.getContext("2d");
    window.irrigationChartInstance = new Chart(ctx, {
      type: "line",
      data: {
        labels: dates,
        datasets: [
          {
            label: "CWR (mm/day)",
            data: cwrValues,
            borderColor: "#ff7300",
            backgroundColor: "rgba(255, 115, 0, 0.1)",
            borderWidth: 2,
            pointRadius: 4,
            tension: 0.3,
          },
          {
            label: "Effective Rainfall (mm)",
            data: rainfallValues,
            borderColor: "#0070d0",
            backgroundColor: "rgba(0, 112, 208, 0.1)",
            borderWidth: 2,
            pointRadius: 4,
            tension: 0.3,
          },
          {
            label: "Irrigation Need (mm/day)",
            data: irrNeeds,
            borderColor: "#dc3545",
            backgroundColor: "rgba(220, 53, 69, 0.1)",
            borderWidth: 3,
            pointRadius: 5,
            pointBackgroundColor: "#dc3545",
            tension: 0.3,
          },
        ],
      },
      options: {
        responsive: true,
        plugins: {
          legend: {
            position: "top",
            labels: {
              font: { size: 12 },
            },
          },
          title: {
            display: true,
            text: "Irrigation Need Time Series",
            font: { size: 16, weight: "bold" },
            // Add custom HTML rendering for icon
            padding: {
              top: 10,
              bottom: 10
            }
          }
        },
        scales: {
          y: {
            title: {
              display: true,
              text: "Water (mm/day)",
            },
            beginAtZero: true,
          },
          x: {
            title: {
              display: true,
              text: "Date",
            },
          },
        },
      },
    });

    document.getElementById("irrigationChartContainer").style.display =
      "block";
  }

  // ============================================================================
  // HELPER: Get color for irrigation need value
  // ============================================================================

  function getColorForValue(value) {
    const num = parseFloat(value);
    if (isNaN(num) || num === null) return "#666";
    if (num < 0) return "#28a745"; // Green - sufficient rainfall
    if (num < 2) return "#ffc107"; // Yellow - light
    if (num < 5) return "#ff6c00"; // Orange - moderate
    return "#dc3545"; // Red - heavy
  }




  // Add event listener for the irrigation calendar button
  document.getElementById('irrigationCalendarBtn').addEventListener('click', generateIrrigationCalendar);

  async function generateIrrigationCalendar() {
    if (!drawnAOI) {
      Swal.fire({
        icon: 'warning',
        title: 'Draw AOI First',
        text: 'Please draw an Area of Interest on the map first.'
      });
      return;
    }

    const start_date = document.getElementById('start').value;
    const end_date = document.getElementById('end').value;

    if (!start_date || !end_date) {
      Swal.fire({
        icon: 'warning',
        title: 'Select Dates',
        text: 'Please select start and end dates.'
      });
      return;
    }

    // Expand the irrigation calendar panel
    if (typeof expandIrrigationCalendarPanel === 'function') {
      expandIrrigationCalendarPanel();
    }

    // Show loading state in the panel
    const loadingElement = document.getElementById('irrigation-calendar-loading');
    const displayElement = document.getElementById('irrigation-calendar-display');
    const buttonContainer = document.getElementById('irrigation-calendar-button-container');

    if (loadingElement) loadingElement.style.display = 'block';
    if (displayElement) displayElement.style.display = 'none';
    if (buttonContainer) buttonContainer.style.display = 'none';

    // Show loading
    document.getElementById('spinner').style.display = 'block';

    try {
      const response = await fetch('/get_irrigation_calendar', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          aoi: drawnAOI.toGeoJSON(),
          start_date: start_date,
          end_date: end_date,
          rain_threshold: 2.0,
          cwsi_threshold: 0.2,
          sm_threshold: 25.0
        })
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error || 'Failed to generate irrigation calendar');
      }

      if (data.success) {
        irrigationCalendarData = data;
        displayIrrigationCalendar(data);

        //  Save irrigation calendar data and AOI to localStorage for dashboard
        try {
          localStorage.setItem('lastIrrigationCalendar', JSON.stringify(data));
          localStorage.setItem('recentAOI', JSON.stringify(drawnAOI.toGeoJSON()));
          console.log(' Irrigation calendar saved to localStorage for dashboard');
        } catch (e) {
          console.warn('Failed to save irrigation calendar to localStorage:', e);
        }

        // Don't call ensureRightPanelOpen() - keep the right panel as is

        Swal.fire({
          icon: 'success',
          title: 'Calendar Generated!',
          text: `Found ${data.summary.irrigation.total_events} irrigation events`,
          timer: 2000,
          showConfirmButton: false
        });
      } else {
        throw new Error(data.error || 'Calendar generation failed');
      }

    } catch (error) {
      console.error('Irrigation calendar error:', error);
      // Hide loading, show button again on error
      const loadingElement = document.getElementById('irrigation-calendar-loading');
      const displayElement = document.getElementById('irrigation-calendar-display');
      const buttonContainer = document.getElementById('irrigation-calendar-button-container');

      if (loadingElement) loadingElement.style.display = 'none';
      if (displayElement) displayElement.style.display = 'none';
      if (buttonContainer) buttonContainer.style.display = 'block';

      Swal.fire({
        icon: 'error',
        title: 'Calendar Generation Failed',
        text: error.message
      });
    } finally {
      document.getElementById('spinner').style.display = 'none';
    }
  }

  function displayIrrigationCalendar(data) {
    const calendarDisplay = document.getElementById('irrigation-calendar-display');
    let html = '';

    // Summary section with translations
    if (data.summary) {
      const summary = data.summary;
      html += `
            <div style="background: #e8f5e8; padding: 12px; border-radius: 8px; margin-bottom: 16px;">
                <h4 class="icon-heading" style="margin: 0 0 8px 0; color: var(--krishi-dark);">
                  <i class="fa-solid fa-chart-simple"></i>
                  <span data-i18n="summary_title">Summary</span>
                </h4>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 12px;">
                    <div><strong data-i18n="total_events">Total Events:</strong> ${summary.irrigation?.total_events || 0}</div>
                    <div><strong data-i18n="total_water">Total Water:</strong> ${summary.irrigation?.total_water_mm || 0} mm</div>
                    <div><strong data-i18n="water_saved">Water Saved:</strong> ${summary.irrigation?.water_saved_mm || 0} mm</div>
                    <div><strong data-i18n="savings">Savings:</strong> ${summary.irrigation?.savings_percent || 0}%</div>
                </div>
            </div>
        `;
    }

    // Calendar events with translations
    if (data.calendar && data.calendar.length > 0) {
      html += '<div>';
      data.calendar.forEach(day => {
        const priorityColor = getPriorityColor(day.priority);
        const icon = day.should_irrigate
          ? '<i class="fa-solid fa-droplet" style="color: #0ea5e9;"></i>'
          : '<i class="fa-solid fa-circle-check" style="color: #22c55e;"></i>';

        html += `
                <div style="border: 1px solid var(--border-color); border-radius: 8px; padding: 12px; margin-bottom: 8px; background: white;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                        <strong style="color: var(--krishi-dark);">${day.date}</strong>
                        <span style="background: ${priorityColor}; color: white; padding: 2px 8px; border-radius: 12px; font-size: 11px; font-weight: bold;">
                            ${day.priority}
                        </span>
                    </div>
                    <div style="font-size: 13px; margin-bottom: 4px;">
                        ${icon} ${day.advice}
                    </div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px; font-size: 11px; color: #666;">
                        <div><span data-i18n="rain_label">Rain:</span> ${day.rain_mm}mm</div>
                        <div><span data-i18n="soil_moisture_label">Soil Moisture:</span> ${day.soil_moisture_percent}%</div>
                        <div><span data-i18n="cwsi_label">CWSI:</span> ${day.cwsi_mean}</div>
                        <div><span data-i18n="irrigation_label">Irrigation</span> ${day.final_irrigation_mm}mm</div>
                    </div>
                </div>
            `;
      });
      html += '</div>';
    } else {
      html += `<p style="text-align: center; color: #666; padding: 20px;" data-i18n="no_irrigation_events">No irrigation events found for the selected period.</p>`;
    }

    if (calendarDisplay) {
      calendarDisplay.innerHTML = html;
      calendarDisplay.style.display = 'block';

      // Re-apply translations to newly added content
      applyLanguage(currentLang);
    }

    const loadingElement = document.getElementById('irrigation-calendar-loading');
    const buttonContainer = document.getElementById('irrigation-calendar-button-container');

    if (loadingElement) loadingElement.style.display = 'none';
    if (buttonContainer) buttonContainer.style.display = 'none';
  }

  function getPriorityColor(priority) {
    switch (priority) {
      case 'URGENT': return '#dc3545';
      case 'HIGH': return '#fd7e14';
      case 'MEDIUM': return '#ffc107';
      case 'LOW': return '#28a745';
      default: return '#6c757d';
    }
  }

  // --- Legend Toggle Handlers ---



  function toggleLegendContrast(checkbox) {
    useHighContrast = checkbox.checked;
    console.log("High Contrast toggled:", useHighContrast);

    // 1. Refresh the legend to show new colors
    const currentLayerVal = document.getElementById("layer").value;

    // Pass the existing stats if we have them saved in currentLayerData
    const stats = currentLayerData ? currentLayerData.stats : null;
    updateMapLegend(currentLayerVal, stats);

    // 2. OPTIONAL: If you want to actually change the Map Layer color (requires backend support)
    // Usually, you might just want to reload the tile layer with a different palette param
    // or just change the Charts colors.

    // Update charts to match new colors
    if (chartStyles[currentLayerVal]) {
      chartStyles[currentLayerVal].color = useHighContrast ? '#ff5722' : '#2f7a2f';
      // Trigger a chart update if needed
      if (typeof updateChartTheme === 'function') updateChartTheme();
    }
  }

  // Add to your language translations
  i18n.en.irrigation_calendar = "Irrigation Calendar";
  i18n.en.generate_calendar = "Generate Irrigation Calendar";
  i18n.en.irrigation_schedule = "Irrigation Schedule";

  i18n.hi.irrigation_calendar = " ";
  i18n.hi.generate_calendar = "  ";
  i18n.hi.irrigation_schedule = " ";
</script>

<!-- Include Chart.js for visualization -->

</html>